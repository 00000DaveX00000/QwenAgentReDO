var bi = Object.defineProperty;
var Nn = (c) => {
  throw TypeError(c);
};
var yi = (c, a, h) => a in c ? bi(c, a, { enumerable: !0, configurable: !0, writable: !0, value: h }) : c[a] = h;
var _t = (c, a, h) => yi(c, typeof a != "symbol" ? a + "" : a, h), en = (c, a, h) => a.has(c) || Nn("Cannot " + h);
var w = (c, a, h) => (en(c, a, "read from private field"), h ? h.call(c) : a.get(c)), Ee = (c, a, h) => a.has(c) ? Nn("Cannot add the same private member more than once") : a instanceof WeakSet ? a.add(c) : a.set(c, h), Se = (c, a, h, d) => (en(c, a, "write to private field"), d ? d.call(c, h) : a.set(c, h), h), _e = (c, a, h) => (en(c, a, "access private method"), h);
var Mt = (c, a, h, d) => ({
  set _(u) {
    Se(c, a, u, h);
  },
  get _() {
    return w(c, a, d);
  }
});
const React = window.ms_globals.React, useState = window.ms_globals.React.useState, useEffect = window.ms_globals.React.useEffect, useRef = window.ms_globals.React.useRef, useMemo = window.ms_globals.React.useMemo, ReactDOM = window.ms_globals.ReactDOMClient, StyleProvider = window.ms_globals.antdCssinjs.StyleProvider, legacyLogicalPropertiesTransformer = window.ms_globals.antdCssinjs.legacyLogicalPropertiesTransformer, Button$1 = window.ms_globals.antd.Button, Image$3 = window.ms_globals.antd.Image, ConfigProvider = window.ms_globals.antd.ConfigProvider, theme = window.ms_globals.antd.theme, CaretLeftOutlined = window.ms_globals.antdIcons.CaretLeftOutlined, CaretRightOutlined = window.ms_globals.antdIcons.CaretRightOutlined, FileOutlined = window.ms_globals.antdIcons.FileOutlined, {
  SvelteComponent: SvelteComponent$2t,
  assign: assign$7,
  children: children$2m,
  claim_element: claim_element$u,
  create_slot: create_slot$b,
  detach: detach$2o,
  element: element$u,
  get_all_dirty_from_scope: get_all_dirty_from_scope$b,
  get_slot_changes: get_slot_changes$b,
  get_spread_update: get_spread_update$6,
  init: init$2t,
  insert_hydration: insert_hydration$2o,
  safe_not_equal: safe_not_equal$2u,
  set_dynamic_element_data: set_dynamic_element_data$1,
  set_style: set_style$e,
  toggle_class: toggle_class$o,
  transition_in: transition_in$z,
  transition_out: transition_out$z,
  update_slot_base: update_slot_base$b
} = window.__gradio__svelte__internal;
function create_dynamic_element(c) {
  let a, h, d;
  const u = (
    /*#slots*/
    c[18].default
  ), _ = create_slot$b(
    u,
    c,
    /*$$scope*/
    c[17],
    null
  );
  let g = [{
    "data-testid": (
      /*test_id*/
      c[7]
    )
  }, {
    id: (
      /*elem_id*/
      c[2]
    )
  }, {
    class: h = "block " + /*elem_classes*/
    c[3].join(" ") + " svelte-nl1om8"
  }], $ = {};
  for (let b = 0; b < g.length; b += 1)
    $ = assign$7($, g[b]);
  return {
    c() {
      a = element$u(
        /*tag*/
        c[14]
      ), _ && _.c(), this.h();
    },
    l(b) {
      a = claim_element$u(
        b,
        /*tag*/
        (c[14] || "null").toUpperCase(),
        {
          "data-testid": !0,
          id: !0,
          class: !0
        }
      );
      var y = children$2m(a);
      _ && _.l(y), y.forEach(detach$2o), this.h();
    },
    h() {
      set_dynamic_element_data$1(
        /*tag*/
        c[14]
      )(a, $), toggle_class$o(
        a,
        "hidden",
        /*visible*/
        c[10] === !1
      ), toggle_class$o(
        a,
        "padded",
        /*padding*/
        c[6]
      ), toggle_class$o(
        a,
        "border_focus",
        /*border_mode*/
        c[5] === "focus"
      ), toggle_class$o(
        a,
        "border_contrast",
        /*border_mode*/
        c[5] === "contrast"
      ), toggle_class$o(a, "hide-container", !/*explicit_call*/
      c[8] && !/*container*/
      c[9]), set_style$e(
        a,
        "height",
        /*get_dimension*/
        c[15](
          /*height*/
          c[0]
        )
      ), set_style$e(a, "width", typeof /*width*/
      c[1] == "number" ? `calc(min(${/*width*/
      c[1]}px, 100%))` : (
        /*get_dimension*/
        c[15](
          /*width*/
          c[1]
        )
      )), set_style$e(
        a,
        "border-style",
        /*variant*/
        c[4]
      ), set_style$e(
        a,
        "overflow",
        /*allow_overflow*/
        c[11] ? "visible" : "hidden"
      ), set_style$e(
        a,
        "flex-grow",
        /*scale*/
        c[12]
      ), set_style$e(a, "min-width", `calc(min(${/*min_width*/
      c[13]}px, 100%))`), set_style$e(a, "border-width", "var(--block-border-width)");
    },
    m(b, y) {
      insert_hydration$2o(b, a, y), _ && _.m(a, null), d = !0;
    },
    p(b, y) {
      _ && _.p && (!d || y & /*$$scope*/
      131072) && update_slot_base$b(
        _,
        u,
        b,
        /*$$scope*/
        b[17],
        d ? get_slot_changes$b(
          u,
          /*$$scope*/
          b[17],
          y,
          null
        ) : get_all_dirty_from_scope$b(
          /*$$scope*/
          b[17]
        ),
        null
      ), set_dynamic_element_data$1(
        /*tag*/
        b[14]
      )(a, $ = get_spread_update$6(g, [(!d || y & /*test_id*/
      128) && {
        "data-testid": (
          /*test_id*/
          b[7]
        )
      }, (!d || y & /*elem_id*/
      4) && {
        id: (
          /*elem_id*/
          b[2]
        )
      }, (!d || y & /*elem_classes*/
      8 && h !== (h = "block " + /*elem_classes*/
      b[3].join(" ") + " svelte-nl1om8")) && {
        class: h
      }])), toggle_class$o(
        a,
        "hidden",
        /*visible*/
        b[10] === !1
      ), toggle_class$o(
        a,
        "padded",
        /*padding*/
        b[6]
      ), toggle_class$o(
        a,
        "border_focus",
        /*border_mode*/
        b[5] === "focus"
      ), toggle_class$o(
        a,
        "border_contrast",
        /*border_mode*/
        b[5] === "contrast"
      ), toggle_class$o(a, "hide-container", !/*explicit_call*/
      b[8] && !/*container*/
      b[9]), y & /*height*/
      1 && set_style$e(
        a,
        "height",
        /*get_dimension*/
        b[15](
          /*height*/
          b[0]
        )
      ), y & /*width*/
      2 && set_style$e(a, "width", typeof /*width*/
      b[1] == "number" ? `calc(min(${/*width*/
      b[1]}px, 100%))` : (
        /*get_dimension*/
        b[15](
          /*width*/
          b[1]
        )
      )), y & /*variant*/
      16 && set_style$e(
        a,
        "border-style",
        /*variant*/
        b[4]
      ), y & /*allow_overflow*/
      2048 && set_style$e(
        a,
        "overflow",
        /*allow_overflow*/
        b[11] ? "visible" : "hidden"
      ), y & /*scale*/
      4096 && set_style$e(
        a,
        "flex-grow",
        /*scale*/
        b[12]
      ), y & /*min_width*/
      8192 && set_style$e(a, "min-width", `calc(min(${/*min_width*/
      b[13]}px, 100%))`);
    },
    i(b) {
      d || (transition_in$z(_, b), d = !0);
    },
    o(b) {
      transition_out$z(_, b), d = !1;
    },
    d(b) {
      b && detach$2o(a), _ && _.d(b);
    }
  };
}
function create_fragment$y(c) {
  let a, h = (
    /*tag*/
    c[14] && create_dynamic_element(c)
  );
  return {
    c() {
      h && h.c();
    },
    l(d) {
      h && h.l(d);
    },
    m(d, u) {
      h && h.m(d, u), a = !0;
    },
    p(d, [u]) {
      /*tag*/
      d[14] && h.p(d, u);
    },
    i(d) {
      a || (transition_in$z(h, d), a = !0);
    },
    o(d) {
      transition_out$z(h, d), a = !1;
    },
    d(d) {
      h && h.d(d);
    }
  };
}
function instance$i(c, a, h) {
  let {
    $$slots: d = {},
    $$scope: u
  } = a, {
    height: _ = void 0
  } = a, {
    width: g = void 0
  } = a, {
    elem_id: $ = ""
  } = a, {
    elem_classes: b = []
  } = a, {
    variant: y = "solid"
  } = a, {
    border_mode: v = "base"
  } = a, {
    padding: E = !0
  } = a, {
    type: S = "normal"
  } = a, {
    test_id: R = void 0
  } = a, {
    explicit_call: x = !1
  } = a, {
    container: H = !0
  } = a, {
    visible: T = !0
  } = a, {
    allow_overflow: C = !0
  } = a, {
    scale: O = null
  } = a, {
    min_width: j = 0
  } = a, B = S === "fieldset" ? "fieldset" : "div";
  const D = (M) => {
    if (M !== void 0) {
      if (typeof M == "number")
        return M + "px";
      if (typeof M == "string")
        return M;
    }
  };
  return c.$$set = (M) => {
    "height" in M && h(0, _ = M.height), "width" in M && h(1, g = M.width), "elem_id" in M && h(2, $ = M.elem_id), "elem_classes" in M && h(3, b = M.elem_classes), "variant" in M && h(4, y = M.variant), "border_mode" in M && h(5, v = M.border_mode), "padding" in M && h(6, E = M.padding), "type" in M && h(16, S = M.type), "test_id" in M && h(7, R = M.test_id), "explicit_call" in M && h(8, x = M.explicit_call), "container" in M && h(9, H = M.container), "visible" in M && h(10, T = M.visible), "allow_overflow" in M && h(11, C = M.allow_overflow), "scale" in M && h(12, O = M.scale), "min_width" in M && h(13, j = M.min_width), "$$scope" in M && h(17, u = M.$$scope);
  }, [_, g, $, b, y, v, E, R, x, H, T, C, O, j, B, D, S, u, d];
}
class Block extends SvelteComponent$2t {
  constructor(a) {
    super(), init$2t(this, a, instance$i, create_fragment$y, safe_not_equal$2u, {
      height: 0,
      width: 1,
      elem_id: 2,
      elem_classes: 3,
      variant: 4,
      border_mode: 5,
      padding: 6,
      type: 16,
      test_id: 7,
      explicit_call: 8,
      container: 9,
      visible: 10,
      allow_overflow: 11,
      scale: 12,
      min_width: 13
    });
  }
}
const {
  SvelteComponent: SvelteComponent$2s,
  attr: attr$2k,
  children: children$2l,
  claim_element: claim_element$t,
  create_slot: create_slot$a,
  detach: detach$2n,
  element: element$t,
  get_all_dirty_from_scope: get_all_dirty_from_scope$a,
  get_slot_changes: get_slot_changes$a,
  init: init$2s,
  insert_hydration: insert_hydration$2n,
  safe_not_equal: safe_not_equal$2t,
  transition_in: transition_in$y,
  transition_out: transition_out$y,
  update_slot_base: update_slot_base$a
} = window.__gradio__svelte__internal;
function create_fragment$x(c) {
  let a, h;
  const d = (
    /*#slots*/
    c[1].default
  ), u = create_slot$a(
    d,
    c,
    /*$$scope*/
    c[0],
    null
  );
  return {
    c() {
      a = element$t("div"), u && u.c(), this.h();
    },
    l(_) {
      a = claim_element$t(_, "DIV", {
        class: !0
      });
      var g = children$2l(a);
      u && u.l(g), g.forEach(detach$2n), this.h();
    },
    h() {
      attr$2k(a, "class", "svelte-1hnfib2");
    },
    m(_, g) {
      insert_hydration$2n(_, a, g), u && u.m(a, null), h = !0;
    },
    p(_, [g]) {
      u && u.p && (!h || g & /*$$scope*/
      1) && update_slot_base$a(
        u,
        d,
        _,
        /*$$scope*/
        _[0],
        h ? get_slot_changes$a(
          d,
          /*$$scope*/
          _[0],
          g,
          null
        ) : get_all_dirty_from_scope$a(
          /*$$scope*/
          _[0]
        ),
        null
      );
    },
    i(_) {
      h || (transition_in$y(u, _), h = !0);
    },
    o(_) {
      transition_out$y(u, _), h = !1;
    },
    d(_) {
      _ && detach$2n(a), u && u.d(_);
    }
  };
}
function instance$h(c, a, h) {
  let {
    $$slots: d = {},
    $$scope: u
  } = a;
  return c.$$set = (_) => {
    "$$scope" in _ && h(0, u = _.$$scope);
  }, [u, d];
}
class Info extends SvelteComponent$2s {
  constructor(a) {
    super(), init$2s(this, a, instance$h, create_fragment$x, safe_not_equal$2t, {});
  }
}
const {
  SvelteComponent: SvelteComponent$2r,
  attr: attr$2j,
  check_outros: check_outros$g,
  children: children$2k,
  claim_component: claim_component$q,
  claim_element: claim_element$s,
  claim_space: claim_space$k,
  claim_text: claim_text$p,
  create_component: create_component$q,
  create_slot: create_slot$9,
  destroy_component: destroy_component$q,
  detach: detach$2m,
  element: element$s,
  empty: empty$a,
  get_all_dirty_from_scope: get_all_dirty_from_scope$9,
  get_slot_changes: get_slot_changes$9,
  group_outros: group_outros$g,
  init: init$2r,
  insert_hydration: insert_hydration$2m,
  mount_component: mount_component$q,
  safe_not_equal: safe_not_equal$2s,
  set_data: set_data$h,
  space: space$k,
  text: text$q,
  toggle_class: toggle_class$n,
  transition_in: transition_in$x,
  transition_out: transition_out$x,
  update_slot_base: update_slot_base$9
} = window.__gradio__svelte__internal;
function create_if_block$b(c) {
  let a, h;
  return a = new Info({
    props: {
      $$slots: {
        default: [create_default_slot$3]
      },
      $$scope: {
        ctx: c
      }
    }
  }), {
    c() {
      create_component$q(a.$$.fragment);
    },
    l(d) {
      claim_component$q(a.$$.fragment, d);
    },
    m(d, u) {
      mount_component$q(a, d, u), h = !0;
    },
    p(d, u) {
      const _ = {};
      u & /*$$scope, info*/
      10 && (_.$$scope = {
        dirty: u,
        ctx: d
      }), a.$set(_);
    },
    i(d) {
      h || (transition_in$x(a.$$.fragment, d), h = !0);
    },
    o(d) {
      transition_out$x(a.$$.fragment, d), h = !1;
    },
    d(d) {
      destroy_component$q(a, d);
    }
  };
}
function create_default_slot$3(c) {
  let a;
  return {
    c() {
      a = text$q(
        /*info*/
        c[1]
      );
    },
    l(h) {
      a = claim_text$p(
        h,
        /*info*/
        c[1]
      );
    },
    m(h, d) {
      insert_hydration$2m(h, a, d);
    },
    p(h, d) {
      d & /*info*/
      2 && set_data$h(
        a,
        /*info*/
        h[1]
      );
    },
    d(h) {
      h && detach$2m(a);
    }
  };
}
function create_fragment$w(c) {
  let a, h, d, u;
  const _ = (
    /*#slots*/
    c[2].default
  ), g = create_slot$9(
    _,
    c,
    /*$$scope*/
    c[3],
    null
  );
  let $ = (
    /*info*/
    c[1] && create_if_block$b(c)
  );
  return {
    c() {
      a = element$s("span"), g && g.c(), h = space$k(), $ && $.c(), d = empty$a(), this.h();
    },
    l(b) {
      a = claim_element$s(b, "SPAN", {
        "data-testid": !0,
        class: !0
      });
      var y = children$2k(a);
      g && g.l(y), y.forEach(detach$2m), h = claim_space$k(b), $ && $.l(b), d = empty$a(), this.h();
    },
    h() {
      attr$2j(a, "data-testid", "block-info"), attr$2j(a, "class", "svelte-22c38v"), toggle_class$n(a, "sr-only", !/*show_label*/
      c[0]), toggle_class$n(a, "hide", !/*show_label*/
      c[0]), toggle_class$n(
        a,
        "has-info",
        /*info*/
        c[1] != null
      );
    },
    m(b, y) {
      insert_hydration$2m(b, a, y), g && g.m(a, null), insert_hydration$2m(b, h, y), $ && $.m(b, y), insert_hydration$2m(b, d, y), u = !0;
    },
    p(b, [y]) {
      g && g.p && (!u || y & /*$$scope*/
      8) && update_slot_base$9(
        g,
        _,
        b,
        /*$$scope*/
        b[3],
        u ? get_slot_changes$9(
          _,
          /*$$scope*/
          b[3],
          y,
          null
        ) : get_all_dirty_from_scope$9(
          /*$$scope*/
          b[3]
        ),
        null
      ), (!u || y & /*show_label*/
      1) && toggle_class$n(a, "sr-only", !/*show_label*/
      b[0]), (!u || y & /*show_label*/
      1) && toggle_class$n(a, "hide", !/*show_label*/
      b[0]), (!u || y & /*info*/
      2) && toggle_class$n(
        a,
        "has-info",
        /*info*/
        b[1] != null
      ), /*info*/
      b[1] ? $ ? ($.p(b, y), y & /*info*/
      2 && transition_in$x($, 1)) : ($ = create_if_block$b(b), $.c(), transition_in$x($, 1), $.m(d.parentNode, d)) : $ && (group_outros$g(), transition_out$x($, 1, 1, () => {
        $ = null;
      }), check_outros$g());
    },
    i(b) {
      u || (transition_in$x(g, b), transition_in$x($), u = !0);
    },
    o(b) {
      transition_out$x(g, b), transition_out$x($), u = !1;
    },
    d(b) {
      b && (detach$2m(a), detach$2m(h), detach$2m(d)), g && g.d(b), $ && $.d(b);
    }
  };
}
function instance$g(c, a, h) {
  let {
    $$slots: d = {},
    $$scope: u
  } = a, {
    show_label: _ = !0
  } = a, {
    info: g = void 0
  } = a;
  return c.$$set = ($) => {
    "show_label" in $ && h(0, _ = $.show_label), "info" in $ && h(1, g = $.info), "$$scope" in $ && h(3, u = $.$$scope);
  }, [_, g, d, u];
}
class BlockTitle extends SvelteComponent$2r {
  constructor(a) {
    super(), init$2r(this, a, instance$g, create_fragment$w, safe_not_equal$2s, {
      show_label: 0,
      info: 1
    });
  }
}
const {
  SvelteComponent: SvelteComponent$2q,
  append_hydration: append_hydration$2c,
  attr: attr$2i,
  children: children$2j,
  claim_component: claim_component$p,
  claim_element: claim_element$r,
  claim_space: claim_space$j,
  claim_text: claim_text$o,
  create_component: create_component$p,
  destroy_component: destroy_component$p,
  detach: detach$2l,
  element: element$r,
  init: init$2q,
  insert_hydration: insert_hydration$2l,
  mount_component: mount_component$p,
  safe_not_equal: safe_not_equal$2r,
  set_data: set_data$g,
  space: space$j,
  text: text$p,
  toggle_class: toggle_class$m,
  transition_in: transition_in$w,
  transition_out: transition_out$w
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2p,
  append_hydration: append_hydration$2b,
  attr: attr$2h,
  bubble: bubble$5,
  children: children$2i,
  claim_component: claim_component$o,
  claim_element: claim_element$q,
  claim_space: claim_space$i,
  claim_text: claim_text$n,
  create_component: create_component$o,
  destroy_component: destroy_component$o,
  detach: detach$2k,
  element: element$q,
  init: init$2p,
  insert_hydration: insert_hydration$2k,
  listen: listen$a,
  mount_component: mount_component$o,
  safe_not_equal: safe_not_equal$2q,
  set_data: set_data$f,
  set_style: set_style$d,
  space: space$i,
  text: text$o,
  toggle_class: toggle_class$l,
  transition_in: transition_in$v,
  transition_out: transition_out$v
} = window.__gradio__svelte__internal;
function create_if_block$a(c) {
  let a, h;
  return {
    c() {
      a = element$q("span"), h = text$o(
        /*label*/
        c[1]
      ), this.h();
    },
    l(d) {
      a = claim_element$q(d, "SPAN", {
        class: !0
      });
      var u = children$2i(a);
      h = claim_text$n(
        u,
        /*label*/
        c[1]
      ), u.forEach(detach$2k), this.h();
    },
    h() {
      attr$2h(a, "class", "svelte-1lrphxw");
    },
    m(d, u) {
      insert_hydration$2k(d, a, u), append_hydration$2b(a, h);
    },
    p(d, u) {
      u & /*label*/
      2 && set_data$f(
        h,
        /*label*/
        d[1]
      );
    },
    d(d) {
      d && detach$2k(a);
    }
  };
}
function create_fragment$v(c) {
  let a, h, d, u, _, g, $, b = (
    /*show_label*/
    c[2] && create_if_block$a(c)
  );
  return u = new /*Icon*/
  c[0]({}), {
    c() {
      a = element$q("button"), b && b.c(), h = space$i(), d = element$q("div"), create_component$o(u.$$.fragment), this.h();
    },
    l(y) {
      a = claim_element$q(y, "BUTTON", {
        "aria-label": !0,
        "aria-haspopup": !0,
        title: !0,
        class: !0
      });
      var v = children$2i(a);
      b && b.l(v), h = claim_space$i(v), d = claim_element$q(v, "DIV", {
        class: !0
      });
      var E = children$2i(d);
      claim_component$o(u.$$.fragment, E), E.forEach(detach$2k), v.forEach(detach$2k), this.h();
    },
    h() {
      attr$2h(d, "class", "svelte-1lrphxw"), toggle_class$l(
        d,
        "small",
        /*size*/
        c[4] === "small"
      ), toggle_class$l(
        d,
        "large",
        /*size*/
        c[4] === "large"
      ), toggle_class$l(
        d,
        "medium",
        /*size*/
        c[4] === "medium"
      ), a.disabled = /*disabled*/
      c[7], attr$2h(
        a,
        "aria-label",
        /*label*/
        c[1]
      ), attr$2h(
        a,
        "aria-haspopup",
        /*hasPopup*/
        c[8]
      ), attr$2h(
        a,
        "title",
        /*label*/
        c[1]
      ), attr$2h(a, "class", "svelte-1lrphxw"), toggle_class$l(
        a,
        "pending",
        /*pending*/
        c[3]
      ), toggle_class$l(
        a,
        "padded",
        /*padded*/
        c[5]
      ), toggle_class$l(
        a,
        "highlight",
        /*highlight*/
        c[6]
      ), toggle_class$l(
        a,
        "transparent",
        /*transparent*/
        c[9]
      ), set_style$d(a, "color", !/*disabled*/
      c[7] && /*_color*/
      c[12] ? (
        /*_color*/
        c[12]
      ) : "var(--block-label-text-color)"), set_style$d(a, "--bg-color", /*disabled*/
      c[7] ? "auto" : (
        /*background*/
        c[10]
      )), set_style$d(
        a,
        "margin-left",
        /*offset*/
        c[11] + "px"
      );
    },
    m(y, v) {
      insert_hydration$2k(y, a, v), b && b.m(a, null), append_hydration$2b(a, h), append_hydration$2b(a, d), mount_component$o(u, d, null), _ = !0, g || ($ = listen$a(
        a,
        "click",
        /*click_handler*/
        c[14]
      ), g = !0);
    },
    p(y, [v]) {
      /*show_label*/
      y[2] ? b ? b.p(y, v) : (b = create_if_block$a(y), b.c(), b.m(a, h)) : b && (b.d(1), b = null), (!_ || v & /*size*/
      16) && toggle_class$l(
        d,
        "small",
        /*size*/
        y[4] === "small"
      ), (!_ || v & /*size*/
      16) && toggle_class$l(
        d,
        "large",
        /*size*/
        y[4] === "large"
      ), (!_ || v & /*size*/
      16) && toggle_class$l(
        d,
        "medium",
        /*size*/
        y[4] === "medium"
      ), (!_ || v & /*disabled*/
      128) && (a.disabled = /*disabled*/
      y[7]), (!_ || v & /*label*/
      2) && attr$2h(
        a,
        "aria-label",
        /*label*/
        y[1]
      ), (!_ || v & /*hasPopup*/
      256) && attr$2h(
        a,
        "aria-haspopup",
        /*hasPopup*/
        y[8]
      ), (!_ || v & /*label*/
      2) && attr$2h(
        a,
        "title",
        /*label*/
        y[1]
      ), (!_ || v & /*pending*/
      8) && toggle_class$l(
        a,
        "pending",
        /*pending*/
        y[3]
      ), (!_ || v & /*padded*/
      32) && toggle_class$l(
        a,
        "padded",
        /*padded*/
        y[5]
      ), (!_ || v & /*highlight*/
      64) && toggle_class$l(
        a,
        "highlight",
        /*highlight*/
        y[6]
      ), (!_ || v & /*transparent*/
      512) && toggle_class$l(
        a,
        "transparent",
        /*transparent*/
        y[9]
      ), v & /*disabled, _color*/
      4224 && set_style$d(a, "color", !/*disabled*/
      y[7] && /*_color*/
      y[12] ? (
        /*_color*/
        y[12]
      ) : "var(--block-label-text-color)"), v & /*disabled, background*/
      1152 && set_style$d(a, "--bg-color", /*disabled*/
      y[7] ? "auto" : (
        /*background*/
        y[10]
      )), v & /*offset*/
      2048 && set_style$d(
        a,
        "margin-left",
        /*offset*/
        y[11] + "px"
      );
    },
    i(y) {
      _ || (transition_in$v(u.$$.fragment, y), _ = !0);
    },
    o(y) {
      transition_out$v(u.$$.fragment, y), _ = !1;
    },
    d(y) {
      y && detach$2k(a), b && b.d(), destroy_component$o(u), g = !1, $();
    }
  };
}
function instance$f(c, a, h) {
  let d, {
    Icon: u
  } = a, {
    label: _ = ""
  } = a, {
    show_label: g = !1
  } = a, {
    pending: $ = !1
  } = a, {
    size: b = "small"
  } = a, {
    padded: y = !0
  } = a, {
    highlight: v = !1
  } = a, {
    disabled: E = !1
  } = a, {
    hasPopup: S = !1
  } = a, {
    color: R = "var(--block-label-text-color)"
  } = a, {
    transparent: x = !1
  } = a, {
    background: H = "var(--background-fill-primary)"
  } = a, {
    offset: T = 0
  } = a;
  function C(O) {
    bubble$5.call(this, c, O);
  }
  return c.$$set = (O) => {
    "Icon" in O && h(0, u = O.Icon), "label" in O && h(1, _ = O.label), "show_label" in O && h(2, g = O.show_label), "pending" in O && h(3, $ = O.pending), "size" in O && h(4, b = O.size), "padded" in O && h(5, y = O.padded), "highlight" in O && h(6, v = O.highlight), "disabled" in O && h(7, E = O.disabled), "hasPopup" in O && h(8, S = O.hasPopup), "color" in O && h(13, R = O.color), "transparent" in O && h(9, x = O.transparent), "background" in O && h(10, H = O.background), "offset" in O && h(11, T = O.offset);
  }, c.$$.update = () => {
    c.$$.dirty & /*highlight, color*/
    8256 && h(12, d = v ? "var(--color-accent)" : R);
  }, [u, _, g, $, b, y, v, E, S, x, H, T, d, R, C];
}
let IconButton$1 = class extends SvelteComponent$2p {
  constructor(a) {
    super(), init$2p(this, a, instance$f, create_fragment$v, safe_not_equal$2q, {
      Icon: 0,
      label: 1,
      show_label: 2,
      pending: 3,
      size: 4,
      padded: 5,
      highlight: 6,
      disabled: 7,
      hasPopup: 8,
      color: 13,
      transparent: 9,
      background: 10,
      offset: 11
    });
  }
};
const {
  SvelteComponent: SvelteComponent$2o,
  append_hydration: append_hydration$2a,
  attr: attr$2g,
  binding_callbacks: binding_callbacks$9,
  children: children$2h,
  claim_element: claim_element$p,
  create_slot: create_slot$8,
  detach: detach$2j,
  element: element$p,
  get_all_dirty_from_scope: get_all_dirty_from_scope$8,
  get_slot_changes: get_slot_changes$8,
  init: init$2o,
  insert_hydration: insert_hydration$2j,
  safe_not_equal: safe_not_equal$2p,
  toggle_class: toggle_class$k,
  transition_in: transition_in$u,
  transition_out: transition_out$u,
  update_slot_base: update_slot_base$8
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2n,
  append_hydration: append_hydration$29,
  attr: attr$2f,
  children: children$2g,
  claim_svg_element: claim_svg_element$1U,
  detach: detach$2i,
  init: init$2n,
  insert_hydration: insert_hydration$2i,
  noop: noop$20,
  safe_not_equal: safe_not_equal$2o,
  svg_element: svg_element$1U
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2m,
  append_hydration: append_hydration$28,
  attr: attr$2e,
  children: children$2f,
  claim_svg_element: claim_svg_element$1T,
  detach: detach$2h,
  init: init$2m,
  insert_hydration: insert_hydration$2h,
  noop: noop$1$,
  safe_not_equal: safe_not_equal$2n,
  svg_element: svg_element$1T
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2l,
  append_hydration: append_hydration$27,
  attr: attr$2d,
  children: children$2e,
  claim_svg_element: claim_svg_element$1S,
  detach: detach$2g,
  init: init$2l,
  insert_hydration: insert_hydration$2g,
  noop: noop$1_,
  safe_not_equal: safe_not_equal$2m,
  svg_element: svg_element$1S
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2k,
  append_hydration: append_hydration$26,
  attr: attr$2c,
  children: children$2d,
  claim_svg_element: claim_svg_element$1R,
  detach: detach$2f,
  init: init$2k,
  insert_hydration: insert_hydration$2f,
  noop: noop$1Z,
  safe_not_equal: safe_not_equal$2l,
  svg_element: svg_element$1R
} = window.__gradio__svelte__internal;
function create_fragment$u(c) {
  let a, h, d;
  return {
    c() {
      a = svg_element$1R("svg"), h = svg_element$1R("path"), d = svg_element$1R("circle"), this.h();
    },
    l(u) {
      a = claim_svg_element$1R(u, "svg", {
        xmlns: !0,
        width: !0,
        height: !0,
        viewBox: !0,
        fill: !0,
        stroke: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        "stroke-linejoin": !0,
        class: !0
      });
      var _ = children$2d(a);
      h = claim_svg_element$1R(_, "path", {
        d: !0
      }), children$2d(h).forEach(detach$2f), d = claim_svg_element$1R(_, "circle", {
        cx: !0,
        cy: !0,
        r: !0
      }), children$2d(d).forEach(detach$2f), _.forEach(detach$2f), this.h();
    },
    h() {
      attr$2c(h, "d", "M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"), attr$2c(d, "cx", "12"), attr$2c(d, "cy", "13"), attr$2c(d, "r", "4"), attr$2c(a, "xmlns", "http://www.w3.org/2000/svg"), attr$2c(a, "width", "100%"), attr$2c(a, "height", "100%"), attr$2c(a, "viewBox", "0 0 24 24"), attr$2c(a, "fill", "none"), attr$2c(a, "stroke", "currentColor"), attr$2c(a, "stroke-width", "1.5"), attr$2c(a, "stroke-linecap", "round"), attr$2c(a, "stroke-linejoin", "round"), attr$2c(a, "class", "feather feather-camera");
    },
    m(u, _) {
      insert_hydration$2f(u, a, _), append_hydration$26(a, h), append_hydration$26(a, d);
    },
    p: noop$1Z,
    i: noop$1Z,
    o: noop$1Z,
    d(u) {
      u && detach$2f(a);
    }
  };
}
class Camera extends SvelteComponent$2k {
  constructor(a) {
    super(), init$2k(this, a, null, create_fragment$u, safe_not_equal$2l, {});
  }
}
const {
  SvelteComponent: SvelteComponent$2j,
  append_hydration: append_hydration$25,
  attr: attr$2b,
  children: children$2c,
  claim_svg_element: claim_svg_element$1Q,
  detach: detach$2e,
  init: init$2j,
  insert_hydration: insert_hydration$2e,
  noop: noop$1Y,
  safe_not_equal: safe_not_equal$2k,
  svg_element: svg_element$1Q
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2i,
  append_hydration: append_hydration$24,
  attr: attr$2a,
  children: children$2b,
  claim_svg_element: claim_svg_element$1P,
  detach: detach$2d,
  init: init$2i,
  insert_hydration: insert_hydration$2d,
  noop: noop$1X,
  safe_not_equal: safe_not_equal$2j,
  svg_element: svg_element$1P
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2h,
  append_hydration: append_hydration$23,
  attr: attr$29,
  children: children$2a,
  claim_svg_element: claim_svg_element$1O,
  detach: detach$2c,
  init: init$2h,
  insert_hydration: insert_hydration$2c,
  noop: noop$1W,
  safe_not_equal: safe_not_equal$2i,
  svg_element: svg_element$1O
} = window.__gradio__svelte__internal;
function create_fragment$t(c) {
  let a, h;
  return {
    c() {
      a = svg_element$1O("svg"), h = svg_element$1O("polyline"), this.h();
    },
    l(d) {
      a = claim_svg_element$1O(d, "svg", {
        xmlns: !0,
        viewBox: !0,
        fill: !0,
        stroke: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        "stroke-linejoin": !0
      });
      var u = children$2a(a);
      h = claim_svg_element$1O(u, "polyline", {
        points: !0
      }), children$2a(h).forEach(detach$2c), u.forEach(detach$2c), this.h();
    },
    h() {
      attr$29(h, "points", "20 6 9 17 4 12"), attr$29(a, "xmlns", "http://www.w3.org/2000/svg"), attr$29(a, "viewBox", "2 0 20 20"), attr$29(a, "fill", "none"), attr$29(a, "stroke", "currentColor"), attr$29(a, "stroke-width", "3"), attr$29(a, "stroke-linecap", "round"), attr$29(a, "stroke-linejoin", "round");
    },
    m(d, u) {
      insert_hydration$2c(d, a, u), append_hydration$23(a, h);
    },
    p: noop$1W,
    i: noop$1W,
    o: noop$1W,
    d(d) {
      d && detach$2c(a);
    }
  };
}
class Check extends SvelteComponent$2h {
  constructor(a) {
    super(), init$2h(this, a, null, create_fragment$t, safe_not_equal$2i, {});
  }
}
const {
  SvelteComponent: SvelteComponent$2g,
  append_hydration: append_hydration$22,
  attr: attr$28,
  children: children$29,
  claim_svg_element: claim_svg_element$1N,
  detach: detach$2b,
  init: init$2g,
  insert_hydration: insert_hydration$2b,
  noop: noop$1V,
  safe_not_equal: safe_not_equal$2h,
  svg_element: svg_element$1N
} = window.__gradio__svelte__internal;
function create_fragment$s(c) {
  let a, h;
  return {
    c() {
      a = svg_element$1N("svg"), h = svg_element$1N("circle"), this.h();
    },
    l(d) {
      a = claim_svg_element$1N(d, "svg", {
        xmlns: !0,
        width: !0,
        height: !0,
        viewBox: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        "stroke-linejoin": !0,
        class: !0
      });
      var u = children$29(a);
      h = claim_svg_element$1N(u, "circle", {
        cx: !0,
        cy: !0,
        r: !0
      }), children$29(h).forEach(detach$2b), u.forEach(detach$2b), this.h();
    },
    h() {
      attr$28(h, "cx", "12"), attr$28(h, "cy", "12"), attr$28(h, "r", "10"), attr$28(a, "xmlns", "http://www.w3.org/2000/svg"), attr$28(a, "width", "100%"), attr$28(a, "height", "100%"), attr$28(a, "viewBox", "0 0 24 24"), attr$28(a, "stroke-width", "1.5"), attr$28(a, "stroke-linecap", "round"), attr$28(a, "stroke-linejoin", "round"), attr$28(a, "class", "feather feather-circle");
    },
    m(d, u) {
      insert_hydration$2b(d, a, u), append_hydration$22(a, h);
    },
    p: noop$1V,
    i: noop$1V,
    o: noop$1V,
    d(d) {
      d && detach$2b(a);
    }
  };
}
class Circle extends SvelteComponent$2g {
  constructor(a) {
    super(), init$2g(this, a, null, create_fragment$s, safe_not_equal$2h, {});
  }
}
const {
  SvelteComponent: SvelteComponent$2f,
  append_hydration: append_hydration$21,
  attr: attr$27,
  children: children$28,
  claim_svg_element: claim_svg_element$1M,
  detach: detach$2a,
  init: init$2f,
  insert_hydration: insert_hydration$2a,
  noop: noop$1U,
  safe_not_equal: safe_not_equal$2g,
  set_style: set_style$c,
  svg_element: svg_element$1M
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2e,
  append_hydration: append_hydration$20,
  attr: attr$26,
  children: children$27,
  claim_svg_element: claim_svg_element$1L,
  detach: detach$29,
  init: init$2e,
  insert_hydration: insert_hydration$29,
  noop: noop$1T,
  safe_not_equal: safe_not_equal$2f,
  svg_element: svg_element$1L
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2d,
  append_hydration: append_hydration$1$,
  attr: attr$25,
  children: children$26,
  claim_svg_element: claim_svg_element$1K,
  detach: detach$28,
  init: init$2d,
  insert_hydration: insert_hydration$28,
  noop: noop$1S,
  safe_not_equal: safe_not_equal$2e,
  svg_element: svg_element$1K
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2c,
  append_hydration: append_hydration$1_,
  attr: attr$24,
  children: children$25,
  claim_svg_element: claim_svg_element$1J,
  detach: detach$27,
  init: init$2c,
  insert_hydration: insert_hydration$27,
  noop: noop$1R,
  safe_not_equal: safe_not_equal$2d,
  svg_element: svg_element$1J
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$2b,
  append_hydration: append_hydration$1Z,
  attr: attr$23,
  children: children$24,
  claim_svg_element: claim_svg_element$1I,
  detach: detach$26,
  init: init$2b,
  insert_hydration: insert_hydration$26,
  noop: noop$1Q,
  safe_not_equal: safe_not_equal$2c,
  svg_element: svg_element$1I
} = window.__gradio__svelte__internal;
function create_fragment$r(c) {
  let a, h, d;
  return {
    c() {
      a = svg_element$1I("svg"), h = svg_element$1I("path"), d = svg_element$1I("path"), this.h();
    },
    l(u) {
      a = claim_svg_element$1I(u, "svg", {
        xmlns: !0,
        viewBox: !0,
        color: !0
      });
      var _ = children$24(a);
      h = claim_svg_element$1I(_, "path", {
        fill: !0,
        d: !0
      }), children$24(h).forEach(detach$26), d = claim_svg_element$1I(_, "path", {
        fill: !0,
        d: !0
      }), children$24(d).forEach(detach$26), _.forEach(detach$26), this.h();
    },
    h() {
      attr$23(h, "fill", "currentColor"), attr$23(h, "d", "M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z"), attr$23(d, "fill", "currentColor"), attr$23(d, "d", "M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z"), attr$23(a, "xmlns", "http://www.w3.org/2000/svg"), attr$23(a, "viewBox", "0 0 33 33"), attr$23(a, "color", "currentColor");
    },
    m(u, _) {
      insert_hydration$26(u, a, _), append_hydration$1Z(a, h), append_hydration$1Z(a, d);
    },
    p: noop$1Q,
    i: noop$1Q,
    o: noop$1Q,
    d(u) {
      u && detach$26(a);
    }
  };
}
class Copy extends SvelteComponent$2b {
  constructor(a) {
    super(), init$2b(this, a, null, create_fragment$r, safe_not_equal$2c, {});
  }
}
const {
  SvelteComponent: SvelteComponent$2a,
  append_hydration: append_hydration$1Y,
  attr: attr$22,
  children: children$23,
  claim_svg_element: claim_svg_element$1H,
  detach: detach$25,
  init: init$2a,
  insert_hydration: insert_hydration$25,
  noop: noop$1P,
  safe_not_equal: safe_not_equal$2b,
  svg_element: svg_element$1H
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$29,
  append_hydration: append_hydration$1X,
  attr: attr$21,
  children: children$22,
  claim_svg_element: claim_svg_element$1G,
  detach: detach$24,
  init: init$29,
  insert_hydration: insert_hydration$24,
  noop: noop$1O,
  safe_not_equal: safe_not_equal$2a,
  svg_element: svg_element$1G
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$28,
  append_hydration: append_hydration$1W,
  attr: attr$20,
  children: children$21,
  claim_svg_element: claim_svg_element$1F,
  detach: detach$23,
  init: init$28,
  insert_hydration: insert_hydration$23,
  noop: noop$1N,
  safe_not_equal: safe_not_equal$29,
  svg_element: svg_element$1F
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$27,
  append_hydration: append_hydration$1V,
  attr: attr$1$,
  children: children$20,
  claim_svg_element: claim_svg_element$1E,
  detach: detach$22,
  init: init$27,
  insert_hydration: insert_hydration$22,
  noop: noop$1M,
  safe_not_equal: safe_not_equal$28,
  svg_element: svg_element$1E
} = window.__gradio__svelte__internal;
function create_fragment$q(c) {
  let a, h;
  return {
    c() {
      a = svg_element$1E("svg"), h = svg_element$1E("path"), this.h();
    },
    l(d) {
      a = claim_svg_element$1E(d, "svg", {
        class: !0,
        xmlns: !0,
        width: !0,
        height: !0,
        viewBox: !0
      });
      var u = children$20(a);
      h = claim_svg_element$1E(u, "path", {
        d: !0
      }), children$20(h).forEach(detach$22), u.forEach(detach$22), this.h();
    },
    h() {
      attr$1$(h, "d", "M5 8l4 4 4-4z"), attr$1$(a, "class", "dropdown-arrow svelte-145leq6"), attr$1$(a, "xmlns", "http://www.w3.org/2000/svg"), attr$1$(a, "width", "100%"), attr$1$(a, "height", "100%"), attr$1$(a, "viewBox", "0 0 18 18");
    },
    m(d, u) {
      insert_hydration$22(d, a, u), append_hydration$1V(a, h);
    },
    p: noop$1M,
    i: noop$1M,
    o: noop$1M,
    d(d) {
      d && detach$22(a);
    }
  };
}
class DropdownArrow extends SvelteComponent$27 {
  constructor(a) {
    super(), init$27(this, a, null, create_fragment$q, safe_not_equal$28, {});
  }
}
const {
  SvelteComponent: SvelteComponent$26,
  append_hydration: append_hydration$1U,
  attr: attr$1_,
  children: children$1$,
  claim_svg_element: claim_svg_element$1D,
  detach: detach$21,
  init: init$26,
  insert_hydration: insert_hydration$21,
  noop: noop$1L,
  safe_not_equal: safe_not_equal$27,
  svg_element: svg_element$1D
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$25,
  append_hydration: append_hydration$1T,
  attr: attr$1Z,
  children: children$1_,
  claim_svg_element: claim_svg_element$1C,
  detach: detach$20,
  init: init$25,
  insert_hydration: insert_hydration$20,
  noop: noop$1K,
  safe_not_equal: safe_not_equal$26,
  svg_element: svg_element$1C
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$24,
  append_hydration: append_hydration$1S,
  attr: attr$1Y,
  children: children$1Z,
  claim_svg_element: claim_svg_element$1B,
  detach: detach$1$,
  init: init$24,
  insert_hydration: insert_hydration$1$,
  noop: noop$1J,
  safe_not_equal: safe_not_equal$25,
  svg_element: svg_element$1B
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$23,
  append_hydration: append_hydration$1R,
  attr: attr$1X,
  children: children$1Y,
  claim_svg_element: claim_svg_element$1A,
  detach: detach$1_,
  init: init$23,
  insert_hydration: insert_hydration$1_,
  noop: noop$1I,
  safe_not_equal: safe_not_equal$24,
  svg_element: svg_element$1A
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$22,
  append_hydration: append_hydration$1Q,
  attr: attr$1W,
  children: children$1X,
  claim_svg_element: claim_svg_element$1z,
  detach: detach$1Z,
  init: init$22,
  insert_hydration: insert_hydration$1Z,
  noop: noop$1H,
  safe_not_equal: safe_not_equal$23,
  svg_element: svg_element$1z
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$21,
  append_hydration: append_hydration$1P,
  attr: attr$1V,
  children: children$1W,
  claim_svg_element: claim_svg_element$1y,
  detach: detach$1Y,
  init: init$21,
  insert_hydration: insert_hydration$1Y,
  noop: noop$1G,
  safe_not_equal: safe_not_equal$22,
  svg_element: svg_element$1y
} = window.__gradio__svelte__internal;
function create_fragment$p(c) {
  let a, h, d;
  return {
    c() {
      a = svg_element$1y("svg"), h = svg_element$1y("path"), d = svg_element$1y("polyline"), this.h();
    },
    l(u) {
      a = claim_svg_element$1y(u, "svg", {
        xmlns: !0,
        width: !0,
        height: !0,
        viewBox: !0,
        fill: !0,
        stroke: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        "stroke-linejoin": !0,
        class: !0
      });
      var _ = children$1W(a);
      h = claim_svg_element$1y(_, "path", {
        d: !0
      }), children$1W(h).forEach(detach$1Y), d = claim_svg_element$1y(_, "polyline", {
        points: !0
      }), children$1W(d).forEach(detach$1Y), _.forEach(detach$1Y), this.h();
    },
    h() {
      attr$1V(h, "d", "M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"), attr$1V(d, "points", "13 2 13 9 20 9"), attr$1V(a, "xmlns", "http://www.w3.org/2000/svg"), attr$1V(a, "width", "100%"), attr$1V(a, "height", "100%"), attr$1V(a, "viewBox", "0 0 24 24"), attr$1V(a, "fill", "none"), attr$1V(a, "stroke", "currentColor"), attr$1V(a, "stroke-width", "1.5"), attr$1V(a, "stroke-linecap", "round"), attr$1V(a, "stroke-linejoin", "round"), attr$1V(a, "class", "feather feather-file");
    },
    m(u, _) {
      insert_hydration$1Y(u, a, _), append_hydration$1P(a, h), append_hydration$1P(a, d);
    },
    p: noop$1G,
    i: noop$1G,
    o: noop$1G,
    d(u) {
      u && detach$1Y(a);
    }
  };
}
let File$1 = class extends SvelteComponent$21 {
  constructor(a) {
    super(), init$21(this, a, null, create_fragment$p, safe_not_equal$22, {});
  }
};
const {
  SvelteComponent: SvelteComponent$20,
  append_hydration: append_hydration$1O,
  attr: attr$1U,
  children: children$1V,
  claim_svg_element: claim_svg_element$1x,
  detach: detach$1X,
  init: init$20,
  insert_hydration: insert_hydration$1X,
  noop: noop$1F,
  safe_not_equal: safe_not_equal$21,
  svg_element: svg_element$1x
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1$,
  append_hydration: append_hydration$1N,
  attr: attr$1T,
  children: children$1U,
  claim_svg_element: claim_svg_element$1w,
  detach: detach$1W,
  init: init$1$,
  insert_hydration: insert_hydration$1W,
  noop: noop$1E,
  safe_not_equal: safe_not_equal$20,
  svg_element: svg_element$1w
} = window.__gradio__svelte__internal;
function create_fragment$o(c) {
  let a, h, d, u;
  return {
    c() {
      a = svg_element$1w("svg"), h = svg_element$1w("rect"), d = svg_element$1w("circle"), u = svg_element$1w("polyline"), this.h();
    },
    l(_) {
      a = claim_svg_element$1w(_, "svg", {
        xmlns: !0,
        width: !0,
        height: !0,
        viewBox: !0,
        fill: !0,
        stroke: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        "stroke-linejoin": !0,
        class: !0
      });
      var g = children$1U(a);
      h = claim_svg_element$1w(g, "rect", {
        x: !0,
        y: !0,
        width: !0,
        height: !0,
        rx: !0,
        ry: !0
      }), children$1U(h).forEach(detach$1W), d = claim_svg_element$1w(g, "circle", {
        cx: !0,
        cy: !0,
        r: !0
      }), children$1U(d).forEach(detach$1W), u = claim_svg_element$1w(g, "polyline", {
        points: !0
      }), children$1U(u).forEach(detach$1W), g.forEach(detach$1W), this.h();
    },
    h() {
      attr$1T(h, "x", "3"), attr$1T(h, "y", "3"), attr$1T(h, "width", "18"), attr$1T(h, "height", "18"), attr$1T(h, "rx", "2"), attr$1T(h, "ry", "2"), attr$1T(d, "cx", "8.5"), attr$1T(d, "cy", "8.5"), attr$1T(d, "r", "1.5"), attr$1T(u, "points", "21 15 16 10 5 21"), attr$1T(a, "xmlns", "http://www.w3.org/2000/svg"), attr$1T(a, "width", "100%"), attr$1T(a, "height", "100%"), attr$1T(a, "viewBox", "0 0 24 24"), attr$1T(a, "fill", "none"), attr$1T(a, "stroke", "currentColor"), attr$1T(a, "stroke-width", "1.5"), attr$1T(a, "stroke-linecap", "round"), attr$1T(a, "stroke-linejoin", "round"), attr$1T(a, "class", "feather feather-image");
    },
    m(_, g) {
      insert_hydration$1W(_, a, g), append_hydration$1N(a, h), append_hydration$1N(a, d), append_hydration$1N(a, u);
    },
    p: noop$1E,
    i: noop$1E,
    o: noop$1E,
    d(_) {
      _ && detach$1W(a);
    }
  };
}
let Image$2 = class extends SvelteComponent$1$ {
  constructor(a) {
    super(), init$1$(this, a, null, create_fragment$o, safe_not_equal$20, {});
  }
};
const {
  SvelteComponent: SvelteComponent$1_,
  append_hydration: append_hydration$1M,
  attr: attr$1S,
  children: children$1T,
  claim_svg_element: claim_svg_element$1v,
  detach: detach$1V,
  init: init$1_,
  insert_hydration: insert_hydration$1V,
  noop: noop$1D,
  safe_not_equal: safe_not_equal$1$,
  svg_element: svg_element$1v
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1Z,
  append_hydration: append_hydration$1L,
  attr: attr$1R,
  children: children$1S,
  claim_svg_element: claim_svg_element$1u,
  detach: detach$1U,
  init: init$1Z,
  insert_hydration: insert_hydration$1U,
  noop: noop$1C,
  safe_not_equal: safe_not_equal$1_,
  svg_element: svg_element$1u
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1Y,
  append_hydration: append_hydration$1K,
  attr: attr$1Q,
  children: children$1R,
  claim_svg_element: claim_svg_element$1t,
  detach: detach$1T,
  init: init$1Y,
  insert_hydration: insert_hydration$1T,
  noop: noop$1B,
  safe_not_equal: safe_not_equal$1Z,
  svg_element: svg_element$1t
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1X,
  append_hydration: append_hydration$1J,
  attr: attr$1P,
  children: children$1Q,
  claim_svg_element: claim_svg_element$1s,
  detach: detach$1S,
  init: init$1X,
  insert_hydration: insert_hydration$1S,
  noop: noop$1A,
  safe_not_equal: safe_not_equal$1Y,
  svg_element: svg_element$1s
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1W,
  append_hydration: append_hydration$1I,
  attr: attr$1O,
  children: children$1P,
  claim_svg_element: claim_svg_element$1r,
  detach: detach$1R,
  init: init$1W,
  insert_hydration: insert_hydration$1R,
  noop: noop$1z,
  safe_not_equal: safe_not_equal$1X,
  svg_element: svg_element$1r
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1V,
  append_hydration: append_hydration$1H,
  attr: attr$1N,
  children: children$1O,
  claim_svg_element: claim_svg_element$1q,
  detach: detach$1Q,
  init: init$1V,
  insert_hydration: insert_hydration$1Q,
  noop: noop$1y,
  safe_not_equal: safe_not_equal$1W,
  svg_element: svg_element$1q
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1U,
  append_hydration: append_hydration$1G,
  attr: attr$1M,
  children: children$1N,
  claim_svg_element: claim_svg_element$1p,
  detach: detach$1P,
  init: init$1U,
  insert_hydration: insert_hydration$1P,
  noop: noop$1x,
  safe_not_equal: safe_not_equal$1V,
  svg_element: svg_element$1p
} = window.__gradio__svelte__internal;
function create_fragment$n(c) {
  let a, h, d, u, _;
  return {
    c() {
      a = svg_element$1p("svg"), h = svg_element$1p("path"), d = svg_element$1p("path"), u = svg_element$1p("line"), _ = svg_element$1p("line"), this.h();
    },
    l(g) {
      a = claim_svg_element$1p(g, "svg", {
        xmlns: !0,
        width: !0,
        height: !0,
        viewBox: !0,
        fill: !0,
        stroke: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        "stroke-linejoin": !0,
        class: !0
      });
      var $ = children$1N(a);
      h = claim_svg_element$1p($, "path", {
        d: !0
      }), children$1N(h).forEach(detach$1P), d = claim_svg_element$1p($, "path", {
        d: !0
      }), children$1N(d).forEach(detach$1P), u = claim_svg_element$1p($, "line", {
        x1: !0,
        y1: !0,
        x2: !0,
        y2: !0
      }), children$1N(u).forEach(detach$1P), _ = claim_svg_element$1p($, "line", {
        x1: !0,
        y1: !0,
        x2: !0,
        y2: !0
      }), children$1N(_).forEach(detach$1P), $.forEach(detach$1P), this.h();
    },
    h() {
      attr$1M(h, "d", "M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"), attr$1M(d, "d", "M19 10v2a7 7 0 0 1-14 0v-2"), attr$1M(u, "x1", "12"), attr$1M(u, "y1", "19"), attr$1M(u, "x2", "12"), attr$1M(u, "y2", "23"), attr$1M(_, "x1", "8"), attr$1M(_, "y1", "23"), attr$1M(_, "x2", "16"), attr$1M(_, "y2", "23"), attr$1M(a, "xmlns", "http://www.w3.org/2000/svg"), attr$1M(a, "width", "100%"), attr$1M(a, "height", "100%"), attr$1M(a, "viewBox", "0 0 24 24"), attr$1M(a, "fill", "none"), attr$1M(a, "stroke", "currentColor"), attr$1M(a, "stroke-width", "2"), attr$1M(a, "stroke-linecap", "round"), attr$1M(a, "stroke-linejoin", "round"), attr$1M(a, "class", "feather feather-mic");
    },
    m(g, $) {
      insert_hydration$1P(g, a, $), append_hydration$1G(a, h), append_hydration$1G(a, d), append_hydration$1G(a, u), append_hydration$1G(a, _);
    },
    p: noop$1x,
    i: noop$1x,
    o: noop$1x,
    d(g) {
      g && detach$1P(a);
    }
  };
}
class Microphone extends SvelteComponent$1U {
  constructor(a) {
    super(), init$1U(this, a, null, create_fragment$n, safe_not_equal$1V, {});
  }
}
const {
  SvelteComponent: SvelteComponent$1T,
  append_hydration: append_hydration$1F,
  attr: attr$1L,
  children: children$1M,
  claim_svg_element: claim_svg_element$1o,
  detach: detach$1O,
  init: init$1T,
  insert_hydration: insert_hydration$1O,
  noop: noop$1w,
  safe_not_equal: safe_not_equal$1U,
  svg_element: svg_element$1o
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1S,
  append_hydration: append_hydration$1E,
  attr: attr$1K,
  children: children$1L,
  claim_svg_element: claim_svg_element$1n,
  detach: detach$1N,
  init: init$1S,
  insert_hydration: insert_hydration$1N,
  noop: noop$1v,
  safe_not_equal: safe_not_equal$1T,
  svg_element: svg_element$1n
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1R,
  append_hydration: append_hydration$1D,
  attr: attr$1J,
  children: children$1K,
  claim_svg_element: claim_svg_element$1m,
  detach: detach$1M,
  init: init$1R,
  insert_hydration: insert_hydration$1M,
  noop: noop$1u,
  safe_not_equal: safe_not_equal$1S,
  svg_element: svg_element$1m
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1Q,
  append_hydration: append_hydration$1C,
  attr: attr$1I,
  children: children$1J,
  claim_svg_element: claim_svg_element$1l,
  detach: detach$1L,
  init: init$1Q,
  insert_hydration: insert_hydration$1L,
  noop: noop$1t,
  safe_not_equal: safe_not_equal$1R,
  svg_element: svg_element$1l
} = window.__gradio__svelte__internal;
function create_fragment$m(c) {
  let a, h, d;
  return {
    c() {
      a = svg_element$1l("svg"), h = svg_element$1l("rect"), d = svg_element$1l("rect"), this.h();
    },
    l(u) {
      a = claim_svg_element$1l(u, "svg", {
        xmlns: !0,
        width: !0,
        height: !0,
        viewBox: !0,
        fill: !0,
        stroke: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        "stroke-linejoin": !0
      });
      var _ = children$1J(a);
      h = claim_svg_element$1l(_, "rect", {
        x: !0,
        y: !0,
        width: !0,
        height: !0
      }), children$1J(h).forEach(detach$1L), d = claim_svg_element$1l(_, "rect", {
        x: !0,
        y: !0,
        width: !0,
        height: !0
      }), children$1J(d).forEach(detach$1L), _.forEach(detach$1L), this.h();
    },
    h() {
      attr$1I(h, "x", "6"), attr$1I(h, "y", "4"), attr$1I(h, "width", "4"), attr$1I(h, "height", "16"), attr$1I(d, "x", "14"), attr$1I(d, "y", "4"), attr$1I(d, "width", "4"), attr$1I(d, "height", "16"), attr$1I(a, "xmlns", "http://www.w3.org/2000/svg"), attr$1I(a, "width", "100%"), attr$1I(a, "height", "100%"), attr$1I(a, "viewBox", "0 0 24 24"), attr$1I(a, "fill", "currentColor"), attr$1I(a, "stroke", "currentColor"), attr$1I(a, "stroke-width", "1.5"), attr$1I(a, "stroke-linecap", "round"), attr$1I(a, "stroke-linejoin", "round");
    },
    m(u, _) {
      insert_hydration$1L(u, a, _), append_hydration$1C(a, h), append_hydration$1C(a, d);
    },
    p: noop$1t,
    i: noop$1t,
    o: noop$1t,
    d(u) {
      u && detach$1L(a);
    }
  };
}
class Pause extends SvelteComponent$1Q {
  constructor(a) {
    super(), init$1Q(this, a, null, create_fragment$m, safe_not_equal$1R, {});
  }
}
const {
  SvelteComponent: SvelteComponent$1P,
  append_hydration: append_hydration$1B,
  attr: attr$1H,
  children: children$1I,
  claim_svg_element: claim_svg_element$1k,
  detach: detach$1K,
  init: init$1P,
  insert_hydration: insert_hydration$1K,
  noop: noop$1s,
  safe_not_equal: safe_not_equal$1Q,
  svg_element: svg_element$1k
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1O,
  append_hydration: append_hydration$1A,
  attr: attr$1G,
  children: children$1H,
  claim_svg_element: claim_svg_element$1j,
  detach: detach$1J,
  init: init$1O,
  insert_hydration: insert_hydration$1J,
  noop: noop$1r,
  safe_not_equal: safe_not_equal$1P,
  svg_element: svg_element$1j
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1N,
  append_hydration: append_hydration$1z,
  attr: attr$1F,
  children: children$1G,
  claim_svg_element: claim_svg_element$1i,
  detach: detach$1I,
  init: init$1N,
  insert_hydration: insert_hydration$1I,
  noop: noop$1q,
  safe_not_equal: safe_not_equal$1O,
  set_style: set_style$b,
  svg_element: svg_element$1i
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1M,
  append_hydration: append_hydration$1y,
  attr: attr$1E,
  children: children$1F,
  claim_svg_element: claim_svg_element$1h,
  detach: detach$1H,
  init: init$1M,
  insert_hydration: insert_hydration$1H,
  noop: noop$1p,
  safe_not_equal: safe_not_equal$1N,
  svg_element: svg_element$1h
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1L,
  append_hydration: append_hydration$1x,
  attr: attr$1D,
  children: children$1E,
  claim_svg_element: claim_svg_element$1g,
  detach: detach$1G,
  init: init$1L,
  insert_hydration: insert_hydration$1G,
  noop: noop$1o,
  safe_not_equal: safe_not_equal$1M,
  svg_element: svg_element$1g
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1K,
  append_hydration: append_hydration$1w,
  attr: attr$1C,
  children: children$1D,
  claim_svg_element: claim_svg_element$1f,
  detach: detach$1F,
  init: init$1K,
  insert_hydration: insert_hydration$1F,
  noop: noop$1n,
  safe_not_equal: safe_not_equal$1L,
  svg_element: svg_element$1f
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1J,
  append_hydration: append_hydration$1v,
  attr: attr$1B,
  children: children$1C,
  claim_svg_element: claim_svg_element$1e,
  detach: detach$1E,
  init: init$1J,
  insert_hydration: insert_hydration$1E,
  noop: noop$1m,
  safe_not_equal: safe_not_equal$1K,
  svg_element: svg_element$1e
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1I,
  append_hydration: append_hydration$1u,
  attr: attr$1A,
  children: children$1B,
  claim_svg_element: claim_svg_element$1d,
  detach: detach$1D,
  init: init$1I,
  insert_hydration: insert_hydration$1D,
  noop: noop$1l,
  safe_not_equal: safe_not_equal$1J,
  svg_element: svg_element$1d
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1H,
  append_hydration: append_hydration$1t,
  attr: attr$1z,
  children: children$1A,
  claim_svg_element: claim_svg_element$1c,
  detach: detach$1C,
  init: init$1H,
  insert_hydration: insert_hydration$1C,
  noop: noop$1k,
  safe_not_equal: safe_not_equal$1I,
  svg_element: svg_element$1c
} = window.__gradio__svelte__internal;
function create_fragment$l(c) {
  let a, h;
  return {
    c() {
      a = svg_element$1c("svg"), h = svg_element$1c("rect"), this.h();
    },
    l(d) {
      a = claim_svg_element$1c(d, "svg", {
        xmlns: !0,
        width: !0,
        height: !0,
        viewBox: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        "stroke-linejoin": !0,
        class: !0
      });
      var u = children$1A(a);
      h = claim_svg_element$1c(u, "rect", {
        x: !0,
        y: !0,
        width: !0,
        height: !0,
        rx: !0,
        ry: !0
      }), children$1A(h).forEach(detach$1C), u.forEach(detach$1C), this.h();
    },
    h() {
      attr$1z(h, "x", "3"), attr$1z(h, "y", "3"), attr$1z(h, "width", "18"), attr$1z(h, "height", "18"), attr$1z(h, "rx", "2"), attr$1z(h, "ry", "2"), attr$1z(a, "xmlns", "http://www.w3.org/2000/svg"), attr$1z(a, "width", "100%"), attr$1z(a, "height", "100%"), attr$1z(a, "viewBox", "0 0 24 24"), attr$1z(a, "stroke-width", "1.5"), attr$1z(a, "stroke-linecap", "round"), attr$1z(a, "stroke-linejoin", "round"), attr$1z(a, "class", "feather feather-square");
    },
    m(d, u) {
      insert_hydration$1C(d, a, u), append_hydration$1t(a, h);
    },
    p: noop$1k,
    i: noop$1k,
    o: noop$1k,
    d(d) {
      d && detach$1C(a);
    }
  };
}
class Square extends SvelteComponent$1H {
  constructor(a) {
    super(), init$1H(this, a, null, create_fragment$l, safe_not_equal$1I, {});
  }
}
const {
  SvelteComponent: SvelteComponent$1G,
  append_hydration: append_hydration$1s,
  attr: attr$1y,
  children: children$1z,
  claim_svg_element: claim_svg_element$1b,
  detach: detach$1B,
  init: init$1G,
  insert_hydration: insert_hydration$1B,
  noop: noop$1j,
  safe_not_equal: safe_not_equal$1H,
  svg_element: svg_element$1b
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1F,
  append_hydration: append_hydration$1r,
  attr: attr$1x,
  children: children$1y,
  claim_svg_element: claim_svg_element$1a,
  detach: detach$1A,
  init: init$1F,
  insert_hydration: insert_hydration$1A,
  noop: noop$1i,
  safe_not_equal: safe_not_equal$1G,
  svg_element: svg_element$1a
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1E,
  append_hydration: append_hydration$1q,
  attr: attr$1w,
  children: children$1x,
  claim_svg_element: claim_svg_element$19,
  claim_text: claim_text$m,
  detach: detach$1z,
  init: init$1E,
  insert_hydration: insert_hydration$1z,
  noop: noop$1h,
  safe_not_equal: safe_not_equal$1F,
  svg_element: svg_element$19,
  text: text$n
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1D,
  append_hydration: append_hydration$1p,
  attr: attr$1v,
  children: children$1w,
  claim_svg_element: claim_svg_element$18,
  detach: detach$1y,
  init: init$1D,
  insert_hydration: insert_hydration$1y,
  noop: noop$1g,
  safe_not_equal: safe_not_equal$1E,
  svg_element: svg_element$18
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1C,
  append_hydration: append_hydration$1o,
  attr: attr$1u,
  children: children$1v,
  claim_svg_element: claim_svg_element$17,
  detach: detach$1x,
  init: init$1C,
  insert_hydration: insert_hydration$1x,
  noop: noop$1f,
  safe_not_equal: safe_not_equal$1D,
  svg_element: svg_element$17
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1B,
  append_hydration: append_hydration$1n,
  attr: attr$1t,
  children: children$1u,
  claim_svg_element: claim_svg_element$16,
  detach: detach$1w,
  init: init$1B,
  insert_hydration: insert_hydration$1w,
  noop: noop$1e,
  safe_not_equal: safe_not_equal$1C,
  svg_element: svg_element$16
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1A,
  append_hydration: append_hydration$1m,
  attr: attr$1s,
  children: children$1t,
  claim_svg_element: claim_svg_element$15,
  detach: detach$1v,
  init: init$1A,
  insert_hydration: insert_hydration$1v,
  noop: noop$1d,
  safe_not_equal: safe_not_equal$1B,
  svg_element: svg_element$15
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1z,
  append_hydration: append_hydration$1l,
  attr: attr$1r,
  children: children$1s,
  claim_svg_element: claim_svg_element$14,
  detach: detach$1u,
  init: init$1z,
  insert_hydration: insert_hydration$1u,
  noop: noop$1c,
  safe_not_equal: safe_not_equal$1A,
  svg_element: svg_element$14
} = window.__gradio__svelte__internal;
function create_fragment$k(c) {
  let a, h, d;
  return {
    c() {
      a = svg_element$14("svg"), h = svg_element$14("polygon"), d = svg_element$14("rect"), this.h();
    },
    l(u) {
      a = claim_svg_element$14(u, "svg", {
        xmlns: !0,
        width: !0,
        height: !0,
        viewBox: !0,
        fill: !0,
        stroke: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        "stroke-linejoin": !0,
        class: !0
      });
      var _ = children$1s(a);
      h = claim_svg_element$14(_, "polygon", {
        points: !0
      }), children$1s(h).forEach(detach$1u), d = claim_svg_element$14(_, "rect", {
        x: !0,
        y: !0,
        width: !0,
        height: !0,
        rx: !0,
        ry: !0
      }), children$1s(d).forEach(detach$1u), _.forEach(detach$1u), this.h();
    },
    h() {
      attr$1r(h, "points", "23 7 16 12 23 17 23 7"), attr$1r(d, "x", "1"), attr$1r(d, "y", "5"), attr$1r(d, "width", "15"), attr$1r(d, "height", "14"), attr$1r(d, "rx", "2"), attr$1r(d, "ry", "2"), attr$1r(a, "xmlns", "http://www.w3.org/2000/svg"), attr$1r(a, "width", "100%"), attr$1r(a, "height", "100%"), attr$1r(a, "viewBox", "0 0 24 24"), attr$1r(a, "fill", "none"), attr$1r(a, "stroke", "currentColor"), attr$1r(a, "stroke-width", "1.5"), attr$1r(a, "stroke-linecap", "round"), attr$1r(a, "stroke-linejoin", "round"), attr$1r(a, "class", "feather feather-video");
    },
    m(u, _) {
      insert_hydration$1u(u, a, _), append_hydration$1l(a, h), append_hydration$1l(a, d);
    },
    p: noop$1c,
    i: noop$1c,
    o: noop$1c,
    d(u) {
      u && detach$1u(a);
    }
  };
}
let Video$1 = class extends SvelteComponent$1z {
  constructor(a) {
    super(), init$1z(this, a, null, create_fragment$k, safe_not_equal$1A, {});
  }
};
const {
  SvelteComponent: SvelteComponent$1y,
  append_hydration: append_hydration$1k,
  attr: attr$1q,
  children: children$1r,
  claim_svg_element: claim_svg_element$13,
  claim_text: claim_text$l,
  detach: detach$1t,
  init: init$1y,
  insert_hydration: insert_hydration$1t,
  noop: noop$1b,
  safe_not_equal: safe_not_equal$1z,
  svg_element: svg_element$13,
  text: text$m
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1x,
  append_hydration: append_hydration$1j,
  attr: attr$1p,
  children: children$1q,
  claim_svg_element: claim_svg_element$12,
  claim_text: claim_text$k,
  detach: detach$1s,
  init: init$1x,
  insert_hydration: insert_hydration$1s,
  noop: noop$1a,
  safe_not_equal: safe_not_equal$1y,
  svg_element: svg_element$12,
  text: text$l
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1w,
  append_hydration: append_hydration$1i,
  attr: attr$1o,
  children: children$1p,
  claim_svg_element: claim_svg_element$11,
  claim_text: claim_text$j,
  detach: detach$1r,
  init: init$1w,
  insert_hydration: insert_hydration$1r,
  noop: noop$19,
  safe_not_equal: safe_not_equal$1x,
  svg_element: svg_element$11,
  text: text$k
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1v,
  append_hydration: append_hydration$1h,
  attr: attr$1n,
  children: children$1o,
  claim_svg_element: claim_svg_element$10,
  detach: detach$1q,
  init: init$1v,
  insert_hydration: insert_hydration$1q,
  noop: noop$18,
  safe_not_equal: safe_not_equal$1w,
  svg_element: svg_element$10
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1u,
  append_hydration: append_hydration$1g,
  attr: attr$1m,
  children: children$1n,
  claim_svg_element: claim_svg_element$$,
  detach: detach$1p,
  init: init$1u,
  insert_hydration: insert_hydration$1p,
  noop: noop$17,
  safe_not_equal: safe_not_equal$1v,
  svg_element: svg_element$$
} = window.__gradio__svelte__internal;
function create_fragment$j(c) {
  let a, h, d;
  return {
    c() {
      a = svg_element$$("svg"), h = svg_element$$("path"), d = svg_element$$("path"), this.h();
    },
    l(u) {
      a = claim_svg_element$$(u, "svg", {
        xmlns: !0,
        width: !0,
        height: !0,
        viewBox: !0
      });
      var _ = children$1n(a);
      h = claim_svg_element$$(_, "path", {
        fill: !0,
        d: !0
      }), children$1n(h).forEach(detach$1p), d = claim_svg_element$$(_, "path", {
        fill: !0,
        d: !0
      }), children$1n(d).forEach(detach$1p), _.forEach(detach$1p), this.h();
    },
    h() {
      attr$1m(h, "fill", "currentColor"), attr$1m(h, "d", "M12 2c-4.963 0-9 4.038-9 9c0 3.328 1.82 6.232 4.513 7.79l-2.067 1.378A1 1 0 0 0 6 22h12a1 1 0 0 0 .555-1.832l-2.067-1.378C19.18 17.232 21 14.328 21 11c0-4.962-4.037-9-9-9zm0 16c-3.859 0-7-3.141-7-7c0-3.86 3.141-7 7-7s7 3.14 7 7c0 3.859-3.141 7-7 7z"), attr$1m(d, "fill", "currentColor"), attr$1m(d, "d", "M12 6c-2.757 0-5 2.243-5 5s2.243 5 5 5s5-2.243 5-5s-2.243-5-5-5zm0 8c-1.654 0-3-1.346-3-3s1.346-3 3-3s3 1.346 3 3s-1.346 3-3 3z"), attr$1m(a, "xmlns", "http://www.w3.org/2000/svg"), attr$1m(a, "width", "100%"), attr$1m(a, "height", "100%"), attr$1m(a, "viewBox", "0 0 24 24");
    },
    m(u, _) {
      insert_hydration$1p(u, a, _), append_hydration$1g(a, h), append_hydration$1g(a, d);
    },
    p: noop$17,
    i: noop$17,
    o: noop$17,
    d(u) {
      u && detach$1p(a);
    }
  };
}
class Webcam extends SvelteComponent$1u {
  constructor(a) {
    super(), init$1u(this, a, null, create_fragment$j, safe_not_equal$1v, {});
  }
}
const color_values = [{
  color: "red",
  primary: 600,
  secondary: 100
}, {
  color: "green",
  primary: 600,
  secondary: 100
}, {
  color: "blue",
  primary: 600,
  secondary: 100
}, {
  color: "yellow",
  primary: 500,
  secondary: 100
}, {
  color: "purple",
  primary: 600,
  secondary: 100
}, {
  color: "teal",
  primary: 600,
  secondary: 100
}, {
  color: "orange",
  primary: 600,
  secondary: 100
}, {
  color: "cyan",
  primary: 600,
  secondary: 100
}, {
  color: "lime",
  primary: 500,
  secondary: 100
}, {
  color: "pink",
  primary: 600,
  secondary: 100
}], tw_colors = {
  inherit: "inherit",
  current: "currentColor",
  transparent: "transparent",
  black: "#000",
  white: "#fff",
  slate: {
    50: "#f8fafc",
    100: "#f1f5f9",
    200: "#e2e8f0",
    300: "#cbd5e1",
    400: "#94a3b8",
    500: "#64748b",
    600: "#475569",
    700: "#334155",
    800: "#1e293b",
    900: "#0f172a",
    950: "#020617"
  },
  gray: {
    50: "#f9fafb",
    100: "#f3f4f6",
    200: "#e5e7eb",
    300: "#d1d5db",
    400: "#9ca3af",
    500: "#6b7280",
    600: "#4b5563",
    700: "#374151",
    800: "#1f2937",
    900: "#111827",
    950: "#030712"
  },
  zinc: {
    50: "#fafafa",
    100: "#f4f4f5",
    200: "#e4e4e7",
    300: "#d4d4d8",
    400: "#a1a1aa",
    500: "#71717a",
    600: "#52525b",
    700: "#3f3f46",
    800: "#27272a",
    900: "#18181b",
    950: "#09090b"
  },
  neutral: {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#e5e5e5",
    300: "#d4d4d4",
    400: "#a3a3a3",
    500: "#737373",
    600: "#525252",
    700: "#404040",
    800: "#262626",
    900: "#171717",
    950: "#0a0a0a"
  },
  stone: {
    50: "#fafaf9",
    100: "#f5f5f4",
    200: "#e7e5e4",
    300: "#d6d3d1",
    400: "#a8a29e",
    500: "#78716c",
    600: "#57534e",
    700: "#44403c",
    800: "#292524",
    900: "#1c1917",
    950: "#0c0a09"
  },
  red: {
    50: "#fef2f2",
    100: "#fee2e2",
    200: "#fecaca",
    300: "#fca5a5",
    400: "#f87171",
    500: "#ef4444",
    600: "#dc2626",
    700: "#b91c1c",
    800: "#991b1b",
    900: "#7f1d1d",
    950: "#450a0a"
  },
  orange: {
    50: "#fff7ed",
    100: "#ffedd5",
    200: "#fed7aa",
    300: "#fdba74",
    400: "#fb923c",
    500: "#f97316",
    600: "#ea580c",
    700: "#c2410c",
    800: "#9a3412",
    900: "#7c2d12",
    950: "#431407"
  },
  amber: {
    50: "#fffbeb",
    100: "#fef3c7",
    200: "#fde68a",
    300: "#fcd34d",
    400: "#fbbf24",
    500: "#f59e0b",
    600: "#d97706",
    700: "#b45309",
    800: "#92400e",
    900: "#78350f",
    950: "#451a03"
  },
  yellow: {
    50: "#fefce8",
    100: "#fef9c3",
    200: "#fef08a",
    300: "#fde047",
    400: "#facc15",
    500: "#eab308",
    600: "#ca8a04",
    700: "#a16207",
    800: "#854d0e",
    900: "#713f12",
    950: "#422006"
  },
  lime: {
    50: "#f7fee7",
    100: "#ecfccb",
    200: "#d9f99d",
    300: "#bef264",
    400: "#a3e635",
    500: "#84cc16",
    600: "#65a30d",
    700: "#4d7c0f",
    800: "#3f6212",
    900: "#365314",
    950: "#1a2e05"
  },
  green: {
    50: "#f0fdf4",
    100: "#dcfce7",
    200: "#bbf7d0",
    300: "#86efac",
    400: "#4ade80",
    500: "#22c55e",
    600: "#16a34a",
    700: "#15803d",
    800: "#166534",
    900: "#14532d",
    950: "#052e16"
  },
  emerald: {
    50: "#ecfdf5",
    100: "#d1fae5",
    200: "#a7f3d0",
    300: "#6ee7b7",
    400: "#34d399",
    500: "#10b981",
    600: "#059669",
    700: "#047857",
    800: "#065f46",
    900: "#064e3b",
    950: "#022c22"
  },
  teal: {
    50: "#f0fdfa",
    100: "#ccfbf1",
    200: "#99f6e4",
    300: "#5eead4",
    400: "#2dd4bf",
    500: "#14b8a6",
    600: "#0d9488",
    700: "#0f766e",
    800: "#115e59",
    900: "#134e4a",
    950: "#042f2e"
  },
  cyan: {
    50: "#ecfeff",
    100: "#cffafe",
    200: "#a5f3fc",
    300: "#67e8f9",
    400: "#22d3ee",
    500: "#06b6d4",
    600: "#0891b2",
    700: "#0e7490",
    800: "#155e75",
    900: "#164e63",
    950: "#083344"
  },
  sky: {
    50: "#f0f9ff",
    100: "#e0f2fe",
    200: "#bae6fd",
    300: "#7dd3fc",
    400: "#38bdf8",
    500: "#0ea5e9",
    600: "#0284c7",
    700: "#0369a1",
    800: "#075985",
    900: "#0c4a6e",
    950: "#082f49"
  },
  blue: {
    50: "#eff6ff",
    100: "#dbeafe",
    200: "#bfdbfe",
    300: "#93c5fd",
    400: "#60a5fa",
    500: "#3b82f6",
    600: "#2563eb",
    700: "#1d4ed8",
    800: "#1e40af",
    900: "#1e3a8a",
    950: "#172554"
  },
  indigo: {
    50: "#eef2ff",
    100: "#e0e7ff",
    200: "#c7d2fe",
    300: "#a5b4fc",
    400: "#818cf8",
    500: "#6366f1",
    600: "#4f46e5",
    700: "#4338ca",
    800: "#3730a3",
    900: "#312e81",
    950: "#1e1b4b"
  },
  violet: {
    50: "#f5f3ff",
    100: "#ede9fe",
    200: "#ddd6fe",
    300: "#c4b5fd",
    400: "#a78bfa",
    500: "#8b5cf6",
    600: "#7c3aed",
    700: "#6d28d9",
    800: "#5b21b6",
    900: "#4c1d95",
    950: "#2e1065"
  },
  purple: {
    50: "#faf5ff",
    100: "#f3e8ff",
    200: "#e9d5ff",
    300: "#d8b4fe",
    400: "#c084fc",
    500: "#a855f7",
    600: "#9333ea",
    700: "#7e22ce",
    800: "#6b21a8",
    900: "#581c87",
    950: "#3b0764"
  },
  fuchsia: {
    50: "#fdf4ff",
    100: "#fae8ff",
    200: "#f5d0fe",
    300: "#f0abfc",
    400: "#e879f9",
    500: "#d946ef",
    600: "#c026d3",
    700: "#a21caf",
    800: "#86198f",
    900: "#701a75",
    950: "#4a044e"
  },
  pink: {
    50: "#fdf2f8",
    100: "#fce7f3",
    200: "#fbcfe8",
    300: "#f9a8d4",
    400: "#f472b6",
    500: "#ec4899",
    600: "#db2777",
    700: "#be185d",
    800: "#9d174d",
    900: "#831843",
    950: "#500724"
  },
  rose: {
    50: "#fff1f2",
    100: "#ffe4e6",
    200: "#fecdd3",
    300: "#fda4af",
    400: "#fb7185",
    500: "#f43f5e",
    600: "#e11d48",
    700: "#be123c",
    800: "#9f1239",
    900: "#881337",
    950: "#4c0519"
  }
};
color_values.reduce((c, {
  color: a,
  primary: h,
  secondary: d
}) => ({
  ...c,
  [a]: {
    primary: tw_colors[a][h],
    secondary: tw_colors[a][d]
  }
}), {});
const {
  SvelteComponent: SvelteComponent$1t,
  claim_component: claim_component$n,
  create_component: create_component$n,
  destroy_component: destroy_component$n,
  init: init$1t,
  mount_component: mount_component$n,
  safe_not_equal: safe_not_equal$1u,
  transition_in: transition_in$t,
  transition_out: transition_out$t
} = window.__gradio__svelte__internal, {
  createEventDispatcher: createEventDispatcher$9
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1s,
  append_hydration: append_hydration$1f,
  attr: attr$1l,
  check_outros: check_outros$f,
  children: children$1m,
  claim_component: claim_component$m,
  claim_element: claim_element$o,
  claim_space: claim_space$h,
  claim_text: claim_text$i,
  create_component: create_component$m,
  destroy_component: destroy_component$m,
  detach: detach$1o,
  element: element$o,
  group_outros: group_outros$f,
  init: init$1s,
  insert_hydration: insert_hydration$1o,
  mount_component: mount_component$m,
  safe_not_equal: safe_not_equal$1t,
  set_data: set_data$e,
  space: space$h,
  text: text$j,
  toggle_class: toggle_class$j,
  transition_in: transition_in$s,
  transition_out: transition_out$s
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1r,
  attr: attr$1k,
  children: children$1l,
  claim_element: claim_element$n,
  create_slot: create_slot$7,
  detach: detach$1n,
  element: element$n,
  get_all_dirty_from_scope: get_all_dirty_from_scope$7,
  get_slot_changes: get_slot_changes$7,
  init: init$1r,
  insert_hydration: insert_hydration$1n,
  safe_not_equal: safe_not_equal$1s,
  toggle_class: toggle_class$i,
  transition_in: transition_in$r,
  transition_out: transition_out$r,
  update_slot_base: update_slot_base$7
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1q,
  append_hydration: append_hydration$1e,
  attr: attr$1j,
  check_outros: check_outros$e,
  children: children$1k,
  claim_component: claim_component$l,
  claim_element: claim_element$m,
  claim_space: claim_space$g,
  create_component: create_component$l,
  destroy_component: destroy_component$l,
  detach: detach$1m,
  element: element$m,
  empty: empty$9,
  group_outros: group_outros$e,
  init: init$1q,
  insert_hydration: insert_hydration$1m,
  listen: listen$9,
  mount_component: mount_component$l,
  safe_not_equal: safe_not_equal$1r,
  space: space$g,
  toggle_class: toggle_class$h,
  transition_in: transition_in$q,
  transition_out: transition_out$q
} = window.__gradio__svelte__internal;
new Intl.Collator(0, {
  numeric: 1
}).compare;
const UPLOAD_URL = "upload", BROKEN_CONNECTION_MSG = "Connection errored out. ";
async function upload_files(c, a, h) {
  var $;
  const d = {};
  ($ = this == null ? void 0 : this.options) != null && $.hf_token && (d.Authorization = `Bearer ${this.options.hf_token}`);
  const u = 1e3, _ = [];
  let g;
  for (let b = 0; b < a.length; b += u) {
    const y = a.slice(b, b + u), v = new FormData();
    y.forEach((S) => {
      v.append("files", S);
    });
    try {
      const S = h ? `${c}${this.api_prefix}/${UPLOAD_URL}?upload_id=${h}` : `${c}${this.api_prefix}/${UPLOAD_URL}`;
      g = await this.fetch(S, {
        method: "POST",
        body: v,
        headers: d,
        credentials: "include"
      });
    } catch (S) {
      throw new Error(BROKEN_CONNECTION_MSG + S.message);
    }
    if (!g.ok) {
      const S = await g.text();
      return {
        error: `HTTP ${g.status}: ${S}`
      };
    }
    const E = await g.json();
    E && _.push(...E);
  }
  return {
    files: _
  };
}
async function prepare_files(c, a) {
  return c.map((h) => new FileData({
    path: h.name,
    orig_name: h.name,
    blob: h,
    size: h.size,
    mime_type: h.type,
    is_stream: a
  }));
}
class FileData {
  constructor({
    path: a,
    url: h,
    orig_name: d,
    size: u,
    blob: _,
    is_stream: g,
    mime_type: $,
    alt_text: b,
    b64: y
  }) {
    _t(this, "path");
    _t(this, "url");
    _t(this, "orig_name");
    _t(this, "size");
    _t(this, "blob");
    _t(this, "is_stream");
    _t(this, "mime_type");
    _t(this, "alt_text");
    _t(this, "b64");
    _t(this, "meta", {
      _type: "gradio.FileData"
    });
    this.path = a, this.url = h, this.orig_name = d, this.size = u, this.blob = h ? void 0 : _, this.is_stream = g, this.mime_type = $, this.alt_text = b, this.b64 = y;
  }
}
typeof process < "u" && process.versions && process.versions.node;
var St;
class TextLineStream extends TransformStream {
  /** Constructs a new instance. */
  constructor(h = {
    allowCR: !1
  }) {
    super({
      transform: (d, u) => {
        for (d = w(this, St) + d; ; ) {
          const _ = d.indexOf(`
`), g = h.allowCR ? d.indexOf("\r") : -1;
          if (g !== -1 && g !== d.length - 1 && (_ === -1 || _ - 1 > g)) {
            u.enqueue(d.slice(0, g)), d = d.slice(g + 1);
            continue;
          }
          if (_ === -1) break;
          const $ = d[_ - 1] === "\r" ? _ - 1 : _;
          u.enqueue(d.slice(0, $)), d = d.slice(_ + 1);
        }
        Se(this, St, d);
      },
      flush: (d) => {
        if (w(this, St) === "") return;
        const u = h.allowCR && w(this, St).endsWith("\r") ? w(this, St).slice(0, -1) : w(this, St);
        d.enqueue(u);
      }
    });
    Ee(this, St, "");
  }
}
St = new WeakMap();
function pretty_si(c) {
  let a = ["", "k", "M", "G", "T", "P", "E", "Z"], h = 0;
  for (; c > 1e3 && h < a.length - 1; )
    c /= 1e3, h++;
  let d = a[h];
  return (Number.isInteger(c) ? c : c.toFixed(1)) + d;
}
function noop$16() {
}
function run(c) {
  return c();
}
function run_all$5(c) {
  c.forEach(run);
}
function is_function$2(c) {
  return typeof c == "function";
}
function safe_not_equal$1q(c, a) {
  return c != c ? a == a : c !== a || c && typeof c == "object" || typeof c == "function";
}
function subscribe(c, ...a) {
  if (c == null) {
    for (const d of a)
      d(void 0);
    return noop$16;
  }
  const h = c.subscribe(...a);
  return h.unsubscribe ? () => h.unsubscribe() : h;
}
const is_client = typeof window < "u";
let now = is_client ? () => window.performance.now() : () => Date.now(), raf = is_client ? (c) => requestAnimationFrame(c) : noop$16;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(c) {
  tasks.forEach((a) => {
    a.c(c) || (tasks.delete(a), a.f());
  }), tasks.size !== 0 && raf(run_tasks);
}
function loop(c) {
  let a;
  return tasks.size === 0 && raf(run_tasks), {
    promise: new Promise((h) => {
      tasks.add(a = {
        c,
        f: h
      });
    }),
    abort() {
      tasks.delete(a);
    }
  };
}
const subscriber_queue = [];
function readable(c, a) {
  return {
    subscribe: writable(c, a).subscribe
  };
}
function writable(c, a = noop$16) {
  let h;
  const d = /* @__PURE__ */ new Set();
  function u($) {
    if (safe_not_equal$1q(c, $) && (c = $, h)) {
      const b = !subscriber_queue.length;
      for (const y of d)
        y[1](), subscriber_queue.push(y, c);
      if (b) {
        for (let y = 0; y < subscriber_queue.length; y += 2)
          subscriber_queue[y][0](subscriber_queue[y + 1]);
        subscriber_queue.length = 0;
      }
    }
  }
  function _($) {
    u($(c));
  }
  function g($, b = noop$16) {
    const y = [$, b];
    return d.add(y), d.size === 1 && (h = a(u, _) || noop$16), $(c), () => {
      d.delete(y), d.size === 0 && h && (h(), h = null);
    };
  }
  return {
    set: u,
    update: _,
    subscribe: g
  };
}
function derived(c, a, h) {
  const d = !Array.isArray(c), u = d ? [c] : c;
  if (!u.every(Boolean))
    throw new Error("derived() expects stores as input, got a falsy value");
  const _ = a.length < 2;
  return readable(h, (g, $) => {
    let b = !1;
    const y = [];
    let v = 0, E = noop$16;
    const S = () => {
      if (v)
        return;
      E();
      const x = a(d ? y[0] : y, g, $);
      _ ? g(x) : E = is_function$2(x) ? x : noop$16;
    }, R = u.map((x, H) => subscribe(x, (T) => {
      y[H] = T, v &= ~(1 << H), b && S();
    }, () => {
      v |= 1 << H;
    }));
    return b = !0, S(), function() {
      run_all$5(R), E(), b = !1;
    };
  });
}
function is_date(c) {
  return Object.prototype.toString.call(c) === "[object Date]";
}
function tick_spring(c, a, h, d) {
  if (typeof h == "number" || is_date(h)) {
    const u = d - h, _ = (h - a) / (c.dt || 1 / 60), g = c.opts.stiffness * u, $ = c.opts.damping * _, b = (g - $) * c.inv_mass, y = (_ + b) * c.dt;
    return Math.abs(y) < c.opts.precision && Math.abs(u) < c.opts.precision ? d : (c.settled = !1, is_date(h) ? new Date(h.getTime() + y) : h + y);
  } else {
    if (Array.isArray(h))
      return h.map((u, _) => tick_spring(c, a[_], h[_], d[_]));
    if (typeof h == "object") {
      const u = {};
      for (const _ in h)
        u[_] = tick_spring(c, a[_], h[_], d[_]);
      return u;
    } else
      throw new Error(`Cannot spring ${typeof h} values`);
  }
}
function spring(c, a = {}) {
  const h = writable(c), {
    stiffness: d = 0.15,
    damping: u = 0.8,
    precision: _ = 0.01
  } = a;
  let g, $, b, y = c, v = c, E = 1, S = 0, R = !1;
  function x(T, C = {}) {
    v = T;
    const O = b = {};
    return c == null || C.hard || H.stiffness >= 1 && H.damping >= 1 ? (R = !0, g = now(), y = T, h.set(c = v), Promise.resolve()) : (C.soft && (S = 1 / ((C.soft === !0 ? 0.5 : +C.soft) * 60), E = 0), $ || (g = now(), R = !1, $ = loop((j) => {
      if (R)
        return R = !1, $ = null, !1;
      E = Math.min(E + S, 1);
      const B = {
        inv_mass: E,
        opts: H,
        settled: !0,
        dt: (j - g) * 60 / 1e3
      }, D = tick_spring(B, y, c, v);
      return g = j, y = c, h.set(c = D), B.settled && ($ = null), !B.settled;
    })), new Promise((j) => {
      $.promise.then(() => {
        O === b && j();
      });
    }));
  }
  const H = {
    set: x,
    update: (T, C) => x(T(v, c), C),
    subscribe: h.subscribe,
    stiffness: d,
    damping: u,
    precision: _
  };
  return H;
}
const {
  SvelteComponent: SvelteComponent$1p,
  append_hydration: append_hydration$1d,
  attr: attr$1i,
  children: children$1j,
  claim_element: claim_element$l,
  claim_svg_element: claim_svg_element$_,
  component_subscribe,
  detach: detach$1l,
  element: element$l,
  init: init$1p,
  insert_hydration: insert_hydration$1l,
  noop: noop$15,
  safe_not_equal: safe_not_equal$1p,
  set_style: set_style$a,
  svg_element: svg_element$_,
  toggle_class: toggle_class$g
} = window.__gradio__svelte__internal, {
  onMount: onMount$4
} = window.__gradio__svelte__internal;
function create_fragment$i(c) {
  let a, h, d, u, _, g, $, b, y, v, E, S;
  return {
    c() {
      a = element$l("div"), h = svg_element$_("svg"), d = svg_element$_("g"), u = svg_element$_("path"), _ = svg_element$_("path"), g = svg_element$_("path"), $ = svg_element$_("path"), b = svg_element$_("g"), y = svg_element$_("path"), v = svg_element$_("path"), E = svg_element$_("path"), S = svg_element$_("path"), this.h();
    },
    l(R) {
      a = claim_element$l(R, "DIV", {
        class: !0
      });
      var x = children$1j(a);
      h = claim_svg_element$_(x, "svg", {
        viewBox: !0,
        fill: !0,
        xmlns: !0,
        class: !0
      });
      var H = children$1j(h);
      d = claim_svg_element$_(H, "g", {
        style: !0
      });
      var T = children$1j(d);
      u = claim_svg_element$_(T, "path", {
        d: !0,
        fill: !0,
        "fill-opacity": !0,
        class: !0
      }), children$1j(u).forEach(detach$1l), _ = claim_svg_element$_(T, "path", {
        d: !0,
        fill: !0,
        class: !0
      }), children$1j(_).forEach(detach$1l), g = claim_svg_element$_(T, "path", {
        d: !0,
        fill: !0,
        "fill-opacity": !0,
        class: !0
      }), children$1j(g).forEach(detach$1l), $ = claim_svg_element$_(T, "path", {
        d: !0,
        fill: !0,
        class: !0
      }), children$1j($).forEach(detach$1l), T.forEach(detach$1l), b = claim_svg_element$_(H, "g", {
        style: !0
      });
      var C = children$1j(b);
      y = claim_svg_element$_(C, "path", {
        d: !0,
        fill: !0,
        "fill-opacity": !0,
        class: !0
      }), children$1j(y).forEach(detach$1l), v = claim_svg_element$_(C, "path", {
        d: !0,
        fill: !0,
        class: !0
      }), children$1j(v).forEach(detach$1l), E = claim_svg_element$_(C, "path", {
        d: !0,
        fill: !0,
        "fill-opacity": !0,
        class: !0
      }), children$1j(E).forEach(detach$1l), S = claim_svg_element$_(C, "path", {
        d: !0,
        fill: !0,
        class: !0
      }), children$1j(S).forEach(detach$1l), C.forEach(detach$1l), H.forEach(detach$1l), x.forEach(detach$1l), this.h();
    },
    h() {
      attr$1i(u, "d", "M255.926 0.754768L509.702 139.936V221.027L255.926 81.8465V0.754768Z"), attr$1i(u, "fill", "#FF7C00"), attr$1i(u, "fill-opacity", "0.4"), attr$1i(u, "class", "svelte-43sxxs"), attr$1i(_, "d", "M509.69 139.936L254.981 279.641V361.255L509.69 221.55V139.936Z"), attr$1i(_, "fill", "#FF7C00"), attr$1i(_, "class", "svelte-43sxxs"), attr$1i(g, "d", "M0.250138 139.937L254.981 279.641V361.255L0.250138 221.55V139.937Z"), attr$1i(g, "fill", "#FF7C00"), attr$1i(g, "fill-opacity", "0.4"), attr$1i(g, "class", "svelte-43sxxs"), attr$1i($, "d", "M255.923 0.232622L0.236328 139.936V221.55L255.923 81.8469V0.232622Z"), attr$1i($, "fill", "#FF7C00"), attr$1i($, "class", "svelte-43sxxs"), set_style$a(d, "transform", "translate(" + /*$top*/
      c[1][0] + "px, " + /*$top*/
      c[1][1] + "px)"), attr$1i(y, "d", "M255.926 141.5L509.702 280.681V361.773L255.926 222.592V141.5Z"), attr$1i(y, "fill", "#FF7C00"), attr$1i(y, "fill-opacity", "0.4"), attr$1i(y, "class", "svelte-43sxxs"), attr$1i(v, "d", "M509.69 280.679L254.981 420.384V501.998L509.69 362.293V280.679Z"), attr$1i(v, "fill", "#FF7C00"), attr$1i(v, "class", "svelte-43sxxs"), attr$1i(E, "d", "M0.250138 280.681L254.981 420.386V502L0.250138 362.295V280.681Z"), attr$1i(E, "fill", "#FF7C00"), attr$1i(E, "fill-opacity", "0.4"), attr$1i(E, "class", "svelte-43sxxs"), attr$1i(S, "d", "M255.923 140.977L0.236328 280.68V362.294L255.923 222.591V140.977Z"), attr$1i(S, "fill", "#FF7C00"), attr$1i(S, "class", "svelte-43sxxs"), set_style$a(b, "transform", "translate(" + /*$bottom*/
      c[2][0] + "px, " + /*$bottom*/
      c[2][1] + "px)"), attr$1i(h, "viewBox", "-1200 -1200 3000 3000"), attr$1i(h, "fill", "none"), attr$1i(h, "xmlns", "http://www.w3.org/2000/svg"), attr$1i(h, "class", "svelte-43sxxs"), attr$1i(a, "class", "svelte-43sxxs"), toggle_class$g(
        a,
        "margin",
        /*margin*/
        c[0]
      );
    },
    m(R, x) {
      insert_hydration$1l(R, a, x), append_hydration$1d(a, h), append_hydration$1d(h, d), append_hydration$1d(d, u), append_hydration$1d(d, _), append_hydration$1d(d, g), append_hydration$1d(d, $), append_hydration$1d(h, b), append_hydration$1d(b, y), append_hydration$1d(b, v), append_hydration$1d(b, E), append_hydration$1d(b, S);
    },
    p(R, [x]) {
      x & /*$top*/
      2 && set_style$a(d, "transform", "translate(" + /*$top*/
      R[1][0] + "px, " + /*$top*/
      R[1][1] + "px)"), x & /*$bottom*/
      4 && set_style$a(b, "transform", "translate(" + /*$bottom*/
      R[2][0] + "px, " + /*$bottom*/
      R[2][1] + "px)"), x & /*margin*/
      1 && toggle_class$g(
        a,
        "margin",
        /*margin*/
        R[0]
      );
    },
    i: noop$15,
    o: noop$15,
    d(R) {
      R && detach$1l(a);
    }
  };
}
function instance$e(c, a, h) {
  let d, u, {
    margin: _ = !0
  } = a;
  const g = spring([0, 0]);
  component_subscribe(c, g, (S) => h(1, d = S));
  const $ = spring([0, 0]);
  component_subscribe(c, $, (S) => h(2, u = S));
  let b;
  async function y() {
    await Promise.all([g.set([125, 140]), $.set([-125, -140])]), await Promise.all([g.set([-125, 140]), $.set([125, -140])]), await Promise.all([g.set([-125, 0]), $.set([125, -0])]), await Promise.all([g.set([125, 0]), $.set([-125, 0])]);
  }
  async function v() {
    await y(), b || v();
  }
  async function E() {
    await Promise.all([g.set([125, 0]), $.set([-125, 0])]), v();
  }
  return onMount$4(() => (E(), () => b = !0)), c.$$set = (S) => {
    "margin" in S && h(0, _ = S.margin);
  }, [_, d, u, g, $];
}
let Loader$1 = class extends SvelteComponent$1p {
  constructor(a) {
    super(), init$1p(this, a, instance$e, create_fragment$i, safe_not_equal$1p, {
      margin: 0
    });
  }
};
const {
  SvelteComponent: SvelteComponent$1o,
  assign: assign$6,
  children: children$1i,
  claim_element: claim_element$k,
  create_slot: create_slot$6,
  detach: detach$1k,
  element: element$k,
  get_all_dirty_from_scope: get_all_dirty_from_scope$6,
  get_slot_changes: get_slot_changes$6,
  get_spread_update: get_spread_update$5,
  init: init$1o,
  insert_hydration: insert_hydration$1k,
  safe_not_equal: safe_not_equal$1o,
  set_dynamic_element_data,
  set_style: set_style$9,
  toggle_class: toggle_class$f,
  transition_in: transition_in$p,
  transition_out: transition_out$p,
  update_slot_base: update_slot_base$6
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1n,
  attr: attr$1h,
  children: children$1h,
  claim_element: claim_element$j,
  create_slot: create_slot$5,
  detach: detach$1j,
  element: element$j,
  get_all_dirty_from_scope: get_all_dirty_from_scope$5,
  get_slot_changes: get_slot_changes$5,
  init: init$1n,
  insert_hydration: insert_hydration$1j,
  safe_not_equal: safe_not_equal$1n,
  transition_in: transition_in$o,
  transition_out: transition_out$o,
  update_slot_base: update_slot_base$5
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1m,
  attr: attr$1g,
  check_outros: check_outros$d,
  children: children$1g,
  claim_component: claim_component$k,
  claim_element: claim_element$i,
  claim_space: claim_space$f,
  claim_text: claim_text$h,
  create_component: create_component$k,
  create_slot: create_slot$4,
  destroy_component: destroy_component$k,
  detach: detach$1i,
  element: element$i,
  empty: empty$8,
  get_all_dirty_from_scope: get_all_dirty_from_scope$4,
  get_slot_changes: get_slot_changes$4,
  group_outros: group_outros$d,
  init: init$1m,
  insert_hydration: insert_hydration$1i,
  mount_component: mount_component$k,
  safe_not_equal: safe_not_equal$1m,
  set_data: set_data$d,
  space: space$f,
  text: text$i,
  toggle_class: toggle_class$e,
  transition_in: transition_in$n,
  transition_out: transition_out$n,
  update_slot_base: update_slot_base$4
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1l,
  append_hydration: append_hydration$1c,
  attr: attr$1f,
  children: children$1f,
  claim_component: claim_component$j,
  claim_element: claim_element$h,
  claim_space: claim_space$e,
  claim_text: claim_text$g,
  create_component: create_component$j,
  destroy_component: destroy_component$j,
  detach: detach$1h,
  element: element$h,
  init: init$1l,
  insert_hydration: insert_hydration$1h,
  mount_component: mount_component$j,
  safe_not_equal: safe_not_equal$1l,
  set_data: set_data$c,
  space: space$e,
  text: text$h,
  toggle_class: toggle_class$d,
  transition_in: transition_in$m,
  transition_out: transition_out$m
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1k,
  append_hydration: append_hydration$1b,
  attr: attr$1e,
  bubble: bubble$4,
  children: children$1e,
  claim_component: claim_component$i,
  claim_element: claim_element$g,
  claim_space: claim_space$d,
  claim_text: claim_text$f,
  create_component: create_component$i,
  destroy_component: destroy_component$i,
  detach: detach$1g,
  element: element$g,
  init: init$1k,
  insert_hydration: insert_hydration$1g,
  listen: listen$8,
  mount_component: mount_component$i,
  safe_not_equal: safe_not_equal$1k,
  set_data: set_data$b,
  set_style: set_style$8,
  space: space$d,
  text: text$g,
  toggle_class: toggle_class$c,
  transition_in: transition_in$l,
  transition_out: transition_out$l
} = window.__gradio__svelte__internal;
function create_if_block$9(c) {
  let a, h;
  return {
    c() {
      a = element$g("span"), h = text$g(
        /*label*/
        c[1]
      ), this.h();
    },
    l(d) {
      a = claim_element$g(d, "SPAN", {
        class: !0
      });
      var u = children$1e(a);
      h = claim_text$f(
        u,
        /*label*/
        c[1]
      ), u.forEach(detach$1g), this.h();
    },
    h() {
      attr$1e(a, "class", "svelte-1lrphxw");
    },
    m(d, u) {
      insert_hydration$1g(d, a, u), append_hydration$1b(a, h);
    },
    p(d, u) {
      u & /*label*/
      2 && set_data$b(
        h,
        /*label*/
        d[1]
      );
    },
    d(d) {
      d && detach$1g(a);
    }
  };
}
function create_fragment$h(c) {
  let a, h, d, u, _, g, $, b = (
    /*show_label*/
    c[2] && create_if_block$9(c)
  );
  return u = new /*Icon*/
  c[0]({}), {
    c() {
      a = element$g("button"), b && b.c(), h = space$d(), d = element$g("div"), create_component$i(u.$$.fragment), this.h();
    },
    l(y) {
      a = claim_element$g(y, "BUTTON", {
        "aria-label": !0,
        "aria-haspopup": !0,
        title: !0,
        class: !0
      });
      var v = children$1e(a);
      b && b.l(v), h = claim_space$d(v), d = claim_element$g(v, "DIV", {
        class: !0
      });
      var E = children$1e(d);
      claim_component$i(u.$$.fragment, E), E.forEach(detach$1g), v.forEach(detach$1g), this.h();
    },
    h() {
      attr$1e(d, "class", "svelte-1lrphxw"), toggle_class$c(
        d,
        "small",
        /*size*/
        c[4] === "small"
      ), toggle_class$c(
        d,
        "large",
        /*size*/
        c[4] === "large"
      ), toggle_class$c(
        d,
        "medium",
        /*size*/
        c[4] === "medium"
      ), a.disabled = /*disabled*/
      c[7], attr$1e(
        a,
        "aria-label",
        /*label*/
        c[1]
      ), attr$1e(
        a,
        "aria-haspopup",
        /*hasPopup*/
        c[8]
      ), attr$1e(
        a,
        "title",
        /*label*/
        c[1]
      ), attr$1e(a, "class", "svelte-1lrphxw"), toggle_class$c(
        a,
        "pending",
        /*pending*/
        c[3]
      ), toggle_class$c(
        a,
        "padded",
        /*padded*/
        c[5]
      ), toggle_class$c(
        a,
        "highlight",
        /*highlight*/
        c[6]
      ), toggle_class$c(
        a,
        "transparent",
        /*transparent*/
        c[9]
      ), set_style$8(a, "color", !/*disabled*/
      c[7] && /*_color*/
      c[12] ? (
        /*_color*/
        c[12]
      ) : "var(--block-label-text-color)"), set_style$8(a, "--bg-color", /*disabled*/
      c[7] ? "auto" : (
        /*background*/
        c[10]
      )), set_style$8(
        a,
        "margin-left",
        /*offset*/
        c[11] + "px"
      );
    },
    m(y, v) {
      insert_hydration$1g(y, a, v), b && b.m(a, null), append_hydration$1b(a, h), append_hydration$1b(a, d), mount_component$i(u, d, null), _ = !0, g || ($ = listen$8(
        a,
        "click",
        /*click_handler*/
        c[14]
      ), g = !0);
    },
    p(y, [v]) {
      /*show_label*/
      y[2] ? b ? b.p(y, v) : (b = create_if_block$9(y), b.c(), b.m(a, h)) : b && (b.d(1), b = null), (!_ || v & /*size*/
      16) && toggle_class$c(
        d,
        "small",
        /*size*/
        y[4] === "small"
      ), (!_ || v & /*size*/
      16) && toggle_class$c(
        d,
        "large",
        /*size*/
        y[4] === "large"
      ), (!_ || v & /*size*/
      16) && toggle_class$c(
        d,
        "medium",
        /*size*/
        y[4] === "medium"
      ), (!_ || v & /*disabled*/
      128) && (a.disabled = /*disabled*/
      y[7]), (!_ || v & /*label*/
      2) && attr$1e(
        a,
        "aria-label",
        /*label*/
        y[1]
      ), (!_ || v & /*hasPopup*/
      256) && attr$1e(
        a,
        "aria-haspopup",
        /*hasPopup*/
        y[8]
      ), (!_ || v & /*label*/
      2) && attr$1e(
        a,
        "title",
        /*label*/
        y[1]
      ), (!_ || v & /*pending*/
      8) && toggle_class$c(
        a,
        "pending",
        /*pending*/
        y[3]
      ), (!_ || v & /*padded*/
      32) && toggle_class$c(
        a,
        "padded",
        /*padded*/
        y[5]
      ), (!_ || v & /*highlight*/
      64) && toggle_class$c(
        a,
        "highlight",
        /*highlight*/
        y[6]
      ), (!_ || v & /*transparent*/
      512) && toggle_class$c(
        a,
        "transparent",
        /*transparent*/
        y[9]
      ), v & /*disabled, _color*/
      4224 && set_style$8(a, "color", !/*disabled*/
      y[7] && /*_color*/
      y[12] ? (
        /*_color*/
        y[12]
      ) : "var(--block-label-text-color)"), v & /*disabled, background*/
      1152 && set_style$8(a, "--bg-color", /*disabled*/
      y[7] ? "auto" : (
        /*background*/
        y[10]
      )), v & /*offset*/
      2048 && set_style$8(
        a,
        "margin-left",
        /*offset*/
        y[11] + "px"
      );
    },
    i(y) {
      _ || (transition_in$l(u.$$.fragment, y), _ = !0);
    },
    o(y) {
      transition_out$l(u.$$.fragment, y), _ = !1;
    },
    d(y) {
      y && detach$1g(a), b && b.d(), destroy_component$i(u), g = !1, $();
    }
  };
}
function instance$d(c, a, h) {
  let d, {
    Icon: u
  } = a, {
    label: _ = ""
  } = a, {
    show_label: g = !1
  } = a, {
    pending: $ = !1
  } = a, {
    size: b = "small"
  } = a, {
    padded: y = !0
  } = a, {
    highlight: v = !1
  } = a, {
    disabled: E = !1
  } = a, {
    hasPopup: S = !1
  } = a, {
    color: R = "var(--block-label-text-color)"
  } = a, {
    transparent: x = !1
  } = a, {
    background: H = "var(--background-fill-primary)"
  } = a, {
    offset: T = 0
  } = a;
  function C(O) {
    bubble$4.call(this, c, O);
  }
  return c.$$set = (O) => {
    "Icon" in O && h(0, u = O.Icon), "label" in O && h(1, _ = O.label), "show_label" in O && h(2, g = O.show_label), "pending" in O && h(3, $ = O.pending), "size" in O && h(4, b = O.size), "padded" in O && h(5, y = O.padded), "highlight" in O && h(6, v = O.highlight), "disabled" in O && h(7, E = O.disabled), "hasPopup" in O && h(8, S = O.hasPopup), "color" in O && h(13, R = O.color), "transparent" in O && h(9, x = O.transparent), "background" in O && h(10, H = O.background), "offset" in O && h(11, T = O.offset);
  }, c.$$.update = () => {
    c.$$.dirty & /*highlight, color*/
    8256 && h(12, d = v ? "var(--color-accent)" : R);
  }, [u, _, g, $, b, y, v, E, S, x, H, T, d, R, C];
}
class IconButton extends SvelteComponent$1k {
  constructor(a) {
    super(), init$1k(this, a, instance$d, create_fragment$h, safe_not_equal$1k, {
      Icon: 0,
      label: 1,
      show_label: 2,
      pending: 3,
      size: 4,
      padded: 5,
      highlight: 6,
      disabled: 7,
      hasPopup: 8,
      color: 13,
      transparent: 9,
      background: 10,
      offset: 11
    });
  }
}
const {
  SvelteComponent: SvelteComponent$1j,
  append_hydration: append_hydration$1a,
  attr: attr$1d,
  binding_callbacks: binding_callbacks$8,
  children: children$1d,
  claim_element: claim_element$f,
  create_slot: create_slot$3,
  detach: detach$1f,
  element: element$f,
  get_all_dirty_from_scope: get_all_dirty_from_scope$3,
  get_slot_changes: get_slot_changes$3,
  init: init$1j,
  insert_hydration: insert_hydration$1f,
  safe_not_equal: safe_not_equal$1j,
  toggle_class: toggle_class$b,
  transition_in: transition_in$k,
  transition_out: transition_out$k,
  update_slot_base: update_slot_base$3
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1i,
  append_hydration: append_hydration$19,
  attr: attr$1c,
  children: children$1c,
  claim_svg_element: claim_svg_element$Z,
  detach: detach$1e,
  init: init$1i,
  insert_hydration: insert_hydration$1e,
  noop: noop$14,
  safe_not_equal: safe_not_equal$1i,
  svg_element: svg_element$Z
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1h,
  append_hydration: append_hydration$18,
  attr: attr$1b,
  children: children$1b,
  claim_svg_element: claim_svg_element$Y,
  detach: detach$1d,
  init: init$1h,
  insert_hydration: insert_hydration$1d,
  noop: noop$13,
  safe_not_equal: safe_not_equal$1h,
  svg_element: svg_element$Y
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1g,
  append_hydration: append_hydration$17,
  attr: attr$1a,
  children: children$1a,
  claim_svg_element: claim_svg_element$X,
  detach: detach$1c,
  init: init$1g,
  insert_hydration: insert_hydration$1c,
  noop: noop$12,
  safe_not_equal: safe_not_equal$1g,
  svg_element: svg_element$X
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1f,
  append_hydration: append_hydration$16,
  attr: attr$19,
  children: children$19,
  claim_svg_element: claim_svg_element$W,
  detach: detach$1b,
  init: init$1f,
  insert_hydration: insert_hydration$1b,
  noop: noop$11,
  safe_not_equal: safe_not_equal$1f,
  svg_element: svg_element$W
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1e,
  append_hydration: append_hydration$15,
  attr: attr$18,
  children: children$18,
  claim_svg_element: claim_svg_element$V,
  detach: detach$1a,
  init: init$1e,
  insert_hydration: insert_hydration$1a,
  noop: noop$10,
  safe_not_equal: safe_not_equal$1e,
  svg_element: svg_element$V
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1d,
  append_hydration: append_hydration$14,
  attr: attr$17,
  children: children$17,
  claim_svg_element: claim_svg_element$U,
  detach: detach$19,
  init: init$1d,
  insert_hydration: insert_hydration$19,
  noop: noop$$,
  safe_not_equal: safe_not_equal$1d,
  svg_element: svg_element$U
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1c,
  append_hydration: append_hydration$13,
  attr: attr$16,
  children: children$16,
  claim_svg_element: claim_svg_element$T,
  detach: detach$18,
  init: init$1c,
  insert_hydration: insert_hydration$18,
  noop: noop$_,
  safe_not_equal: safe_not_equal$1c,
  svg_element: svg_element$T
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1b,
  append_hydration: append_hydration$12,
  attr: attr$15,
  children: children$15,
  claim_svg_element: claim_svg_element$S,
  detach: detach$17,
  init: init$1b,
  insert_hydration: insert_hydration$17,
  noop: noop$Z,
  safe_not_equal: safe_not_equal$1b,
  svg_element: svg_element$S
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$1a,
  append_hydration: append_hydration$11,
  attr: attr$14,
  children: children$14,
  claim_svg_element: claim_svg_element$R,
  detach: detach$16,
  init: init$1a,
  insert_hydration: insert_hydration$16,
  noop: noop$Y,
  safe_not_equal: safe_not_equal$1a,
  svg_element: svg_element$R
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$19,
  append_hydration: append_hydration$10,
  attr: attr$13,
  children: children$13,
  claim_svg_element: claim_svg_element$Q,
  detach: detach$15,
  init: init$19,
  insert_hydration: insert_hydration$15,
  noop: noop$X,
  safe_not_equal: safe_not_equal$19,
  svg_element: svg_element$Q
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$18,
  append_hydration: append_hydration$$,
  attr: attr$12,
  children: children$12,
  claim_svg_element: claim_svg_element$P,
  detach: detach$14,
  init: init$18,
  insert_hydration: insert_hydration$14,
  noop: noop$W,
  safe_not_equal: safe_not_equal$18,
  set_style: set_style$7,
  svg_element: svg_element$P
} = window.__gradio__svelte__internal;
function create_fragment$g(c) {
  let a, h, d, u;
  return {
    c() {
      a = svg_element$P("svg"), h = svg_element$P("g"), d = svg_element$P("path"), u = svg_element$P("path"), this.h();
    },
    l(_) {
      a = claim_svg_element$P(_, "svg", {
        width: !0,
        height: !0,
        viewBox: !0,
        version: !0,
        xmlns: !0,
        "xmlns:xlink": !0,
        "xml:space": !0,
        stroke: !0,
        style: !0
      });
      var g = children$12(a);
      h = claim_svg_element$P(g, "g", {
        transform: !0
      });
      var $ = children$12(h);
      d = claim_svg_element$P($, "path", {
        d: !0,
        style: !0
      }), children$12(d).forEach(detach$14), $.forEach(detach$14), u = claim_svg_element$P(g, "path", {
        d: !0,
        style: !0
      }), children$12(u).forEach(detach$14), g.forEach(detach$14), this.h();
    },
    h() {
      attr$12(d, "d", "M18,6L6.087,17.913"), set_style$7(d, "fill", "none"), set_style$7(d, "fill-rule", "nonzero"), set_style$7(d, "stroke-width", "2px"), attr$12(h, "transform", "matrix(1.14096,-0.140958,-0.140958,1.14096,-0.0559523,0.0559523)"), attr$12(u, "d", "M4.364,4.364L19.636,19.636"), set_style$7(u, "fill", "none"), set_style$7(u, "fill-rule", "nonzero"), set_style$7(u, "stroke-width", "2px"), attr$12(a, "width", "100%"), attr$12(a, "height", "100%"), attr$12(a, "viewBox", "0 0 24 24"), attr$12(a, "version", "1.1"), attr$12(a, "xmlns", "http://www.w3.org/2000/svg"), attr$12(a, "xmlns:xlink", "http://www.w3.org/1999/xlink"), attr$12(a, "xml:space", "preserve"), attr$12(a, "stroke", "currentColor"), set_style$7(a, "fill-rule", "evenodd"), set_style$7(a, "clip-rule", "evenodd"), set_style$7(a, "stroke-linecap", "round"), set_style$7(a, "stroke-linejoin", "round");
    },
    m(_, g) {
      insert_hydration$14(_, a, g), append_hydration$$(a, h), append_hydration$$(h, d), append_hydration$$(a, u);
    },
    p: noop$W,
    i: noop$W,
    o: noop$W,
    d(_) {
      _ && detach$14(a);
    }
  };
}
class Clear extends SvelteComponent$18 {
  constructor(a) {
    super(), init$18(this, a, null, create_fragment$g, safe_not_equal$18, {});
  }
}
const {
  SvelteComponent: SvelteComponent$17,
  append_hydration: append_hydration$_,
  attr: attr$11,
  children: children$11,
  claim_svg_element: claim_svg_element$O,
  detach: detach$13,
  init: init$17,
  insert_hydration: insert_hydration$13,
  noop: noop$V,
  safe_not_equal: safe_not_equal$17,
  svg_element: svg_element$O
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$16,
  append_hydration: append_hydration$Z,
  attr: attr$10,
  children: children$10,
  claim_svg_element: claim_svg_element$N,
  detach: detach$12,
  init: init$16,
  insert_hydration: insert_hydration$12,
  noop: noop$U,
  safe_not_equal: safe_not_equal$16,
  svg_element: svg_element$N
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$15,
  append_hydration: append_hydration$Y,
  attr: attr$$,
  children: children$$,
  claim_svg_element: claim_svg_element$M,
  detach: detach$11,
  init: init$15,
  insert_hydration: insert_hydration$11,
  noop: noop$T,
  safe_not_equal: safe_not_equal$15,
  svg_element: svg_element$M
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$14,
  append_hydration: append_hydration$X,
  attr: attr$_,
  children: children$_,
  claim_svg_element: claim_svg_element$L,
  detach: detach$10,
  init: init$14,
  insert_hydration: insert_hydration$10,
  noop: noop$S,
  safe_not_equal: safe_not_equal$14,
  svg_element: svg_element$L
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$13,
  append_hydration: append_hydration$W,
  attr: attr$Z,
  children: children$Z,
  claim_svg_element: claim_svg_element$K,
  detach: detach$$,
  init: init$13,
  insert_hydration: insert_hydration$$,
  noop: noop$R,
  safe_not_equal: safe_not_equal$13,
  svg_element: svg_element$K
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$12,
  append_hydration: append_hydration$V,
  attr: attr$Y,
  children: children$Y,
  claim_svg_element: claim_svg_element$J,
  detach: detach$_,
  init: init$12,
  insert_hydration: insert_hydration$_,
  noop: noop$Q,
  safe_not_equal: safe_not_equal$12,
  svg_element: svg_element$J
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$11,
  append_hydration: append_hydration$U,
  attr: attr$X,
  children: children$X,
  claim_svg_element: claim_svg_element$I,
  detach: detach$Z,
  init: init$11,
  insert_hydration: insert_hydration$Z,
  noop: noop$P,
  safe_not_equal: safe_not_equal$11,
  svg_element: svg_element$I
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$10,
  append_hydration: append_hydration$T,
  attr: attr$W,
  children: children$W,
  claim_svg_element: claim_svg_element$H,
  detach: detach$Y,
  init: init$10,
  insert_hydration: insert_hydration$Y,
  noop: noop$O,
  safe_not_equal: safe_not_equal$10,
  svg_element: svg_element$H
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$$,
  append_hydration: append_hydration$S,
  attr: attr$V,
  children: children$V,
  claim_svg_element: claim_svg_element$G,
  detach: detach$X,
  init: init$$,
  insert_hydration: insert_hydration$X,
  noop: noop$N,
  safe_not_equal: safe_not_equal$$,
  svg_element: svg_element$G
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$_,
  append_hydration: append_hydration$R,
  attr: attr$U,
  children: children$U,
  claim_svg_element: claim_svg_element$F,
  detach: detach$W,
  init: init$_,
  insert_hydration: insert_hydration$W,
  noop: noop$M,
  safe_not_equal: safe_not_equal$_,
  svg_element: svg_element$F
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$Z,
  append_hydration: append_hydration$Q,
  attr: attr$T,
  children: children$T,
  claim_svg_element: claim_svg_element$E,
  detach: detach$V,
  init: init$Z,
  insert_hydration: insert_hydration$V,
  noop: noop$L,
  safe_not_equal: safe_not_equal$Z,
  svg_element: svg_element$E
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$Y,
  append_hydration: append_hydration$P,
  attr: attr$S,
  children: children$S,
  claim_svg_element: claim_svg_element$D,
  detach: detach$U,
  init: init$Y,
  insert_hydration: insert_hydration$U,
  noop: noop$K,
  safe_not_equal: safe_not_equal$Y,
  svg_element: svg_element$D
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$X,
  append_hydration: append_hydration$O,
  attr: attr$R,
  children: children$R,
  claim_svg_element: claim_svg_element$C,
  detach: detach$T,
  init: init$X,
  insert_hydration: insert_hydration$T,
  noop: noop$J,
  safe_not_equal: safe_not_equal$X,
  svg_element: svg_element$C
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$W,
  append_hydration: append_hydration$N,
  attr: attr$Q,
  children: children$Q,
  claim_svg_element: claim_svg_element$B,
  detach: detach$S,
  init: init$W,
  insert_hydration: insert_hydration$S,
  noop: noop$I,
  safe_not_equal: safe_not_equal$W,
  svg_element: svg_element$B
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$V,
  append_hydration: append_hydration$M,
  attr: attr$P,
  children: children$P,
  claim_svg_element: claim_svg_element$A,
  detach: detach$R,
  init: init$V,
  insert_hydration: insert_hydration$R,
  noop: noop$H,
  safe_not_equal: safe_not_equal$V,
  svg_element: svg_element$A
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$U,
  append_hydration: append_hydration$L,
  attr: attr$O,
  children: children$O,
  claim_svg_element: claim_svg_element$z,
  detach: detach$Q,
  init: init$U,
  insert_hydration: insert_hydration$Q,
  noop: noop$G,
  safe_not_equal: safe_not_equal$U,
  svg_element: svg_element$z
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$T,
  append_hydration: append_hydration$K,
  attr: attr$N,
  children: children$N,
  claim_svg_element: claim_svg_element$y,
  detach: detach$P,
  init: init$T,
  insert_hydration: insert_hydration$P,
  noop: noop$F,
  safe_not_equal: safe_not_equal$T,
  svg_element: svg_element$y
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$S,
  append_hydration: append_hydration$J,
  attr: attr$M,
  children: children$M,
  claim_svg_element: claim_svg_element$x,
  detach: detach$O,
  init: init$S,
  insert_hydration: insert_hydration$O,
  noop: noop$E,
  safe_not_equal: safe_not_equal$S,
  svg_element: svg_element$x
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$R,
  append_hydration: append_hydration$I,
  attr: attr$L,
  children: children$L,
  claim_svg_element: claim_svg_element$w,
  detach: detach$N,
  init: init$R,
  insert_hydration: insert_hydration$N,
  noop: noop$D,
  safe_not_equal: safe_not_equal$R,
  svg_element: svg_element$w
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$Q,
  append_hydration: append_hydration$H,
  attr: attr$K,
  children: children$K,
  claim_svg_element: claim_svg_element$v,
  detach: detach$M,
  init: init$Q,
  insert_hydration: insert_hydration$M,
  noop: noop$C,
  safe_not_equal: safe_not_equal$Q,
  svg_element: svg_element$v
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$P,
  append_hydration: append_hydration$G,
  attr: attr$J,
  children: children$J,
  claim_svg_element: claim_svg_element$u,
  detach: detach$L,
  init: init$P,
  insert_hydration: insert_hydration$L,
  noop: noop$B,
  safe_not_equal: safe_not_equal$P,
  svg_element: svg_element$u
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$O,
  append_hydration: append_hydration$F,
  attr: attr$I,
  children: children$I,
  claim_svg_element: claim_svg_element$t,
  detach: detach$K,
  init: init$O,
  insert_hydration: insert_hydration$K,
  noop: noop$A,
  safe_not_equal: safe_not_equal$O,
  svg_element: svg_element$t
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$N,
  append_hydration: append_hydration$E,
  attr: attr$H,
  children: children$H,
  claim_svg_element: claim_svg_element$s,
  detach: detach$J,
  init: init$N,
  insert_hydration: insert_hydration$J,
  noop: noop$z,
  safe_not_equal: safe_not_equal$N,
  svg_element: svg_element$s
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$M,
  append_hydration: append_hydration$D,
  attr: attr$G,
  children: children$G,
  claim_svg_element: claim_svg_element$r,
  detach: detach$I,
  init: init$M,
  insert_hydration: insert_hydration$I,
  noop: noop$y,
  safe_not_equal: safe_not_equal$M,
  svg_element: svg_element$r
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$L,
  append_hydration: append_hydration$C,
  attr: attr$F,
  children: children$F,
  claim_svg_element: claim_svg_element$q,
  detach: detach$H,
  init: init$L,
  insert_hydration: insert_hydration$H,
  noop: noop$x,
  safe_not_equal: safe_not_equal$L,
  svg_element: svg_element$q
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$K,
  append_hydration: append_hydration$B,
  attr: attr$E,
  children: children$E,
  claim_svg_element: claim_svg_element$p,
  detach: detach$G,
  init: init$K,
  insert_hydration: insert_hydration$G,
  noop: noop$w,
  safe_not_equal: safe_not_equal$K,
  svg_element: svg_element$p
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$J,
  append_hydration: append_hydration$A,
  attr: attr$D,
  children: children$D,
  claim_svg_element: claim_svg_element$o,
  detach: detach$F,
  init: init$J,
  insert_hydration: insert_hydration$F,
  noop: noop$v,
  safe_not_equal: safe_not_equal$J,
  svg_element: svg_element$o
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$I,
  append_hydration: append_hydration$z,
  attr: attr$C,
  children: children$C,
  claim_svg_element: claim_svg_element$n,
  detach: detach$E,
  init: init$I,
  insert_hydration: insert_hydration$E,
  noop: noop$u,
  safe_not_equal: safe_not_equal$I,
  svg_element: svg_element$n
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$H,
  append_hydration: append_hydration$y,
  attr: attr$B,
  children: children$B,
  claim_svg_element: claim_svg_element$m,
  detach: detach$D,
  init: init$H,
  insert_hydration: insert_hydration$D,
  noop: noop$t,
  safe_not_equal: safe_not_equal$H,
  svg_element: svg_element$m
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$G,
  append_hydration: append_hydration$x,
  attr: attr$A,
  children: children$A,
  claim_svg_element: claim_svg_element$l,
  detach: detach$C,
  init: init$G,
  insert_hydration: insert_hydration$C,
  noop: noop$s,
  safe_not_equal: safe_not_equal$G,
  set_style: set_style$6,
  svg_element: svg_element$l
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$F,
  append_hydration: append_hydration$w,
  attr: attr$z,
  children: children$z,
  claim_svg_element: claim_svg_element$k,
  detach: detach$B,
  init: init$F,
  insert_hydration: insert_hydration$B,
  noop: noop$r,
  safe_not_equal: safe_not_equal$F,
  svg_element: svg_element$k
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$E,
  append_hydration: append_hydration$v,
  attr: attr$y,
  children: children$y,
  claim_svg_element: claim_svg_element$j,
  detach: detach$A,
  init: init$E,
  insert_hydration: insert_hydration$A,
  noop: noop$q,
  safe_not_equal: safe_not_equal$E,
  svg_element: svg_element$j
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$D,
  append_hydration: append_hydration$u,
  attr: attr$x,
  children: children$x,
  claim_svg_element: claim_svg_element$i,
  detach: detach$z,
  init: init$D,
  insert_hydration: insert_hydration$z,
  noop: noop$p,
  safe_not_equal: safe_not_equal$D,
  svg_element: svg_element$i
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$C,
  append_hydration: append_hydration$t,
  attr: attr$w,
  children: children$w,
  claim_svg_element: claim_svg_element$h,
  detach: detach$y,
  init: init$C,
  insert_hydration: insert_hydration$y,
  noop: noop$o,
  safe_not_equal: safe_not_equal$C,
  svg_element: svg_element$h
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$B,
  append_hydration: append_hydration$s,
  attr: attr$v,
  children: children$v,
  claim_svg_element: claim_svg_element$g,
  detach: detach$x,
  init: init$B,
  insert_hydration: insert_hydration$x,
  noop: noop$n,
  safe_not_equal: safe_not_equal$B,
  svg_element: svg_element$g
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$A,
  append_hydration: append_hydration$r,
  attr: attr$u,
  children: children$u,
  claim_svg_element: claim_svg_element$f,
  detach: detach$w,
  init: init$A,
  insert_hydration: insert_hydration$w,
  noop: noop$m,
  safe_not_equal: safe_not_equal$A,
  svg_element: svg_element$f
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$z,
  append_hydration: append_hydration$q,
  attr: attr$t,
  children: children$t,
  claim_svg_element: claim_svg_element$e,
  detach: detach$v,
  init: init$z,
  insert_hydration: insert_hydration$v,
  noop: noop$l,
  safe_not_equal: safe_not_equal$z,
  svg_element: svg_element$e
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$y,
  append_hydration: append_hydration$p,
  attr: attr$s,
  children: children$s,
  claim_svg_element: claim_svg_element$d,
  detach: detach$u,
  init: init$y,
  insert_hydration: insert_hydration$u,
  noop: noop$k,
  safe_not_equal: safe_not_equal$y,
  svg_element: svg_element$d
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$x,
  append_hydration: append_hydration$o,
  attr: attr$r,
  children: children$r,
  claim_svg_element: claim_svg_element$c,
  claim_text: claim_text$e,
  detach: detach$t,
  init: init$x,
  insert_hydration: insert_hydration$t,
  noop: noop$j,
  safe_not_equal: safe_not_equal$x,
  svg_element: svg_element$c,
  text: text$f
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$w,
  append_hydration: append_hydration$n,
  attr: attr$q,
  children: children$q,
  claim_svg_element: claim_svg_element$b,
  detach: detach$s,
  init: init$w,
  insert_hydration: insert_hydration$s,
  noop: noop$i,
  safe_not_equal: safe_not_equal$w,
  svg_element: svg_element$b
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$v,
  append_hydration: append_hydration$m,
  attr: attr$p,
  children: children$p,
  claim_svg_element: claim_svg_element$a,
  detach: detach$r,
  init: init$v,
  insert_hydration: insert_hydration$r,
  noop: noop$h,
  safe_not_equal: safe_not_equal$v,
  svg_element: svg_element$a
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$u,
  append_hydration: append_hydration$l,
  attr: attr$o,
  children: children$o,
  claim_svg_element: claim_svg_element$9,
  detach: detach$q,
  init: init$u,
  insert_hydration: insert_hydration$q,
  noop: noop$g,
  safe_not_equal: safe_not_equal$u,
  svg_element: svg_element$9
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$t,
  append_hydration: append_hydration$k,
  attr: attr$n,
  children: children$n,
  claim_svg_element: claim_svg_element$8,
  detach: detach$p,
  init: init$t,
  insert_hydration: insert_hydration$p,
  noop: noop$f,
  safe_not_equal: safe_not_equal$t,
  svg_element: svg_element$8
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$s,
  append_hydration: append_hydration$j,
  attr: attr$m,
  children: children$m,
  claim_svg_element: claim_svg_element$7,
  detach: detach$o,
  init: init$s,
  insert_hydration: insert_hydration$o,
  noop: noop$e,
  safe_not_equal: safe_not_equal$s,
  svg_element: svg_element$7
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$r,
  append_hydration: append_hydration$i,
  attr: attr$l,
  children: children$l,
  claim_svg_element: claim_svg_element$6,
  claim_text: claim_text$d,
  detach: detach$n,
  init: init$r,
  insert_hydration: insert_hydration$n,
  noop: noop$d,
  safe_not_equal: safe_not_equal$r,
  svg_element: svg_element$6,
  text: text$e
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$q,
  append_hydration: append_hydration$h,
  attr: attr$k,
  children: children$k,
  claim_svg_element: claim_svg_element$5,
  claim_text: claim_text$c,
  detach: detach$m,
  init: init$q,
  insert_hydration: insert_hydration$m,
  noop: noop$c,
  safe_not_equal: safe_not_equal$q,
  svg_element: svg_element$5,
  text: text$d
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$p,
  append_hydration: append_hydration$g,
  attr: attr$j,
  children: children$j,
  claim_svg_element: claim_svg_element$4,
  claim_text: claim_text$b,
  detach: detach$l,
  init: init$p,
  insert_hydration: insert_hydration$l,
  noop: noop$b,
  safe_not_equal: safe_not_equal$p,
  svg_element: svg_element$4,
  text: text$c
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$o,
  append_hydration: append_hydration$f,
  attr: attr$i,
  children: children$i,
  claim_svg_element: claim_svg_element$3,
  detach: detach$k,
  init: init$o,
  insert_hydration: insert_hydration$k,
  noop: noop$a,
  safe_not_equal: safe_not_equal$o,
  svg_element: svg_element$3
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$n,
  append_hydration: append_hydration$e,
  attr: attr$h,
  children: children$h,
  claim_svg_element: claim_svg_element$2,
  detach: detach$j,
  init: init$n,
  insert_hydration: insert_hydration$j,
  noop: noop$9,
  safe_not_equal: safe_not_equal$n,
  svg_element: svg_element$2
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$m,
  claim_component: claim_component$h,
  create_component: create_component$h,
  destroy_component: destroy_component$h,
  init: init$m,
  mount_component: mount_component$h,
  safe_not_equal: safe_not_equal$m,
  transition_in: transition_in$j,
  transition_out: transition_out$j
} = window.__gradio__svelte__internal, {
  createEventDispatcher: createEventDispatcher$8
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$l,
  append_hydration: append_hydration$d,
  attr: attr$g,
  check_outros: check_outros$c,
  children: children$g,
  claim_component: claim_component$g,
  claim_element: claim_element$e,
  claim_space: claim_space$c,
  claim_text: claim_text$a,
  create_component: create_component$g,
  destroy_component: destroy_component$g,
  detach: detach$i,
  element: element$e,
  empty: empty$7,
  group_outros: group_outros$c,
  init: init$l,
  insert_hydration: insert_hydration$i,
  mount_component: mount_component$g,
  safe_not_equal: safe_not_equal$l,
  set_data: set_data$a,
  space: space$c,
  text: text$b,
  toggle_class: toggle_class$a,
  transition_in: transition_in$i,
  transition_out: transition_out$i
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$k,
  attr: attr$f,
  children: children$f,
  claim_element: claim_element$d,
  create_slot: create_slot$2,
  detach: detach$h,
  element: element$d,
  get_all_dirty_from_scope: get_all_dirty_from_scope$2,
  get_slot_changes: get_slot_changes$2,
  init: init$k,
  insert_hydration: insert_hydration$h,
  safe_not_equal: safe_not_equal$k,
  toggle_class: toggle_class$9,
  transition_in: transition_in$h,
  transition_out: transition_out$h,
  update_slot_base: update_slot_base$2
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$j,
  append_hydration: append_hydration$c,
  attr: attr$e,
  check_outros: check_outros$b,
  children: children$e,
  claim_component: claim_component$f,
  claim_element: claim_element$c,
  claim_space: claim_space$b,
  create_component: create_component$f,
  destroy_component: destroy_component$f,
  detach: detach$g,
  element: element$c,
  empty: empty$6,
  group_outros: group_outros$b,
  init: init$j,
  insert_hydration: insert_hydration$g,
  listen: listen$7,
  mount_component: mount_component$f,
  safe_not_equal: safe_not_equal$j,
  space: space$b,
  toggle_class: toggle_class$8,
  transition_in: transition_in$g,
  transition_out: transition_out$g
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$i,
  append_hydration: append_hydration$b,
  attr: attr$d,
  binding_callbacks: binding_callbacks$7,
  check_outros: check_outros$a,
  children: children$d,
  claim_component: claim_component$e,
  claim_element: claim_element$b,
  claim_space: claim_space$a,
  claim_text: claim_text$9,
  create_component: create_component$e,
  create_slot: create_slot$1,
  destroy_component: destroy_component$e,
  destroy_each: destroy_each$4,
  detach: detach$f,
  element: element$b,
  empty: empty$5,
  ensure_array_like: ensure_array_like$5,
  get_all_dirty_from_scope: get_all_dirty_from_scope$1,
  get_slot_changes: get_slot_changes$1,
  group_outros: group_outros$a,
  init: init$i,
  insert_hydration: insert_hydration$f,
  mount_component: mount_component$e,
  noop: noop$8,
  safe_not_equal: safe_not_equal$i,
  set_data: set_data$9,
  set_style: set_style$5,
  space: space$a,
  text: text$a,
  toggle_class: toggle_class$7,
  transition_in: transition_in$f,
  transition_out: transition_out$f,
  update_slot_base: update_slot_base$1
} = window.__gradio__svelte__internal, {
  tick: tick$2
} = window.__gradio__svelte__internal, {
  onDestroy: onDestroy$1
} = window.__gradio__svelte__internal, {
  createEventDispatcher: createEventDispatcher$7
} = window.__gradio__svelte__internal, get_error_slot_changes = (c) => ({}), get_error_slot_context = (c) => ({}), get_additional_loading_text_slot_changes = (c) => ({}), get_additional_loading_text_slot_context = (c) => ({});
function get_each_context$4(c, a, h) {
  const d = c.slice();
  return d[40] = a[h], d[42] = h, d;
}
function get_each_context_1(c, a, h) {
  const d = c.slice();
  return d[40] = a[h], d;
}
function create_if_block_17(c) {
  let a, h, d, u, _ = (
    /*i18n*/
    c[1]("common.error") + ""
  ), g, $, b;
  h = new IconButton({
    props: {
      Icon: Clear,
      label: (
        /*i18n*/
        c[1]("common.clear")
      ),
      disabled: !1
    }
  }), h.$on(
    "click",
    /*click_handler*/
    c[32]
  );
  const y = (
    /*#slots*/
    c[30].error
  ), v = create_slot$1(
    y,
    c,
    /*$$scope*/
    c[29],
    get_error_slot_context
  );
  return {
    c() {
      a = element$b("div"), create_component$e(h.$$.fragment), d = space$a(), u = element$b("span"), g = text$a(_), $ = space$a(), v && v.c(), this.h();
    },
    l(E) {
      a = claim_element$b(E, "DIV", {
        class: !0
      });
      var S = children$d(a);
      claim_component$e(h.$$.fragment, S), S.forEach(detach$f), d = claim_space$a(E), u = claim_element$b(E, "SPAN", {
        class: !0
      });
      var R = children$d(u);
      g = claim_text$9(R, _), R.forEach(detach$f), $ = claim_space$a(E), v && v.l(E), this.h();
    },
    h() {
      attr$d(a, "class", "clear-status svelte-v0wucf"), attr$d(u, "class", "error svelte-v0wucf");
    },
    m(E, S) {
      insert_hydration$f(E, a, S), mount_component$e(h, a, null), insert_hydration$f(E, d, S), insert_hydration$f(E, u, S), append_hydration$b(u, g), insert_hydration$f(E, $, S), v && v.m(E, S), b = !0;
    },
    p(E, S) {
      const R = {};
      S[0] & /*i18n*/
      2 && (R.label = /*i18n*/
      E[1]("common.clear")), h.$set(R), (!b || S[0] & /*i18n*/
      2) && _ !== (_ = /*i18n*/
      E[1]("common.error") + "") && set_data$9(g, _), v && v.p && (!b || S[0] & /*$$scope*/
      536870912) && update_slot_base$1(
        v,
        y,
        E,
        /*$$scope*/
        E[29],
        b ? get_slot_changes$1(
          y,
          /*$$scope*/
          E[29],
          S,
          get_error_slot_changes
        ) : get_all_dirty_from_scope$1(
          /*$$scope*/
          E[29]
        ),
        get_error_slot_context
      );
    },
    i(E) {
      b || (transition_in$f(h.$$.fragment, E), transition_in$f(v, E), b = !0);
    },
    o(E) {
      transition_out$f(h.$$.fragment, E), transition_out$f(v, E), b = !1;
    },
    d(E) {
      E && (detach$f(a), detach$f(d), detach$f(u), detach$f($)), destroy_component$e(h), v && v.d(E);
    }
  };
}
function create_if_block$8(c) {
  let a, h, d, u, _, g, $, b, y, v = (
    /*variant*/
    c[8] === "default" && /*show_eta_bar*/
    c[18] && /*show_progress*/
    c[6] === "full" && create_if_block_16(c)
  );
  function E(j, B) {
    if (
      /*progress*/
      j[7]
    ) return create_if_block_11;
    if (
      /*queue_position*/
      j[2] !== null && /*queue_size*/
      j[3] !== void 0 && /*queue_position*/
      j[2] >= 0
    ) return create_if_block_14;
    if (
      /*queue_position*/
      j[2] === 0
    ) return create_if_block_15;
  }
  let S = E(c), R = S && S(c), x = (
    /*timer*/
    c[5] && create_if_block_10(c)
  );
  const H = [create_if_block_2$5, create_if_block_9], T = [];
  function C(j, B) {
    return (
      /*last_progress_level*/
      j[15] != null ? 0 : (
        /*show_progress*/
        j[6] === "full" ? 1 : -1
      )
    );
  }
  ~(_ = C(c)) && (g = T[_] = H[_](c));
  let O = !/*timer*/
  c[5] && create_if_block_1$6(c);
  return {
    c() {
      v && v.c(), a = space$a(), h = element$b("div"), R && R.c(), d = space$a(), x && x.c(), u = space$a(), g && g.c(), $ = space$a(), O && O.c(), b = empty$5(), this.h();
    },
    l(j) {
      v && v.l(j), a = claim_space$a(j), h = claim_element$b(j, "DIV", {
        class: !0
      });
      var B = children$d(h);
      R && R.l(B), d = claim_space$a(B), x && x.l(B), B.forEach(detach$f), u = claim_space$a(j), g && g.l(j), $ = claim_space$a(j), O && O.l(j), b = empty$5(), this.h();
    },
    h() {
      attr$d(h, "class", "progress-text svelte-v0wucf"), toggle_class$7(
        h,
        "meta-text-center",
        /*variant*/
        c[8] === "center"
      ), toggle_class$7(
        h,
        "meta-text",
        /*variant*/
        c[8] === "default"
      );
    },
    m(j, B) {
      v && v.m(j, B), insert_hydration$f(j, a, B), insert_hydration$f(j, h, B), R && R.m(h, null), append_hydration$b(h, d), x && x.m(h, null), insert_hydration$f(j, u, B), ~_ && T[_].m(j, B), insert_hydration$f(j, $, B), O && O.m(j, B), insert_hydration$f(j, b, B), y = !0;
    },
    p(j, B) {
      /*variant*/
      j[8] === "default" && /*show_eta_bar*/
      j[18] && /*show_progress*/
      j[6] === "full" ? v ? v.p(j, B) : (v = create_if_block_16(j), v.c(), v.m(a.parentNode, a)) : v && (v.d(1), v = null), S === (S = E(j)) && R ? R.p(j, B) : (R && R.d(1), R = S && S(j), R && (R.c(), R.m(h, d))), /*timer*/
      j[5] ? x ? x.p(j, B) : (x = create_if_block_10(j), x.c(), x.m(h, null)) : x && (x.d(1), x = null), (!y || B[0] & /*variant*/
      256) && toggle_class$7(
        h,
        "meta-text-center",
        /*variant*/
        j[8] === "center"
      ), (!y || B[0] & /*variant*/
      256) && toggle_class$7(
        h,
        "meta-text",
        /*variant*/
        j[8] === "default"
      );
      let D = _;
      _ = C(j), _ === D ? ~_ && T[_].p(j, B) : (g && (group_outros$a(), transition_out$f(T[D], 1, 1, () => {
        T[D] = null;
      }), check_outros$a()), ~_ ? (g = T[_], g ? g.p(j, B) : (g = T[_] = H[_](j), g.c()), transition_in$f(g, 1), g.m($.parentNode, $)) : g = null), /*timer*/
      j[5] ? O && (group_outros$a(), transition_out$f(O, 1, 1, () => {
        O = null;
      }), check_outros$a()) : O ? (O.p(j, B), B[0] & /*timer*/
      32 && transition_in$f(O, 1)) : (O = create_if_block_1$6(j), O.c(), transition_in$f(O, 1), O.m(b.parentNode, b));
    },
    i(j) {
      y || (transition_in$f(g), transition_in$f(O), y = !0);
    },
    o(j) {
      transition_out$f(g), transition_out$f(O), y = !1;
    },
    d(j) {
      j && (detach$f(a), detach$f(h), detach$f(u), detach$f($), detach$f(b)), v && v.d(j), R && R.d(), x && x.d(), ~_ && T[_].d(j), O && O.d(j);
    }
  };
}
function create_if_block_16(c) {
  let a, h = `translateX(${/*eta_level*/
  (c[17] || 0) * 100 - 100}%)`;
  return {
    c() {
      a = element$b("div"), this.h();
    },
    l(d) {
      a = claim_element$b(d, "DIV", {
        class: !0
      }), children$d(a).forEach(detach$f), this.h();
    },
    h() {
      attr$d(a, "class", "eta-bar svelte-v0wucf"), set_style$5(a, "transform", h);
    },
    m(d, u) {
      insert_hydration$f(d, a, u);
    },
    p(d, u) {
      u[0] & /*eta_level*/
      131072 && h !== (h = `translateX(${/*eta_level*/
      (d[17] || 0) * 100 - 100}%)`) && set_style$5(a, "transform", h);
    },
    d(d) {
      d && detach$f(a);
    }
  };
}
function create_if_block_15(c) {
  let a;
  return {
    c() {
      a = text$a("processing |");
    },
    l(h) {
      a = claim_text$9(h, "processing |");
    },
    m(h, d) {
      insert_hydration$f(h, a, d);
    },
    p: noop$8,
    d(h) {
      h && detach$f(a);
    }
  };
}
function create_if_block_14(c) {
  let a, h = (
    /*queue_position*/
    c[2] + 1 + ""
  ), d, u, _, g;
  return {
    c() {
      a = text$a("queue: "), d = text$a(h), u = text$a("/"), _ = text$a(
        /*queue_size*/
        c[3]
      ), g = text$a(" |");
    },
    l($) {
      a = claim_text$9($, "queue: "), d = claim_text$9($, h), u = claim_text$9($, "/"), _ = claim_text$9(
        $,
        /*queue_size*/
        c[3]
      ), g = claim_text$9($, " |");
    },
    m($, b) {
      insert_hydration$f($, a, b), insert_hydration$f($, d, b), insert_hydration$f($, u, b), insert_hydration$f($, _, b), insert_hydration$f($, g, b);
    },
    p($, b) {
      b[0] & /*queue_position*/
      4 && h !== (h = /*queue_position*/
      $[2] + 1 + "") && set_data$9(d, h), b[0] & /*queue_size*/
      8 && set_data$9(
        _,
        /*queue_size*/
        $[3]
      );
    },
    d($) {
      $ && (detach$f(a), detach$f(d), detach$f(u), detach$f(_), detach$f(g));
    }
  };
}
function create_if_block_11(c) {
  let a, h = ensure_array_like$5(
    /*progress*/
    c[7]
  ), d = [];
  for (let u = 0; u < h.length; u += 1)
    d[u] = create_each_block_1(get_each_context_1(c, h, u));
  return {
    c() {
      for (let u = 0; u < d.length; u += 1)
        d[u].c();
      a = empty$5();
    },
    l(u) {
      for (let _ = 0; _ < d.length; _ += 1)
        d[_].l(u);
      a = empty$5();
    },
    m(u, _) {
      for (let g = 0; g < d.length; g += 1)
        d[g] && d[g].m(u, _);
      insert_hydration$f(u, a, _);
    },
    p(u, _) {
      if (_[0] & /*progress*/
      128) {
        h = ensure_array_like$5(
          /*progress*/
          u[7]
        );
        let g;
        for (g = 0; g < h.length; g += 1) {
          const $ = get_each_context_1(u, h, g);
          d[g] ? d[g].p($, _) : (d[g] = create_each_block_1($), d[g].c(), d[g].m(a.parentNode, a));
        }
        for (; g < d.length; g += 1)
          d[g].d(1);
        d.length = h.length;
      }
    },
    d(u) {
      u && detach$f(a), destroy_each$4(d, u);
    }
  };
}
function create_if_block_12(c) {
  let a, h = (
    /*p*/
    c[40].unit + ""
  ), d, u, _ = " ", g;
  function $(v, E) {
    return (
      /*p*/
      v[40].length != null ? create_if_block_13 : create_else_block$5
    );
  }
  let b = $(c), y = b(c);
  return {
    c() {
      y.c(), a = space$a(), d = text$a(h), u = text$a(" | "), g = text$a(_);
    },
    l(v) {
      y.l(v), a = claim_space$a(v), d = claim_text$9(v, h), u = claim_text$9(v, " | "), g = claim_text$9(v, _);
    },
    m(v, E) {
      y.m(v, E), insert_hydration$f(v, a, E), insert_hydration$f(v, d, E), insert_hydration$f(v, u, E), insert_hydration$f(v, g, E);
    },
    p(v, E) {
      b === (b = $(v)) && y ? y.p(v, E) : (y.d(1), y = b(v), y && (y.c(), y.m(a.parentNode, a))), E[0] & /*progress*/
      128 && h !== (h = /*p*/
      v[40].unit + "") && set_data$9(d, h);
    },
    d(v) {
      v && (detach$f(a), detach$f(d), detach$f(u), detach$f(g)), y.d(v);
    }
  };
}
function create_else_block$5(c) {
  let a = pretty_si(
    /*p*/
    c[40].index || 0
  ) + "", h;
  return {
    c() {
      h = text$a(a);
    },
    l(d) {
      h = claim_text$9(d, a);
    },
    m(d, u) {
      insert_hydration$f(d, h, u);
    },
    p(d, u) {
      u[0] & /*progress*/
      128 && a !== (a = pretty_si(
        /*p*/
        d[40].index || 0
      ) + "") && set_data$9(h, a);
    },
    d(d) {
      d && detach$f(h);
    }
  };
}
function create_if_block_13(c) {
  let a = pretty_si(
    /*p*/
    c[40].index || 0
  ) + "", h, d, u = pretty_si(
    /*p*/
    c[40].length
  ) + "", _;
  return {
    c() {
      h = text$a(a), d = text$a("/"), _ = text$a(u);
    },
    l(g) {
      h = claim_text$9(g, a), d = claim_text$9(g, "/"), _ = claim_text$9(g, u);
    },
    m(g, $) {
      insert_hydration$f(g, h, $), insert_hydration$f(g, d, $), insert_hydration$f(g, _, $);
    },
    p(g, $) {
      $[0] & /*progress*/
      128 && a !== (a = pretty_si(
        /*p*/
        g[40].index || 0
      ) + "") && set_data$9(h, a), $[0] & /*progress*/
      128 && u !== (u = pretty_si(
        /*p*/
        g[40].length
      ) + "") && set_data$9(_, u);
    },
    d(g) {
      g && (detach$f(h), detach$f(d), detach$f(_));
    }
  };
}
function create_each_block_1(c) {
  let a, h = (
    /*p*/
    c[40].index != null && create_if_block_12(c)
  );
  return {
    c() {
      h && h.c(), a = empty$5();
    },
    l(d) {
      h && h.l(d), a = empty$5();
    },
    m(d, u) {
      h && h.m(d, u), insert_hydration$f(d, a, u);
    },
    p(d, u) {
      /*p*/
      d[40].index != null ? h ? h.p(d, u) : (h = create_if_block_12(d), h.c(), h.m(a.parentNode, a)) : h && (h.d(1), h = null);
    },
    d(d) {
      d && detach$f(a), h && h.d(d);
    }
  };
}
function create_if_block_10(c) {
  let a, h = (
    /*eta*/
    c[0] ? `/${/*formatted_eta*/
    c[19]}` : ""
  ), d, u;
  return {
    c() {
      a = text$a(
        /*formatted_timer*/
        c[20]
      ), d = text$a(h), u = text$a("s");
    },
    l(_) {
      a = claim_text$9(
        _,
        /*formatted_timer*/
        c[20]
      ), d = claim_text$9(_, h), u = claim_text$9(_, "s");
    },
    m(_, g) {
      insert_hydration$f(_, a, g), insert_hydration$f(_, d, g), insert_hydration$f(_, u, g);
    },
    p(_, g) {
      g[0] & /*formatted_timer*/
      1048576 && set_data$9(
        a,
        /*formatted_timer*/
        _[20]
      ), g[0] & /*eta, formatted_eta*/
      524289 && h !== (h = /*eta*/
      _[0] ? `/${/*formatted_eta*/
      _[19]}` : "") && set_data$9(d, h);
    },
    d(_) {
      _ && (detach$f(a), detach$f(d), detach$f(u));
    }
  };
}
function create_if_block_9(c) {
  let a, h;
  return a = new Loader$1({
    props: {
      margin: (
        /*variant*/
        c[8] === "default"
      )
    }
  }), {
    c() {
      create_component$e(a.$$.fragment);
    },
    l(d) {
      claim_component$e(a.$$.fragment, d);
    },
    m(d, u) {
      mount_component$e(a, d, u), h = !0;
    },
    p(d, u) {
      const _ = {};
      u[0] & /*variant*/
      256 && (_.margin = /*variant*/
      d[8] === "default"), a.$set(_);
    },
    i(d) {
      h || (transition_in$f(a.$$.fragment, d), h = !0);
    },
    o(d) {
      transition_out$f(a.$$.fragment, d), h = !1;
    },
    d(d) {
      destroy_component$e(a, d);
    }
  };
}
function create_if_block_2$5(c) {
  let a, h, d, u, _, g = `${/*last_progress_level*/
  c[15] * 100}%`, $ = (
    /*progress*/
    c[7] != null && create_if_block_3$3(c)
  );
  return {
    c() {
      a = element$b("div"), h = element$b("div"), $ && $.c(), d = space$a(), u = element$b("div"), _ = element$b("div"), this.h();
    },
    l(b) {
      a = claim_element$b(b, "DIV", {
        class: !0
      });
      var y = children$d(a);
      h = claim_element$b(y, "DIV", {
        class: !0
      });
      var v = children$d(h);
      $ && $.l(v), v.forEach(detach$f), d = claim_space$a(y), u = claim_element$b(y, "DIV", {
        class: !0
      });
      var E = children$d(u);
      _ = claim_element$b(E, "DIV", {
        class: !0
      }), children$d(_).forEach(detach$f), E.forEach(detach$f), y.forEach(detach$f), this.h();
    },
    h() {
      attr$d(h, "class", "progress-level-inner svelte-v0wucf"), attr$d(_, "class", "progress-bar svelte-v0wucf"), set_style$5(_, "width", g), attr$d(u, "class", "progress-bar-wrap svelte-v0wucf"), attr$d(a, "class", "progress-level svelte-v0wucf");
    },
    m(b, y) {
      insert_hydration$f(b, a, y), append_hydration$b(a, h), $ && $.m(h, null), append_hydration$b(a, d), append_hydration$b(a, u), append_hydration$b(u, _), c[31](_);
    },
    p(b, y) {
      /*progress*/
      b[7] != null ? $ ? $.p(b, y) : ($ = create_if_block_3$3(b), $.c(), $.m(h, null)) : $ && ($.d(1), $ = null), y[0] & /*last_progress_level*/
      32768 && g !== (g = `${/*last_progress_level*/
      b[15] * 100}%`) && set_style$5(_, "width", g);
    },
    i: noop$8,
    o: noop$8,
    d(b) {
      b && detach$f(a), $ && $.d(), c[31](null);
    }
  };
}
function create_if_block_3$3(c) {
  let a, h = ensure_array_like$5(
    /*progress*/
    c[7]
  ), d = [];
  for (let u = 0; u < h.length; u += 1)
    d[u] = create_each_block$4(get_each_context$4(c, h, u));
  return {
    c() {
      for (let u = 0; u < d.length; u += 1)
        d[u].c();
      a = empty$5();
    },
    l(u) {
      for (let _ = 0; _ < d.length; _ += 1)
        d[_].l(u);
      a = empty$5();
    },
    m(u, _) {
      for (let g = 0; g < d.length; g += 1)
        d[g] && d[g].m(u, _);
      insert_hydration$f(u, a, _);
    },
    p(u, _) {
      if (_[0] & /*progress_level, progress*/
      16512) {
        h = ensure_array_like$5(
          /*progress*/
          u[7]
        );
        let g;
        for (g = 0; g < h.length; g += 1) {
          const $ = get_each_context$4(u, h, g);
          d[g] ? d[g].p($, _) : (d[g] = create_each_block$4($), d[g].c(), d[g].m(a.parentNode, a));
        }
        for (; g < d.length; g += 1)
          d[g].d(1);
        d.length = h.length;
      }
    },
    d(u) {
      u && detach$f(a), destroy_each$4(d, u);
    }
  };
}
function create_if_block_4$3(c) {
  let a, h, d, u, _ = (
    /*i*/
    c[42] !== 0 && create_if_block_8()
  ), g = (
    /*p*/
    c[40].desc != null && create_if_block_7(c)
  ), $ = (
    /*p*/
    c[40].desc != null && /*progress_level*/
    c[14] && /*progress_level*/
    c[14][
      /*i*/
      c[42]
    ] != null && create_if_block_6()
  ), b = (
    /*progress_level*/
    c[14] != null && create_if_block_5$3(c)
  );
  return {
    c() {
      _ && _.c(), a = space$a(), g && g.c(), h = space$a(), $ && $.c(), d = space$a(), b && b.c(), u = empty$5();
    },
    l(y) {
      _ && _.l(y), a = claim_space$a(y), g && g.l(y), h = claim_space$a(y), $ && $.l(y), d = claim_space$a(y), b && b.l(y), u = empty$5();
    },
    m(y, v) {
      _ && _.m(y, v), insert_hydration$f(y, a, v), g && g.m(y, v), insert_hydration$f(y, h, v), $ && $.m(y, v), insert_hydration$f(y, d, v), b && b.m(y, v), insert_hydration$f(y, u, v);
    },
    p(y, v) {
      /*p*/
      y[40].desc != null ? g ? g.p(y, v) : (g = create_if_block_7(y), g.c(), g.m(h.parentNode, h)) : g && (g.d(1), g = null), /*p*/
      y[40].desc != null && /*progress_level*/
      y[14] && /*progress_level*/
      y[14][
        /*i*/
        y[42]
      ] != null ? $ || ($ = create_if_block_6(), $.c(), $.m(d.parentNode, d)) : $ && ($.d(1), $ = null), /*progress_level*/
      y[14] != null ? b ? b.p(y, v) : (b = create_if_block_5$3(y), b.c(), b.m(u.parentNode, u)) : b && (b.d(1), b = null);
    },
    d(y) {
      y && (detach$f(a), detach$f(h), detach$f(d), detach$f(u)), _ && _.d(y), g && g.d(y), $ && $.d(y), b && b.d(y);
    }
  };
}
function create_if_block_8(c) {
  let a;
  return {
    c() {
      a = text$a(" /");
    },
    l(h) {
      a = claim_text$9(h, " /");
    },
    m(h, d) {
      insert_hydration$f(h, a, d);
    },
    d(h) {
      h && detach$f(a);
    }
  };
}
function create_if_block_7(c) {
  let a = (
    /*p*/
    c[40].desc + ""
  ), h;
  return {
    c() {
      h = text$a(a);
    },
    l(d) {
      h = claim_text$9(d, a);
    },
    m(d, u) {
      insert_hydration$f(d, h, u);
    },
    p(d, u) {
      u[0] & /*progress*/
      128 && a !== (a = /*p*/
      d[40].desc + "") && set_data$9(h, a);
    },
    d(d) {
      d && detach$f(h);
    }
  };
}
function create_if_block_6(c) {
  let a;
  return {
    c() {
      a = text$a("-");
    },
    l(h) {
      a = claim_text$9(h, "-");
    },
    m(h, d) {
      insert_hydration$f(h, a, d);
    },
    d(h) {
      h && detach$f(a);
    }
  };
}
function create_if_block_5$3(c) {
  let a = (100 * /*progress_level*/
  (c[14][
    /*i*/
    c[42]
  ] || 0)).toFixed(1) + "", h, d;
  return {
    c() {
      h = text$a(a), d = text$a("%");
    },
    l(u) {
      h = claim_text$9(u, a), d = claim_text$9(u, "%");
    },
    m(u, _) {
      insert_hydration$f(u, h, _), insert_hydration$f(u, d, _);
    },
    p(u, _) {
      _[0] & /*progress_level*/
      16384 && a !== (a = (100 * /*progress_level*/
      (u[14][
        /*i*/
        u[42]
      ] || 0)).toFixed(1) + "") && set_data$9(h, a);
    },
    d(u) {
      u && (detach$f(h), detach$f(d));
    }
  };
}
function create_each_block$4(c) {
  let a, h = (
    /*p*/
    (c[40].desc != null || /*progress_level*/
    c[14] && /*progress_level*/
    c[14][
      /*i*/
      c[42]
    ] != null) && create_if_block_4$3(c)
  );
  return {
    c() {
      h && h.c(), a = empty$5();
    },
    l(d) {
      h && h.l(d), a = empty$5();
    },
    m(d, u) {
      h && h.m(d, u), insert_hydration$f(d, a, u);
    },
    p(d, u) {
      /*p*/
      d[40].desc != null || /*progress_level*/
      d[14] && /*progress_level*/
      d[14][
        /*i*/
        d[42]
      ] != null ? h ? h.p(d, u) : (h = create_if_block_4$3(d), h.c(), h.m(a.parentNode, a)) : h && (h.d(1), h = null);
    },
    d(d) {
      d && detach$f(a), h && h.d(d);
    }
  };
}
function create_if_block_1$6(c) {
  let a, h, d, u;
  const _ = (
    /*#slots*/
    c[30]["additional-loading-text"]
  ), g = create_slot$1(
    _,
    c,
    /*$$scope*/
    c[29],
    get_additional_loading_text_slot_context
  );
  return {
    c() {
      a = element$b("p"), h = text$a(
        /*loading_text*/
        c[9]
      ), d = space$a(), g && g.c(), this.h();
    },
    l($) {
      a = claim_element$b($, "P", {
        class: !0
      });
      var b = children$d(a);
      h = claim_text$9(
        b,
        /*loading_text*/
        c[9]
      ), b.forEach(detach$f), d = claim_space$a($), g && g.l($), this.h();
    },
    h() {
      attr$d(a, "class", "loading svelte-v0wucf");
    },
    m($, b) {
      insert_hydration$f($, a, b), append_hydration$b(a, h), insert_hydration$f($, d, b), g && g.m($, b), u = !0;
    },
    p($, b) {
      (!u || b[0] & /*loading_text*/
      512) && set_data$9(
        h,
        /*loading_text*/
        $[9]
      ), g && g.p && (!u || b[0] & /*$$scope*/
      536870912) && update_slot_base$1(
        g,
        _,
        $,
        /*$$scope*/
        $[29],
        u ? get_slot_changes$1(
          _,
          /*$$scope*/
          $[29],
          b,
          get_additional_loading_text_slot_changes
        ) : get_all_dirty_from_scope$1(
          /*$$scope*/
          $[29]
        ),
        get_additional_loading_text_slot_context
      );
    },
    i($) {
      u || (transition_in$f(g, $), u = !0);
    },
    o($) {
      transition_out$f(g, $), u = !1;
    },
    d($) {
      $ && (detach$f(a), detach$f(d)), g && g.d($);
    }
  };
}
function create_fragment$f(c) {
  let a, h, d, u, _;
  const g = [create_if_block$8, create_if_block_17], $ = [];
  function b(y, v) {
    return (
      /*status*/
      y[4] === "pending" ? 0 : (
        /*status*/
        y[4] === "error" ? 1 : -1
      )
    );
  }
  return ~(h = b(c)) && (d = $[h] = g[h](c)), {
    c() {
      a = element$b("div"), d && d.c(), this.h();
    },
    l(y) {
      a = claim_element$b(y, "DIV", {
        class: !0
      });
      var v = children$d(a);
      d && d.l(v), v.forEach(detach$f), this.h();
    },
    h() {
      attr$d(a, "class", u = "wrap " + /*variant*/
      c[8] + " " + /*show_progress*/
      c[6] + " svelte-v0wucf"), toggle_class$7(a, "hide", !/*status*/
      c[4] || /*status*/
      c[4] === "complete" || /*show_progress*/
      c[6] === "hidden"), toggle_class$7(
        a,
        "translucent",
        /*variant*/
        c[8] === "center" && /*status*/
        (c[4] === "pending" || /*status*/
        c[4] === "error") || /*translucent*/
        c[11] || /*show_progress*/
        c[6] === "minimal"
      ), toggle_class$7(
        a,
        "generating",
        /*status*/
        c[4] === "generating" && /*show_progress*/
        c[6] === "full"
      ), toggle_class$7(
        a,
        "border",
        /*border*/
        c[12]
      ), set_style$5(
        a,
        "position",
        /*absolute*/
        c[10] ? "absolute" : "static"
      ), set_style$5(
        a,
        "padding",
        /*absolute*/
        c[10] ? "0" : "var(--size-8) 0"
      );
    },
    m(y, v) {
      insert_hydration$f(y, a, v), ~h && $[h].m(a, null), c[33](a), _ = !0;
    },
    p(y, v) {
      let E = h;
      h = b(y), h === E ? ~h && $[h].p(y, v) : (d && (group_outros$a(), transition_out$f($[E], 1, 1, () => {
        $[E] = null;
      }), check_outros$a()), ~h ? (d = $[h], d ? d.p(y, v) : (d = $[h] = g[h](y), d.c()), transition_in$f(d, 1), d.m(a, null)) : d = null), (!_ || v[0] & /*variant, show_progress*/
      320 && u !== (u = "wrap " + /*variant*/
      y[8] + " " + /*show_progress*/
      y[6] + " svelte-v0wucf")) && attr$d(a, "class", u), (!_ || v[0] & /*variant, show_progress, status, show_progress*/
      336) && toggle_class$7(a, "hide", !/*status*/
      y[4] || /*status*/
      y[4] === "complete" || /*show_progress*/
      y[6] === "hidden"), (!_ || v[0] & /*variant, show_progress, variant, status, translucent, show_progress*/
      2384) && toggle_class$7(
        a,
        "translucent",
        /*variant*/
        y[8] === "center" && /*status*/
        (y[4] === "pending" || /*status*/
        y[4] === "error") || /*translucent*/
        y[11] || /*show_progress*/
        y[6] === "minimal"
      ), (!_ || v[0] & /*variant, show_progress, status, show_progress*/
      336) && toggle_class$7(
        a,
        "generating",
        /*status*/
        y[4] === "generating" && /*show_progress*/
        y[6] === "full"
      ), (!_ || v[0] & /*variant, show_progress, border*/
      4416) && toggle_class$7(
        a,
        "border",
        /*border*/
        y[12]
      ), v[0] & /*absolute*/
      1024 && set_style$5(
        a,
        "position",
        /*absolute*/
        y[10] ? "absolute" : "static"
      ), v[0] & /*absolute*/
      1024 && set_style$5(
        a,
        "padding",
        /*absolute*/
        y[10] ? "0" : "var(--size-8) 0"
      );
    },
    i(y) {
      _ || (transition_in$f(d), _ = !0);
    },
    o(y) {
      transition_out$f(d), _ = !1;
    },
    d(y) {
      y && detach$f(a), ~h && $[h].d(), c[33](null);
    }
  };
}
let items = [], called = !1;
async function scroll_into_view(c, a = !0) {
  if (!(window.__gradio_mode__ === "website" || window.__gradio_mode__ !== "app" && a !== !0)) {
    if (items.push(c), !called) called = !0;
    else return;
    await tick$2(), requestAnimationFrame(() => {
      let h = [0, 0];
      for (let d = 0; d < items.length; d++) {
        const _ = items[d].getBoundingClientRect();
        (d === 0 || _.top + window.scrollY <= h[0]) && (h[0] = _.top + window.scrollY, h[1] = d);
      }
      window.scrollTo({
        top: h[0] - 20,
        behavior: "smooth"
      }), called = !1, items = [];
    });
  }
}
function instance$c(c, a, h) {
  let d, {
    $$slots: u = {},
    $$scope: _
  } = a;
  const g = createEventDispatcher$7();
  let {
    i18n: $
  } = a, {
    eta: b = null
  } = a, {
    queue_position: y
  } = a, {
    queue_size: v
  } = a, {
    status: E
  } = a, {
    scroll_to_output: S = !1
  } = a, {
    timer: R = !0
  } = a, {
    show_progress: x = "full"
  } = a, {
    message: H = null
  } = a, {
    progress: T = null
  } = a, {
    variant: C = "default"
  } = a, {
    loading_text: O = "Loading..."
  } = a, {
    absolute: j = !0
  } = a, {
    translucent: B = !1
  } = a, {
    border: D = !1
  } = a, {
    autoscroll: M
  } = a, I, P = !1, L = 0, Y = 0, N = null, W = null, V = 0, ue = null, se, ce = null, oe = !0;
  const ge = () => {
    h(0, b = h(27, N = h(19, le = null))), h(25, L = performance.now()), h(26, Y = 0), P = !0, J();
  };
  function J() {
    requestAnimationFrame(() => {
      h(26, Y = (performance.now() - L) / 1e3), P && J();
    });
  }
  function ae() {
    h(26, Y = 0), h(0, b = h(27, N = h(19, le = null))), P && (P = !1);
  }
  onDestroy$1(() => {
    P && ae();
  });
  let le = null;
  function z(U) {
    binding_callbacks$7[U ? "unshift" : "push"](() => {
      ce = U, h(16, ce), h(7, T), h(14, ue), h(15, se);
    });
  }
  const A = () => {
    g("clear_status");
  };
  function F(U) {
    binding_callbacks$7[U ? "unshift" : "push"](() => {
      I = U, h(13, I);
    });
  }
  return c.$$set = (U) => {
    "i18n" in U && h(1, $ = U.i18n), "eta" in U && h(0, b = U.eta), "queue_position" in U && h(2, y = U.queue_position), "queue_size" in U && h(3, v = U.queue_size), "status" in U && h(4, E = U.status), "scroll_to_output" in U && h(22, S = U.scroll_to_output), "timer" in U && h(5, R = U.timer), "show_progress" in U && h(6, x = U.show_progress), "message" in U && h(23, H = U.message), "progress" in U && h(7, T = U.progress), "variant" in U && h(8, C = U.variant), "loading_text" in U && h(9, O = U.loading_text), "absolute" in U && h(10, j = U.absolute), "translucent" in U && h(11, B = U.translucent), "border" in U && h(12, D = U.border), "autoscroll" in U && h(24, M = U.autoscroll), "$$scope" in U && h(29, _ = U.$$scope);
  }, c.$$.update = () => {
    c.$$.dirty[0] & /*eta, old_eta, timer_start, eta_from_start*/
    436207617 && (b === null && h(0, b = N), b != null && N !== b && (h(28, W = (performance.now() - L) / 1e3 + b), h(19, le = W.toFixed(1)), h(27, N = b))), c.$$.dirty[0] & /*eta_from_start, timer_diff*/
    335544320 && h(17, V = W === null || W <= 0 || !Y ? null : Math.min(Y / W, 1)), c.$$.dirty[0] & /*progress*/
    128 && T != null && h(18, oe = !1), c.$$.dirty[0] & /*progress, progress_level, progress_bar, last_progress_level*/
    114816 && (T != null ? h(14, ue = T.map((U) => {
      if (U.index != null && U.length != null)
        return U.index / U.length;
      if (U.progress != null)
        return U.progress;
    })) : h(14, ue = null), ue ? (h(15, se = ue[ue.length - 1]), ce && (se === 0 ? h(16, ce.style.transition = "0", ce) : h(16, ce.style.transition = "150ms", ce))) : h(15, se = void 0)), c.$$.dirty[0] & /*status*/
    16 && (E === "pending" ? ge() : ae()), c.$$.dirty[0] & /*el, scroll_to_output, status, autoscroll*/
    20979728 && I && S && (E === "pending" || E === "complete") && scroll_into_view(I, M), c.$$.dirty[0] & /*status, message*/
    8388624, c.$$.dirty[0] & /*timer_diff*/
    67108864 && h(20, d = Y.toFixed(1));
  }, [b, $, y, v, E, R, x, T, C, O, j, B, D, I, ue, se, ce, V, oe, le, d, g, S, H, M, L, Y, N, W, _, u, z, A, F];
}
class Static extends SvelteComponent$i {
  constructor(a) {
    super(), init$i(this, a, instance$c, create_fragment$f, safe_not_equal$i, {
      i18n: 1,
      eta: 0,
      queue_position: 2,
      queue_size: 3,
      status: 4,
      scroll_to_output: 22,
      timer: 5,
      show_progress: 6,
      message: 23,
      progress: 7,
      variant: 8,
      loading_text: 9,
      absolute: 10,
      translucent: 11,
      border: 12,
      autoscroll: 24
    }, null, [-1, -1]);
  }
}
/*! @license DOMPurify 3.1.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.6/LICENSE */
const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create
} = Object, {
  apply,
  construct
} = typeof Reflect < "u" && Reflect;
freeze || (freeze = function(a) {
  return a;
});
seal || (seal = function(a) {
  return a;
});
apply || (apply = function(a, h, d) {
  return a.apply(h, d);
});
construct || (construct = function(a, h) {
  return new a(...h);
});
const arrayForEach = unapply(Array.prototype.forEach), arrayPop = unapply(Array.prototype.pop), arrayPush = unapply(Array.prototype.push), stringToLowerCase = unapply(String.prototype.toLowerCase), stringToString = unapply(String.prototype.toString), stringMatch = unapply(String.prototype.match), stringReplace = unapply(String.prototype.replace), stringIndexOf = unapply(String.prototype.indexOf), stringTrim = unapply(String.prototype.trim), objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty), regExpTest = unapply(RegExp.prototype.test), typeErrorCreate = unconstruct(TypeError);
function unapply(c) {
  return function(a) {
    for (var h = arguments.length, d = new Array(h > 1 ? h - 1 : 0), u = 1; u < h; u++)
      d[u - 1] = arguments[u];
    return apply(c, a, d);
  };
}
function unconstruct(c) {
  return function() {
    for (var a = arguments.length, h = new Array(a), d = 0; d < a; d++)
      h[d] = arguments[d];
    return construct(c, h);
  };
}
function addToSet(c, a) {
  let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
  setPrototypeOf && setPrototypeOf(c, null);
  let d = a.length;
  for (; d--; ) {
    let u = a[d];
    if (typeof u == "string") {
      const _ = h(u);
      _ !== u && (isFrozen(a) || (a[d] = _), u = _);
    }
    c[u] = !0;
  }
  return c;
}
function cleanArray(c) {
  for (let a = 0; a < c.length; a++)
    objectHasOwnProperty(c, a) || (c[a] = null);
  return c;
}
function clone(c) {
  const a = create(null);
  for (const [h, d] of entries(c))
    objectHasOwnProperty(c, h) && (Array.isArray(d) ? a[h] = cleanArray(d) : d && typeof d == "object" && d.constructor === Object ? a[h] = clone(d) : a[h] = d);
  return a;
}
function lookupGetter(c, a) {
  for (; c !== null; ) {
    const d = getOwnPropertyDescriptor(c, a);
    if (d) {
      if (d.get)
        return unapply(d.get);
      if (typeof d.value == "function")
        return unapply(d.value);
    }
    c = getPrototypeOf(c);
  }
  function h() {
    return null;
  }
  return h;
}
const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), text$9 = freeze(["#text"]), html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm), ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm), TMPLIT_EXPR = seal(/\${[\w\W]*}/gm), DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/), ARIA_ATTR = seal(/^aria-[\-\w]+$/), IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i), ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), DOCTYPE_NAME = seal(/^html$/i), CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR,
  ERB_EXPR,
  TMPLIT_EXPR,
  DATA_ATTR,
  ARIA_ATTR,
  IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA,
  ATTR_WHITESPACE,
  DOCTYPE_NAME,
  CUSTOM_ELEMENT
});
const NODE_TYPE = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, getGlobal = function() {
  return typeof window > "u" ? null : window;
}, _createTrustedTypesPolicy = function(a, h) {
  if (typeof a != "object" || typeof a.createPolicy != "function")
    return null;
  let d = null;
  const u = "data-tt-policy-suffix";
  h && h.hasAttribute(u) && (d = h.getAttribute(u));
  const _ = "dompurify" + (d ? "#" + d : "");
  try {
    return a.createPolicy(_, {
      createHTML(g) {
        return g;
      },
      createScriptURL(g) {
        return g;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + _ + " could not be created."), null;
  }
};
function createDOMPurify() {
  let c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  const a = (Je) => createDOMPurify(Je);
  if (a.version = "3.1.6", a.removed = [], !c || !c.document || c.document.nodeType !== NODE_TYPE.document)
    return a.isSupported = !1, a;
  let {
    document: h
  } = c;
  const d = h, u = d.currentScript, {
    DocumentFragment: _,
    HTMLTemplateElement: g,
    Node: $,
    Element: b,
    NodeFilter: y,
    NamedNodeMap: v = c.NamedNodeMap || c.MozNamedAttrMap,
    HTMLFormElement: E,
    DOMParser: S,
    trustedTypes: R
  } = c, x = b.prototype, H = lookupGetter(x, "cloneNode"), T = lookupGetter(x, "remove"), C = lookupGetter(x, "nextSibling"), O = lookupGetter(x, "childNodes"), j = lookupGetter(x, "parentNode");
  if (typeof g == "function") {
    const Je = h.createElement("template");
    Je.content && Je.content.ownerDocument && (h = Je.content.ownerDocument);
  }
  let B, D = "";
  const {
    implementation: M,
    createNodeIterator: I,
    createDocumentFragment: P,
    getElementsByTagName: L
  } = h, {
    importNode: Y
  } = d;
  let N = {};
  a.isSupported = typeof entries == "function" && typeof j == "function" && M && M.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: W,
    ERB_EXPR: V,
    TMPLIT_EXPR: ue,
    DATA_ATTR: se,
    ARIA_ATTR: ce,
    IS_SCRIPT_OR_DATA: oe,
    ATTR_WHITESPACE: ge,
    CUSTOM_ELEMENT: J
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: ae
  } = EXPRESSIONS, le = null;
  const z = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text$9]);
  let A = null;
  const F = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
  let U = Object.seal(create(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), Z = null, G = null, Q = !0, he = !0, me = !1, Te = !0, Pe = !1, Re = !0, Me = !1, Fe = !1, ve = !1, be = !1, X = !1, ne = !1, te = !0, ye = !1;
  const xe = "user-content-";
  let Le = !0, Ie = !1, fe = {}, He = null;
  const Be = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let st = null;
  const nt = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  let ht = null;
  const Ve = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), et = "http://www.w3.org/1998/Math/MathML", lt = "http://www.w3.org/2000/svg", dt = "http://www.w3.org/1999/xhtml";
  let De = dt, $e = !1, we = null;
  const ze = addToSet({}, [et, lt, dt], stringToString);
  let at = null;
  const ct = ["application/xhtml+xml", "text/html"], ie = "text/html";
  let Ce = null, Ue = null;
  const Ze = h.createElement("form"), Qe = function(pe) {
    return pe instanceof RegExp || pe instanceof Function;
  }, We = function() {
    let pe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(Ue && Ue === pe)) {
      if ((!pe || typeof pe != "object") && (pe = {}), pe = clone(pe), at = // eslint-disable-next-line unicorn/prefer-includes
      ct.indexOf(pe.PARSER_MEDIA_TYPE) === -1 ? ie : pe.PARSER_MEDIA_TYPE, Ce = at === "application/xhtml+xml" ? stringToString : stringToLowerCase, le = objectHasOwnProperty(pe, "ALLOWED_TAGS") ? addToSet({}, pe.ALLOWED_TAGS, Ce) : z, A = objectHasOwnProperty(pe, "ALLOWED_ATTR") ? addToSet({}, pe.ALLOWED_ATTR, Ce) : F, we = objectHasOwnProperty(pe, "ALLOWED_NAMESPACES") ? addToSet({}, pe.ALLOWED_NAMESPACES, stringToString) : ze, ht = objectHasOwnProperty(pe, "ADD_URI_SAFE_ATTR") ? addToSet(
        clone(Ve),
        // eslint-disable-line indent
        pe.ADD_URI_SAFE_ATTR,
        // eslint-disable-line indent
        Ce
        // eslint-disable-line indent
      ) : Ve, st = objectHasOwnProperty(pe, "ADD_DATA_URI_TAGS") ? addToSet(
        clone(nt),
        // eslint-disable-line indent
        pe.ADD_DATA_URI_TAGS,
        // eslint-disable-line indent
        Ce
        // eslint-disable-line indent
      ) : nt, He = objectHasOwnProperty(pe, "FORBID_CONTENTS") ? addToSet({}, pe.FORBID_CONTENTS, Ce) : Be, Z = objectHasOwnProperty(pe, "FORBID_TAGS") ? addToSet({}, pe.FORBID_TAGS, Ce) : {}, G = objectHasOwnProperty(pe, "FORBID_ATTR") ? addToSet({}, pe.FORBID_ATTR, Ce) : {}, fe = objectHasOwnProperty(pe, "USE_PROFILES") ? pe.USE_PROFILES : !1, Q = pe.ALLOW_ARIA_ATTR !== !1, he = pe.ALLOW_DATA_ATTR !== !1, me = pe.ALLOW_UNKNOWN_PROTOCOLS || !1, Te = pe.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Pe = pe.SAFE_FOR_TEMPLATES || !1, Re = pe.SAFE_FOR_XML !== !1, Me = pe.WHOLE_DOCUMENT || !1, be = pe.RETURN_DOM || !1, X = pe.RETURN_DOM_FRAGMENT || !1, ne = pe.RETURN_TRUSTED_TYPE || !1, ve = pe.FORCE_BODY || !1, te = pe.SANITIZE_DOM !== !1, ye = pe.SANITIZE_NAMED_PROPS || !1, Le = pe.KEEP_CONTENT !== !1, Ie = pe.IN_PLACE || !1, ae = pe.ALLOWED_URI_REGEXP || IS_ALLOWED_URI, De = pe.NAMESPACE || dt, U = pe.CUSTOM_ELEMENT_HANDLING || {}, pe.CUSTOM_ELEMENT_HANDLING && Qe(pe.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (U.tagNameCheck = pe.CUSTOM_ELEMENT_HANDLING.tagNameCheck), pe.CUSTOM_ELEMENT_HANDLING && Qe(pe.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (U.attributeNameCheck = pe.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), pe.CUSTOM_ELEMENT_HANDLING && typeof pe.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (U.allowCustomizedBuiltInElements = pe.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Pe && (he = !1), X && (be = !0), fe && (le = addToSet({}, text$9), A = [], fe.html === !0 && (addToSet(le, html$1), addToSet(A, html)), fe.svg === !0 && (addToSet(le, svg$1), addToSet(A, svg), addToSet(A, xml)), fe.svgFilters === !0 && (addToSet(le, svgFilters), addToSet(A, svg), addToSet(A, xml)), fe.mathMl === !0 && (addToSet(le, mathMl$1), addToSet(A, mathMl), addToSet(A, xml))), pe.ADD_TAGS && (le === z && (le = clone(le)), addToSet(le, pe.ADD_TAGS, Ce)), pe.ADD_ATTR && (A === F && (A = clone(A)), addToSet(A, pe.ADD_ATTR, Ce)), pe.ADD_URI_SAFE_ATTR && addToSet(ht, pe.ADD_URI_SAFE_ATTR, Ce), pe.FORBID_CONTENTS && (He === Be && (He = clone(He)), addToSet(He, pe.FORBID_CONTENTS, Ce)), Le && (le["#text"] = !0), Me && addToSet(le, ["html", "head", "body"]), le.table && (addToSet(le, ["tbody"]), delete Z.tbody), pe.TRUSTED_TYPES_POLICY) {
        if (typeof pe.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof pe.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        B = pe.TRUSTED_TYPES_POLICY, D = B.createHTML("");
      } else
        B === void 0 && (B = _createTrustedTypesPolicy(R, u)), B !== null && typeof D == "string" && (D = B.createHTML(""));
      freeze && freeze(pe), Ue = pe;
    }
  }, ee = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]), K = addToSet({}, ["foreignobject", "annotation-xml"]), de = addToSet({}, ["title", "style", "font", "a", "script"]), Ae = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]), ke = addToSet({}, [...mathMl$1, ...mathMlDisallowed]), Oe = function(pe) {
    let je = j(pe);
    (!je || !je.tagName) && (je = {
      namespaceURI: De,
      tagName: "template"
    });
    const tt = stringToLowerCase(pe.tagName), pt = stringToLowerCase(je.tagName);
    return we[pe.namespaceURI] ? pe.namespaceURI === lt ? je.namespaceURI === dt ? tt === "svg" : je.namespaceURI === et ? tt === "svg" && (pt === "annotation-xml" || ee[pt]) : !!Ae[tt] : pe.namespaceURI === et ? je.namespaceURI === dt ? tt === "math" : je.namespaceURI === lt ? tt === "math" && K[pt] : !!ke[tt] : pe.namespaceURI === dt ? je.namespaceURI === lt && !K[pt] || je.namespaceURI === et && !ee[pt] ? !1 : !ke[tt] && (de[tt] || !Ae[tt]) : !!(at === "application/xhtml+xml" && we[pe.namespaceURI]) : !1;
  }, Ne = function(pe) {
    arrayPush(a.removed, {
      element: pe
    });
    try {
      j(pe).removeChild(pe);
    } catch {
      T(pe);
    }
  }, Xe = function(pe, je) {
    try {
      arrayPush(a.removed, {
        attribute: je.getAttributeNode(pe),
        from: je
      });
    } catch {
      arrayPush(a.removed, {
        attribute: null,
        from: je
      });
    }
    if (je.removeAttribute(pe), pe === "is" && !A[pe])
      if (be || X)
        try {
          Ne(je);
        } catch {
        }
      else
        try {
          je.setAttribute(pe, "");
        } catch {
        }
  }, Ye = function(pe) {
    let je = null, tt = null;
    if (ve)
      pe = "<remove></remove>" + pe;
    else {
      const gt = stringMatch(pe, /^[\r\n\t ]+/);
      tt = gt && gt[0];
    }
    at === "application/xhtml+xml" && De === dt && (pe = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + pe + "</body></html>");
    const pt = B ? B.createHTML(pe) : pe;
    if (De === dt)
      try {
        je = new S().parseFromString(pt, at);
      } catch {
      }
    if (!je || !je.documentElement) {
      je = M.createDocument(De, "template", null);
      try {
        je.documentElement.innerHTML = $e ? D : pt;
      } catch {
      }
    }
    const vt = je.body || je.documentElement;
    return pe && tt && vt.insertBefore(h.createTextNode(tt), vt.childNodes[0] || null), De === dt ? L.call(je, Me ? "html" : "body")[0] : Me ? je.documentElement : vt;
  }, qe = function(pe) {
    return I.call(
      pe.ownerDocument || pe,
      pe,
      // eslint-disable-next-line no-bitwise
      y.SHOW_ELEMENT | y.SHOW_COMMENT | y.SHOW_TEXT | y.SHOW_PROCESSING_INSTRUCTION | y.SHOW_CDATA_SECTION,
      null
    );
  }, rt = function(pe) {
    return pe instanceof E && (typeof pe.nodeName != "string" || typeof pe.textContent != "string" || typeof pe.removeChild != "function" || !(pe.attributes instanceof v) || typeof pe.removeAttribute != "function" || typeof pe.setAttribute != "function" || typeof pe.namespaceURI != "string" || typeof pe.insertBefore != "function" || typeof pe.hasChildNodes != "function");
  }, Ke = function(pe) {
    return typeof $ == "function" && pe instanceof $;
  }, Ge = function(pe, je, tt) {
    N[pe] && arrayForEach(N[pe], (pt) => {
      pt.call(a, je, tt, Ue);
    });
  }, it = function(pe) {
    let je = null;
    if (Ge("beforeSanitizeElements", pe, null), rt(pe))
      return Ne(pe), !0;
    const tt = Ce(pe.nodeName);
    if (Ge("uponSanitizeElement", pe, {
      tagName: tt,
      allowedTags: le
    }), pe.hasChildNodes() && !Ke(pe.firstElementChild) && regExpTest(/<[/\w]/g, pe.innerHTML) && regExpTest(/<[/\w]/g, pe.textContent) || pe.nodeType === NODE_TYPE.progressingInstruction || Re && pe.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, pe.data))
      return Ne(pe), !0;
    if (!le[tt] || Z[tt]) {
      if (!Z[tt] && ut(tt) && (U.tagNameCheck instanceof RegExp && regExpTest(U.tagNameCheck, tt) || U.tagNameCheck instanceof Function && U.tagNameCheck(tt)))
        return !1;
      if (Le && !He[tt]) {
        const pt = j(pe) || pe.parentNode, vt = O(pe) || pe.childNodes;
        if (vt && pt) {
          const gt = vt.length;
          for (let yt = gt - 1; yt >= 0; --yt) {
            const Et = H(vt[yt], !0);
            Et.__removalCount = (pe.__removalCount || 0) + 1, pt.insertBefore(Et, C(pe));
          }
        }
      }
      return Ne(pe), !0;
    }
    return pe instanceof b && !Oe(pe) || (tt === "noscript" || tt === "noembed" || tt === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, pe.innerHTML) ? (Ne(pe), !0) : (Pe && pe.nodeType === NODE_TYPE.text && (je = pe.textContent, arrayForEach([W, V, ue], (pt) => {
      je = stringReplace(je, pt, " ");
    }), pe.textContent !== je && (arrayPush(a.removed, {
      element: pe.cloneNode()
    }), pe.textContent = je)), Ge("afterSanitizeElements", pe, null), !1);
  }, ot = function(pe, je, tt) {
    if (te && (je === "id" || je === "name") && (tt in h || tt in Ze))
      return !1;
    if (!(he && !G[je] && regExpTest(se, je))) {
      if (!(Q && regExpTest(ce, je))) {
        if (!A[je] || G[je]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(ut(pe) && (U.tagNameCheck instanceof RegExp && regExpTest(U.tagNameCheck, pe) || U.tagNameCheck instanceof Function && U.tagNameCheck(pe)) && (U.attributeNameCheck instanceof RegExp && regExpTest(U.attributeNameCheck, je) || U.attributeNameCheck instanceof Function && U.attributeNameCheck(je)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            je === "is" && U.allowCustomizedBuiltInElements && (U.tagNameCheck instanceof RegExp && regExpTest(U.tagNameCheck, tt) || U.tagNameCheck instanceof Function && U.tagNameCheck(tt)))
          ) return !1;
        } else if (!ht[je]) {
          if (!regExpTest(ae, stringReplace(tt, ge, ""))) {
            if (!((je === "src" || je === "xlink:href" || je === "href") && pe !== "script" && stringIndexOf(tt, "data:") === 0 && st[pe])) {
              if (!(me && !regExpTest(oe, stringReplace(tt, ge, "")))) {
                if (tt)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, ut = function(pe) {
    return pe !== "annotation-xml" && stringMatch(pe, J);
  }, ft = function(pe) {
    Ge("beforeSanitizeAttributes", pe, null);
    const {
      attributes: je
    } = pe;
    if (!je)
      return;
    const tt = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: A
    };
    let pt = je.length;
    for (; pt--; ) {
      const vt = je[pt], {
        name: gt,
        namespaceURI: yt,
        value: Et
      } = vt, Rt = Ce(gt);
      let bt = gt === "value" ? Et : stringTrim(Et);
      if (tt.attrName = Rt, tt.attrValue = bt, tt.keepAttr = !0, tt.forceKeepAttr = void 0, Ge("uponSanitizeAttribute", pe, tt), bt = tt.attrValue, Re && regExpTest(/((--!?|])>)|<\/(style|title)/i, bt)) {
        Xe(gt, pe);
        continue;
      }
      if (tt.forceKeepAttr || (Xe(gt, pe), !tt.keepAttr))
        continue;
      if (!Te && regExpTest(/\/>/i, bt)) {
        Xe(gt, pe);
        continue;
      }
      Pe && arrayForEach([W, V, ue], (Ln) => {
        bt = stringReplace(bt, Ln, " ");
      });
      const Fn = Ce(pe.nodeName);
      if (ot(Fn, Rt, bt)) {
        if (ye && (Rt === "id" || Rt === "name") && (Xe(gt, pe), bt = xe + bt), B && typeof R == "object" && typeof R.getAttributeType == "function" && !yt)
          switch (R.getAttributeType(Fn, Rt)) {
            case "TrustedHTML": {
              bt = B.createHTML(bt);
              break;
            }
            case "TrustedScriptURL": {
              bt = B.createScriptURL(bt);
              break;
            }
          }
        try {
          yt ? pe.setAttributeNS(yt, gt, bt) : pe.setAttribute(gt, bt), rt(pe) ? Ne(pe) : arrayPop(a.removed);
        } catch {
        }
      }
    }
    Ge("afterSanitizeAttributes", pe, null);
  }, mt = function Je(pe) {
    let je = null;
    const tt = qe(pe);
    for (Ge("beforeSanitizeShadowDOM", pe, null); je = tt.nextNode(); )
      Ge("uponSanitizeShadowNode", je, null), !it(je) && (je.content instanceof _ && Je(je.content), ft(je));
    Ge("afterSanitizeShadowDOM", pe, null);
  };
  return a.sanitize = function(Je) {
    let pe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, je = null, tt = null, pt = null, vt = null;
    if ($e = !Je, $e && (Je = "<!-->"), typeof Je != "string" && !Ke(Je))
      if (typeof Je.toString == "function") {
        if (Je = Je.toString(), typeof Je != "string")
          throw typeErrorCreate("dirty is not a string, aborting");
      } else
        throw typeErrorCreate("toString is not a function");
    if (!a.isSupported)
      return Je;
    if (Fe || We(pe), a.removed = [], typeof Je == "string" && (Ie = !1), Ie) {
      if (Je.nodeName) {
        const Et = Ce(Je.nodeName);
        if (!le[Et] || Z[Et])
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Je instanceof $)
      je = Ye("<!---->"), tt = je.ownerDocument.importNode(Je, !0), tt.nodeType === NODE_TYPE.element && tt.nodeName === "BODY" || tt.nodeName === "HTML" ? je = tt : je.appendChild(tt);
    else {
      if (!be && !Pe && !Me && // eslint-disable-next-line unicorn/prefer-includes
      Je.indexOf("<") === -1)
        return B && ne ? B.createHTML(Je) : Je;
      if (je = Ye(Je), !je)
        return be ? null : ne ? D : "";
    }
    je && ve && Ne(je.firstChild);
    const gt = qe(Ie ? Je : je);
    for (; pt = gt.nextNode(); )
      it(pt) || (pt.content instanceof _ && mt(pt.content), ft(pt));
    if (Ie)
      return Je;
    if (be) {
      if (X)
        for (vt = P.call(je.ownerDocument); je.firstChild; )
          vt.appendChild(je.firstChild);
      else
        vt = je;
      return (A.shadowroot || A.shadowrootmode) && (vt = Y.call(d, vt, !0)), vt;
    }
    let yt = Me ? je.outerHTML : je.innerHTML;
    return Me && le["!doctype"] && je.ownerDocument && je.ownerDocument.doctype && je.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, je.ownerDocument.doctype.name) && (yt = "<!DOCTYPE " + je.ownerDocument.doctype.name + `>
` + yt), Pe && arrayForEach([W, V, ue], (Et) => {
      yt = stringReplace(yt, Et, " ");
    }), B && ne ? B.createHTML(yt) : yt;
  }, a.setConfig = function() {
    let Je = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    We(Je), Fe = !0;
  }, a.clearConfig = function() {
    Ue = null, Fe = !1;
  }, a.isValidAttribute = function(Je, pe, je) {
    Ue || We({});
    const tt = Ce(Je), pt = Ce(pe);
    return ot(tt, pt, je);
  }, a.addHook = function(Je, pe) {
    typeof pe == "function" && (N[Je] = N[Je] || [], arrayPush(N[Je], pe));
  }, a.removeHook = function(Je) {
    if (N[Je])
      return arrayPop(N[Je]);
  }, a.removeHooks = function(Je) {
    N[Je] && (N[Je] = []);
  }, a.removeAllHooks = function() {
    N = {};
  }, a;
}
createDOMPurify();
const {
  HtmlTagHydration: HtmlTagHydration$1,
  SvelteComponent: SvelteComponent$h,
  add_render_callback: add_render_callback$1,
  append_hydration: append_hydration$a,
  attr: attr$c,
  bubble: bubble$3,
  check_outros: check_outros$9,
  children: children$c,
  claim_component: claim_component$d,
  claim_element: claim_element$a,
  claim_html_tag: claim_html_tag$1,
  claim_space: claim_space$9,
  claim_text: claim_text$8,
  create_component: create_component$d,
  create_in_transition,
  create_out_transition,
  destroy_component: destroy_component$d,
  detach: detach$e,
  element: element$a,
  get_svelte_dataset,
  group_outros: group_outros$9,
  init: init$h,
  insert_hydration: insert_hydration$e,
  listen: listen$6,
  mount_component: mount_component$d,
  run_all: run_all$4,
  safe_not_equal: safe_not_equal$h,
  set_data: set_data$8,
  space: space$9,
  stop_propagation: stop_propagation$1,
  text: text$8,
  toggle_class: toggle_class$6,
  transition_in: transition_in$e,
  transition_out: transition_out$e
} = window.__gradio__svelte__internal, {
  createEventDispatcher: createEventDispatcher$6,
  onMount: onMount$3
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$g,
  append_hydration: append_hydration$9,
  attr: attr$b,
  bubble: bubble$2,
  check_outros: check_outros$8,
  children: children$b,
  claim_component: claim_component$c,
  claim_element: claim_element$9,
  claim_space: claim_space$8,
  create_animation,
  create_component: create_component$c,
  destroy_component: destroy_component$c,
  detach: detach$d,
  element: element$9,
  ensure_array_like: ensure_array_like$4,
  fix_and_outro_and_destroy_block,
  fix_position,
  group_outros: group_outros$8,
  init: init$g,
  insert_hydration: insert_hydration$d,
  mount_component: mount_component$c,
  noop: noop$7,
  safe_not_equal: safe_not_equal$g,
  set_style: set_style$4,
  space: space$8,
  transition_in: transition_in$d,
  transition_out: transition_out$d,
  update_keyed_each
} = window.__gradio__svelte__internal;
function get_gradio_version() {
  const c = document.querySelector(".gradio-container");
  if (!c)
    return "";
  const a = c.className.match(/gradio-container-(.+)/);
  return a ? a[1] : "";
}
+get_gradio_version()[0];
async function upload(c, a, h = upload_files) {
  const d = (Array.isArray(c) ? c : [c]).map((u) => u.blob);
  return await Promise.all(await h(a, d, void 0, void 0).then((u) => {
    if (u.modelscope_upload_error)
      return [];
    if (u.error)
      throw new Error(u.error);
    return u.files ? u.files.map((_, g) => new FileData({
      ...c[g],
      path: _,
      url: a + "/file=" + _
    })) : [];
  }));
}
function t(c, a, h, d) {
  return new (h || (h = Promise))(function(u, _) {
    function g(y) {
      try {
        b(d.next(y));
      } catch (v) {
        _(v);
      }
    }
    function $(y) {
      try {
        b(d.throw(y));
      } catch (v) {
        _(v);
      }
    }
    function b(y) {
      var v;
      y.done ? u(y.value) : (v = y.value, v instanceof h ? v : new h(function(E) {
        E(v);
      })).then(g, $);
    }
    b((d = d.apply(c, [])).next());
  });
}
class i {
  constructor() {
    this.listeners = {};
  }
  on(a, h, d) {
    if (this.listeners[a] || (this.listeners[a] = /* @__PURE__ */ new Set()), this.listeners[a].add(h), d == null ? void 0 : d.once) {
      const u = () => {
        this.un(a, u), this.un(a, h);
      };
      return this.on(a, u), u;
    }
    return () => this.un(a, h);
  }
  un(a, h) {
    var d;
    (d = this.listeners[a]) === null || d === void 0 || d.delete(h);
  }
  once(a, h) {
    return this.on(a, h, {
      once: !0
    });
  }
  unAll() {
    this.listeners = {};
  }
  emit(a, ...h) {
    this.listeners[a] && this.listeners[a].forEach((d) => d(...h));
  }
}
class e extends i {
  constructor(a) {
    super(), this.subscriptions = [], this.options = a;
  }
  onInit() {
  }
  _init(a) {
    this.wavesurfer = a, this.onInit();
  }
  destroy() {
    this.emit("destroy"), this.subscriptions.forEach((a) => a());
  }
}
class s extends i {
  constructor() {
    super(...arguments), this.unsubscribe = () => {
    };
  }
  start() {
    this.unsubscribe = this.on("tick", () => {
      requestAnimationFrame(() => {
        this.emit("tick");
      });
    }), this.emit("tick");
  }
  stop() {
    this.unsubscribe();
  }
  destroy() {
    this.unsubscribe();
  }
}
const o = ["audio/webm", "audio/wav", "audio/mpeg", "audio/mp4", "audio/mp3"];
class r extends e {
  constructor(a) {
    var h, d, u, _, g, $;
    super(Object.assign(Object.assign({}, a), {
      audioBitsPerSecond: (h = a.audioBitsPerSecond) !== null && h !== void 0 ? h : 128e3,
      scrollingWaveform: (d = a.scrollingWaveform) !== null && d !== void 0 && d,
      scrollingWaveformWindow: (u = a.scrollingWaveformWindow) !== null && u !== void 0 ? u : 5,
      continuousWaveform: (_ = a.continuousWaveform) !== null && _ !== void 0 && _,
      renderRecordedAudio: (g = a.renderRecordedAudio) === null || g === void 0 || g,
      mediaRecorderTimeslice: ($ = a.mediaRecorderTimeslice) !== null && $ !== void 0 ? $ : void 0
    })), this.stream = null, this.mediaRecorder = null, this.dataWindow = null, this.isWaveformPaused = !1, this.lastStartTime = 0, this.lastDuration = 0, this.duration = 0, this.timer = new s(), this.subscriptions.push(this.timer.on("tick", () => {
      const b = performance.now() - this.lastStartTime;
      this.duration = this.isPaused() ? this.duration : this.lastDuration + b, this.emit("record-progress", this.duration);
    }));
  }
  static create(a) {
    return new r(a || {});
  }
  renderMicStream(a) {
    var h;
    const d = new AudioContext(), u = d.createMediaStreamSource(a), _ = d.createAnalyser();
    u.connect(_), this.options.continuousWaveform && (_.fftSize = 32);
    const g = _.frequencyBinCount, $ = new Float32Array(g);
    let b = 0;
    this.wavesurfer && ((h = this.originalOptions) !== null && h !== void 0 || (this.originalOptions = Object.assign({}, this.wavesurfer.options)), this.wavesurfer.options.interact = !1, this.options.scrollingWaveform && (this.wavesurfer.options.cursorWidth = 0));
    const y = setInterval(() => {
      var v, E, S, R;
      if (!this.isWaveformPaused) {
        if (_.getFloatTimeDomainData($), this.options.scrollingWaveform) {
          const x = Math.floor((this.options.scrollingWaveformWindow || 0) * d.sampleRate), H = Math.min(x, this.dataWindow ? this.dataWindow.length + g : g), T = new Float32Array(x);
          if (this.dataWindow) {
            const C = Math.max(0, x - this.dataWindow.length);
            T.set(this.dataWindow.slice(-H + g), C);
          }
          T.set($, x - g), this.dataWindow = T;
        } else if (this.options.continuousWaveform) {
          if (!this.dataWindow) {
            const H = this.options.continuousWaveformDuration ? Math.round(100 * this.options.continuousWaveformDuration) : ((E = (v = this.wavesurfer) === null || v === void 0 ? void 0 : v.getWidth()) !== null && E !== void 0 ? E : 0) * window.devicePixelRatio;
            this.dataWindow = new Float32Array(H);
          }
          let x = 0;
          for (let H = 0; H < g; H++) {
            const T = Math.abs($[H]);
            T > x && (x = T);
          }
          if (b + 1 > this.dataWindow.length) {
            const H = new Float32Array(2 * this.dataWindow.length);
            H.set(this.dataWindow, 0), this.dataWindow = H;
          }
          this.dataWindow[b] = x, b++;
        } else this.dataWindow = $;
        if (this.wavesurfer) {
          const x = ((R = (S = this.dataWindow) === null || S === void 0 ? void 0 : S.length) !== null && R !== void 0 ? R : 0) / 100;
          this.wavesurfer.load("", [this.dataWindow], this.options.scrollingWaveform ? this.options.scrollingWaveformWindow : x).then(() => {
            this.wavesurfer && this.options.continuousWaveform && (this.wavesurfer.setTime(this.getDuration() / 1e3), this.wavesurfer.options.minPxPerSec || this.wavesurfer.setOptions({
              minPxPerSec: this.wavesurfer.getWidth() / this.wavesurfer.getDuration()
            }));
          }).catch((H) => {
            console.error("Error rendering real-time recording data:", H);
          });
        }
      }
    }, 10);
    return {
      onDestroy: () => {
        clearInterval(y), u == null || u.disconnect(), d == null || d.close();
      },
      onEnd: () => {
        this.isWaveformPaused = !0, clearInterval(y), this.stopMic();
      }
    };
  }
  startMic(a) {
    return t(this, void 0, void 0, function* () {
      let h;
      try {
        h = yield navigator.mediaDevices.getUserMedia({
          audio: !(a != null && a.deviceId) || {
            deviceId: a.deviceId
          }
        });
      } catch (_) {
        throw new Error("Error accessing the microphone: " + _.message);
      }
      const {
        onDestroy: d,
        onEnd: u
      } = this.renderMicStream(h);
      return this.subscriptions.push(this.once("destroy", d)), this.subscriptions.push(this.once("record-end", u)), this.stream = h, h;
    });
  }
  stopMic() {
    this.stream && (this.stream.getTracks().forEach((a) => a.stop()), this.stream = null, this.mediaRecorder = null);
  }
  startRecording(a) {
    return t(this, void 0, void 0, function* () {
      const h = this.stream || (yield this.startMic(a));
      this.dataWindow = null;
      const d = this.mediaRecorder || new MediaRecorder(h, {
        mimeType: this.options.mimeType || o.find((g) => MediaRecorder.isTypeSupported(g)),
        audioBitsPerSecond: this.options.audioBitsPerSecond
      });
      this.mediaRecorder = d, this.stopRecording();
      const u = [];
      d.ondataavailable = (g) => {
        g.data.size > 0 && u.push(g.data), this.emit("record-data-available", g.data);
      };
      const _ = (g) => {
        var $;
        const b = new Blob(u, {
          type: d.mimeType
        });
        this.emit(g, b), this.options.renderRecordedAudio && (this.applyOriginalOptionsIfNeeded(), ($ = this.wavesurfer) === null || $ === void 0 || $.load(URL.createObjectURL(b)));
      };
      d.onpause = () => _("record-pause"), d.onstop = () => _("record-end"), d.start(this.options.mediaRecorderTimeslice), this.lastStartTime = performance.now(), this.lastDuration = 0, this.duration = 0, this.isWaveformPaused = !1, this.timer.start(), this.emit("record-start");
    });
  }
  getDuration() {
    return this.duration;
  }
  isRecording() {
    var a;
    return ((a = this.mediaRecorder) === null || a === void 0 ? void 0 : a.state) === "recording";
  }
  isPaused() {
    var a;
    return ((a = this.mediaRecorder) === null || a === void 0 ? void 0 : a.state) === "paused";
  }
  isActive() {
    var a;
    return ((a = this.mediaRecorder) === null || a === void 0 ? void 0 : a.state) !== "inactive";
  }
  stopRecording() {
    var a;
    this.isActive() && ((a = this.mediaRecorder) === null || a === void 0 || a.stop(), this.timer.stop());
  }
  pauseRecording() {
    var a, h;
    this.isRecording() && (this.isWaveformPaused = !0, (a = this.mediaRecorder) === null || a === void 0 || a.requestData(), (h = this.mediaRecorder) === null || h === void 0 || h.pause(), this.timer.stop(), this.lastDuration = this.duration);
  }
  resumeRecording() {
    var a;
    this.isPaused() && (this.isWaveformPaused = !1, (a = this.mediaRecorder) === null || a === void 0 || a.resume(), this.timer.start(), this.lastStartTime = performance.now(), this.emit("record-resume"));
  }
  static getAvailableAudioDevices() {
    return t(this, void 0, void 0, function* () {
      return navigator.mediaDevices.enumerateDevices().then((a) => a.filter((h) => h.kind === "audioinput"));
    });
  }
  destroy() {
    this.applyOriginalOptionsIfNeeded(), super.destroy(), this.stopRecording(), this.stopMic();
  }
  applyOriginalOptionsIfNeeded() {
    this.wavesurfer && this.originalOptions && (this.wavesurfer.setOptions(this.originalOptions), delete this.originalOptions);
  }
}
class EventEmitter {
  constructor() {
    this.listeners = {};
  }
  /** Subscribe to an event. Returns an unsubscribe function. */
  on(a, h, d) {
    if (this.listeners[a] || (this.listeners[a] = /* @__PURE__ */ new Set()), this.listeners[a].add(h), d != null && d.once) {
      const u = () => {
        this.un(a, u), this.un(a, h);
      };
      return this.on(a, u), u;
    }
    return () => this.un(a, h);
  }
  /** Unsubscribe from an event */
  un(a, h) {
    var d;
    (d = this.listeners[a]) === null || d === void 0 || d.delete(h);
  }
  /** Subscribe to an event only once */
  once(a, h) {
    return this.on(a, h, {
      once: !0
    });
  }
  /** Clear all events */
  unAll() {
    this.listeners = {};
  }
  /** Emit an event */
  emit(a, ...h) {
    this.listeners[a] && this.listeners[a].forEach((d) => d(...h));
  }
}
class BasePlugin extends EventEmitter {
  /** Create a plugin instance */
  constructor(a) {
    super(), this.subscriptions = [], this.options = a;
  }
  /** Called after this.wavesurfer is available */
  onInit() {
  }
  /** Do not call directly, only called by WavesSurfer internally */
  _init(a) {
    this.wavesurfer = a, this.onInit();
  }
  /** Destroy the plugin and unsubscribe from all events */
  destroy() {
    this.emit("destroy"), this.subscriptions.forEach((a) => a());
  }
}
var __awaiter$5 = function(c, a, h, d) {
  function u(_) {
    return _ instanceof h ? _ : new h(function(g) {
      g(_);
    });
  }
  return new (h || (h = Promise))(function(_, g) {
    function $(v) {
      try {
        y(d.next(v));
      } catch (E) {
        g(E);
      }
    }
    function b(v) {
      try {
        y(d.throw(v));
      } catch (E) {
        g(E);
      }
    }
    function y(v) {
      v.done ? _(v.value) : u(v.value).then($, b);
    }
    y((d = d.apply(c, a || [])).next());
  });
};
function decode(c, a) {
  return __awaiter$5(this, void 0, void 0, function* () {
    const h = new AudioContext({
      sampleRate: a
    });
    return h.decodeAudioData(c).finally(() => h.close());
  });
}
function normalize(c) {
  const a = c[0];
  if (a.some((h) => h > 1 || h < -1)) {
    const h = a.length;
    let d = 0;
    for (let u = 0; u < h; u++) {
      const _ = Math.abs(a[u]);
      _ > d && (d = _);
    }
    for (const u of c)
      for (let _ = 0; _ < h; _++)
        u[_] /= d;
  }
  return c;
}
function createBuffer(c, a) {
  return typeof c[0] == "number" && (c = [c]), normalize(c), {
    duration: a,
    length: c[0].length,
    sampleRate: c[0].length / a,
    numberOfChannels: c.length,
    getChannelData: (h) => c == null ? void 0 : c[h],
    copyFromChannel: AudioBuffer.prototype.copyFromChannel,
    copyToChannel: AudioBuffer.prototype.copyToChannel
  };
}
const Decoder = {
  decode,
  createBuffer
};
function renderNode(c, a) {
  const h = a.xmlns ? document.createElementNS(a.xmlns, c) : document.createElement(c);
  for (const [d, u] of Object.entries(a))
    if (d === "children")
      for (const [_, g] of Object.entries(a))
        typeof g == "string" ? h.appendChild(document.createTextNode(g)) : h.appendChild(renderNode(_, g));
    else d === "style" ? Object.assign(h.style, u) : d === "textContent" ? h.textContent = u : h.setAttribute(d, u.toString());
  return h;
}
function createElement(c, a, h) {
  const d = renderNode(c, a || {});
  return h == null || h.appendChild(d), d;
}
const dom = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createElement,
  default: createElement
}, Symbol.toStringTag, {
  value: "Module"
}));
var __awaiter$4 = function(c, a, h, d) {
  function u(_) {
    return _ instanceof h ? _ : new h(function(g) {
      g(_);
    });
  }
  return new (h || (h = Promise))(function(_, g) {
    function $(v) {
      try {
        y(d.next(v));
      } catch (E) {
        g(E);
      }
    }
    function b(v) {
      try {
        y(d.throw(v));
      } catch (E) {
        g(E);
      }
    }
    function y(v) {
      v.done ? _(v.value) : u(v.value).then($, b);
    }
    y((d = d.apply(c, a || [])).next());
  });
};
function watchProgress(c, a) {
  return __awaiter$4(this, void 0, void 0, function* () {
    if (!c.body || !c.headers) return;
    const h = c.body.getReader(), d = Number(c.headers.get("Content-Length")) || 0;
    let u = 0;
    const _ = ($) => __awaiter$4(this, void 0, void 0, function* () {
      u += ($ == null ? void 0 : $.length) || 0;
      const b = Math.round(u / d * 100);
      a(b);
    }), g = () => __awaiter$4(this, void 0, void 0, function* () {
      let $;
      try {
        $ = yield h.read();
      } catch {
        return;
      }
      $.done || (_($.value), yield g());
    });
    g();
  });
}
function fetchBlob(c, a, h) {
  return __awaiter$4(this, void 0, void 0, function* () {
    const d = yield fetch(c, h);
    if (d.status >= 400)
      throw new Error(`Failed to fetch ${c}: ${d.status} (${d.statusText})`);
    return watchProgress(d.clone(), a), d.blob();
  });
}
const Fetcher = {
  fetchBlob
};
var __awaiter$3 = function(c, a, h, d) {
  function u(_) {
    return _ instanceof h ? _ : new h(function(g) {
      g(_);
    });
  }
  return new (h || (h = Promise))(function(_, g) {
    function $(v) {
      try {
        y(d.next(v));
      } catch (E) {
        g(E);
      }
    }
    function b(v) {
      try {
        y(d.throw(v));
      } catch (E) {
        g(E);
      }
    }
    function y(v) {
      v.done ? _(v.value) : u(v.value).then($, b);
    }
    y((d = d.apply(c, a || [])).next());
  });
};
class Player extends EventEmitter {
  constructor(a) {
    super(), this.isExternalMedia = !1, a.media ? (this.media = a.media, this.isExternalMedia = !0) : this.media = document.createElement("audio"), a.mediaControls && (this.media.controls = !0), a.autoplay && (this.media.autoplay = !0), a.playbackRate != null && this.onMediaEvent("canplay", () => {
      a.playbackRate != null && (this.media.playbackRate = a.playbackRate);
    }, {
      once: !0
    });
  }
  onMediaEvent(a, h, d) {
    return this.media.addEventListener(a, h, d), () => this.media.removeEventListener(a, h, d);
  }
  getSrc() {
    return this.media.currentSrc || this.media.src || "";
  }
  revokeSrc() {
    const a = this.getSrc();
    a.startsWith("blob:") && URL.revokeObjectURL(a);
  }
  canPlayType(a) {
    return this.media.canPlayType(a) !== "";
  }
  setSrc(a, h) {
    const d = this.getSrc();
    if (a && d === a) return;
    this.revokeSrc();
    const u = h instanceof Blob && (this.canPlayType(h.type) || !a) ? URL.createObjectURL(h) : a;
    d && (this.media.src = "");
    try {
      this.media.src = u;
    } catch {
      this.media.src = a;
    }
  }
  destroy() {
    this.isExternalMedia || (this.media.pause(), this.media.remove(), this.revokeSrc(), this.media.src = "", this.media.load());
  }
  setMediaElement(a) {
    this.media = a;
  }
  /** Start playing the audio */
  play() {
    return __awaiter$3(this, void 0, void 0, function* () {
      return this.media.play();
    });
  }
  /** Pause the audio */
  pause() {
    this.media.pause();
  }
  /** Check if the audio is playing */
  isPlaying() {
    return !this.media.paused && !this.media.ended;
  }
  /** Jump to a specific time in the audio (in seconds) */
  setTime(a) {
    this.media.currentTime = Math.max(0, Math.min(a, this.getDuration()));
  }
  /** Get the duration of the audio in seconds */
  getDuration() {
    return this.media.duration;
  }
  /** Get the current audio position in seconds */
  getCurrentTime() {
    return this.media.currentTime;
  }
  /** Get the audio volume */
  getVolume() {
    return this.media.volume;
  }
  /** Set the audio volume */
  setVolume(a) {
    this.media.volume = a;
  }
  /** Get the audio muted state */
  getMuted() {
    return this.media.muted;
  }
  /** Mute or unmute the audio */
  setMuted(a) {
    this.media.muted = a;
  }
  /** Get the playback speed */
  getPlaybackRate() {
    return this.media.playbackRate;
  }
  /** Check if the audio is seeking */
  isSeeking() {
    return this.media.seeking;
  }
  /** Set the playback speed, pass an optional false to NOT preserve the pitch */
  setPlaybackRate(a, h) {
    h != null && (this.media.preservesPitch = h), this.media.playbackRate = a;
  }
  /** Get the HTML media element */
  getMediaElement() {
    return this.media;
  }
  /** Set a sink id to change the audio output device */
  setSinkId(a) {
    return this.media.setSinkId(a);
  }
}
function makeDraggable(c, a, h, d, u = 3, _ = 0, g = 100) {
  if (!c) return () => {
  };
  const $ = matchMedia("(pointer: coarse)").matches;
  let b = () => {
  };
  const y = (v) => {
    if (v.button !== _) return;
    v.preventDefault(), v.stopPropagation();
    let E = v.clientX, S = v.clientY, R = !1;
    const x = Date.now(), H = (B) => {
      if (B.preventDefault(), B.stopPropagation(), $ && Date.now() - x < g) return;
      const D = B.clientX, M = B.clientY, I = D - E, P = M - S;
      if (R || Math.abs(I) > u || Math.abs(P) > u) {
        const L = c.getBoundingClientRect(), {
          left: Y,
          top: N
        } = L;
        R || (h == null || h(E - Y, S - N), R = !0), a(I, P, D - Y, M - N), E = D, S = M;
      }
    }, T = (B) => {
      if (R) {
        const D = B.clientX, M = B.clientY, I = c.getBoundingClientRect(), {
          left: P,
          top: L
        } = I;
        d == null || d(D - P, M - L);
      }
      b();
    }, C = (B) => {
      (!B.relatedTarget || B.relatedTarget === document.documentElement) && T(B);
    }, O = (B) => {
      R && (B.stopPropagation(), B.preventDefault());
    }, j = (B) => {
      R && B.preventDefault();
    };
    document.addEventListener("pointermove", H), document.addEventListener("pointerup", T), document.addEventListener("pointerout", C), document.addEventListener("pointercancel", C), document.addEventListener("touchmove", j, {
      passive: !1
    }), document.addEventListener("click", O, {
      capture: !0
    }), b = () => {
      document.removeEventListener("pointermove", H), document.removeEventListener("pointerup", T), document.removeEventListener("pointerout", C), document.removeEventListener("pointercancel", C), document.removeEventListener("touchmove", j), setTimeout(() => {
        document.removeEventListener("click", O, {
          capture: !0
        });
      }, 10);
    };
  };
  return c.addEventListener("pointerdown", y), () => {
    b(), c.removeEventListener("pointerdown", y);
  };
}
var __awaiter$2 = function(c, a, h, d) {
  function u(_) {
    return _ instanceof h ? _ : new h(function(g) {
      g(_);
    });
  }
  return new (h || (h = Promise))(function(_, g) {
    function $(v) {
      try {
        y(d.next(v));
      } catch (E) {
        g(E);
      }
    }
    function b(v) {
      try {
        y(d.throw(v));
      } catch (E) {
        g(E);
      }
    }
    function y(v) {
      v.done ? _(v.value) : u(v.value).then($, b);
    }
    y((d = d.apply(c, a || [])).next());
  });
}, __rest$1 = function(c, a) {
  var h = {};
  for (var d in c) Object.prototype.hasOwnProperty.call(c, d) && a.indexOf(d) < 0 && (h[d] = c[d]);
  if (c != null && typeof Object.getOwnPropertySymbols == "function") for (var u = 0, d = Object.getOwnPropertySymbols(c); u < d.length; u++)
    a.indexOf(d[u]) < 0 && Object.prototype.propertyIsEnumerable.call(c, d[u]) && (h[d[u]] = c[d[u]]);
  return h;
};
class Renderer extends EventEmitter {
  constructor(a, h) {
    super(), this.timeouts = [], this.isScrollable = !1, this.audioData = null, this.resizeObserver = null, this.lastContainerWidth = 0, this.isDragging = !1, this.subscriptions = [], this.unsubscribeOnScroll = [], this.subscriptions = [], this.options = a;
    const d = this.parentFromOptionsContainer(a.container);
    this.parent = d;
    const [u, _] = this.initHtml();
    d.appendChild(u), this.container = u, this.scrollContainer = _.querySelector(".scroll"), this.wrapper = _.querySelector(".wrapper"), this.canvasWrapper = _.querySelector(".canvases"), this.progressWrapper = _.querySelector(".progress"), this.cursor = _.querySelector(".cursor"), h && _.appendChild(h), this.initEvents();
  }
  parentFromOptionsContainer(a) {
    let h;
    if (typeof a == "string" ? h = document.querySelector(a) : a instanceof HTMLElement && (h = a), !h)
      throw new Error("Container not found");
    return h;
  }
  initEvents() {
    const a = (h) => {
      const d = this.wrapper.getBoundingClientRect(), u = h.clientX - d.left, _ = h.clientY - d.top, g = u / d.width, $ = _ / d.height;
      return [g, $];
    };
    if (this.wrapper.addEventListener("click", (h) => {
      const [d, u] = a(h);
      this.emit("click", d, u);
    }), this.wrapper.addEventListener("dblclick", (h) => {
      const [d, u] = a(h);
      this.emit("dblclick", d, u);
    }), (this.options.dragToSeek === !0 || typeof this.options.dragToSeek == "object") && this.initDrag(), this.scrollContainer.addEventListener("scroll", () => {
      const {
        scrollLeft: h,
        scrollWidth: d,
        clientWidth: u
      } = this.scrollContainer, _ = h / d, g = (h + u) / d;
      this.emit("scroll", _, g, h, h + u);
    }), typeof ResizeObserver == "function") {
      const h = this.createDelay(100);
      this.resizeObserver = new ResizeObserver(() => {
        h().then(() => this.onContainerResize()).catch(() => {
        });
      }), this.resizeObserver.observe(this.scrollContainer);
    }
  }
  onContainerResize() {
    const a = this.parent.clientWidth;
    a === this.lastContainerWidth && this.options.height !== "auto" || (this.lastContainerWidth = a, this.reRender());
  }
  initDrag() {
    this.subscriptions.push(makeDraggable(
      this.wrapper,
      // On drag
      (a, h, d) => {
        this.emit("drag", Math.max(0, Math.min(1, d / this.wrapper.getBoundingClientRect().width)));
      },
      // On start drag
      (a) => {
        this.isDragging = !0, this.emit("dragstart", Math.max(0, Math.min(1, a / this.wrapper.getBoundingClientRect().width)));
      },
      // On end drag
      (a) => {
        this.isDragging = !1, this.emit("dragend", Math.max(0, Math.min(1, a / this.wrapper.getBoundingClientRect().width)));
      }
    ));
  }
  getHeight(a, h) {
    var d;
    const _ = ((d = this.audioData) === null || d === void 0 ? void 0 : d.numberOfChannels) || 1;
    if (a == null) return 128;
    if (!isNaN(Number(a))) return Number(a);
    if (a === "auto") {
      const g = this.parent.clientHeight || 128;
      return h != null && h.every(($) => !$.overlay) ? g / _ : g;
    }
    return 128;
  }
  initHtml() {
    const a = document.createElement("div"), h = a.attachShadow({
      mode: "open"
    }), d = this.options.cspNonce && typeof this.options.cspNonce == "string" ? this.options.cspNonce.replace(/"/g, "") : "";
    return h.innerHTML = `
      <style${d ? ` nonce="${d}"` : ""}>
        :host {
          user-select: none;
          min-width: 1px;
        }
        :host audio {
          display: block;
          width: 100%;
        }
        :host .scroll {
          overflow-x: auto;
          overflow-y: hidden;
          width: 100%;
          position: relative;
        }
        :host .noScrollbar {
          scrollbar-color: transparent;
          scrollbar-width: none;
        }
        :host .noScrollbar::-webkit-scrollbar {
          display: none;
          -webkit-appearance: none;
        }
        :host .wrapper {
          position: relative;
          overflow: visible;
          z-index: 2;
        }
        :host .canvases {
          min-height: ${this.getHeight(this.options.height, this.options.splitChannels)}px;
        }
        :host .canvases > div {
          position: relative;
        }
        :host canvas {
          display: block;
          position: absolute;
          top: 0;
          image-rendering: pixelated;
        }
        :host .progress {
          pointer-events: none;
          position: absolute;
          z-index: 2;
          top: 0;
          left: 0;
          width: 0;
          height: 100%;
          overflow: hidden;
        }
        :host .progress > div {
          position: relative;
        }
        :host .cursor {
          pointer-events: none;
          position: absolute;
          z-index: 5;
          top: 0;
          left: 0;
          height: 100%;
          border-radius: 2px;
        }
      </style>

      <div class="scroll" part="scroll">
        <div class="wrapper" part="wrapper">
          <div class="canvases" part="canvases"></div>
          <div class="progress" part="progress"></div>
          <div class="cursor" part="cursor"></div>
        </div>
      </div>
    `, [a, h];
  }
  /** Wavesurfer itself calls this method. Do not call it manually. */
  setOptions(a) {
    if (this.options.container !== a.container) {
      const h = this.parentFromOptionsContainer(a.container);
      h.appendChild(this.container), this.parent = h;
    }
    (a.dragToSeek === !0 || typeof this.options.dragToSeek == "object") && this.initDrag(), this.options = a, this.reRender();
  }
  getWrapper() {
    return this.wrapper;
  }
  getWidth() {
    return this.scrollContainer.clientWidth;
  }
  getScroll() {
    return this.scrollContainer.scrollLeft;
  }
  setScroll(a) {
    this.scrollContainer.scrollLeft = a;
  }
  setScrollPercentage(a) {
    const {
      scrollWidth: h
    } = this.scrollContainer, d = h * a;
    this.setScroll(d);
  }
  destroy() {
    var a, h;
    this.subscriptions.forEach((d) => d()), this.container.remove(), (a = this.resizeObserver) === null || a === void 0 || a.disconnect(), (h = this.unsubscribeOnScroll) === null || h === void 0 || h.forEach((d) => d()), this.unsubscribeOnScroll = [];
  }
  createDelay(a = 10) {
    let h, d;
    const u = () => {
      h && clearTimeout(h), d && d();
    };
    return this.timeouts.push(u), () => new Promise((_, g) => {
      u(), d = g, h = setTimeout(() => {
        h = void 0, d = void 0, _();
      }, a);
    });
  }
  // Convert array of color values to linear gradient
  convertColorValues(a) {
    if (!Array.isArray(a)) return a || "";
    if (a.length < 2) return a[0] || "";
    const h = document.createElement("canvas"), d = h.getContext("2d"), u = h.height * (window.devicePixelRatio || 1), _ = d.createLinearGradient(0, 0, 0, u), g = 1 / (a.length - 1);
    return a.forEach(($, b) => {
      const y = b * g;
      _.addColorStop(y, $);
    }), _;
  }
  getPixelRatio() {
    return Math.max(1, window.devicePixelRatio || 1);
  }
  renderBarWaveform(a, h, d, u) {
    const _ = a[0], g = a[1] || a[0], $ = _.length, {
      width: b,
      height: y
    } = d.canvas, v = y / 2, E = this.getPixelRatio(), S = h.barWidth ? h.barWidth * E : 1, R = h.barGap ? h.barGap * E : h.barWidth ? S / 2 : 0, x = h.barRadius || 0, H = b / (S + R) / $, T = x && "roundRect" in d ? "roundRect" : "rect";
    d.beginPath();
    let C = 0, O = 0, j = 0;
    for (let B = 0; B <= $; B++) {
      const D = Math.round(B * H);
      if (D > C) {
        const P = Math.round(O * v * u), L = Math.round(j * v * u), Y = P + L || 1;
        let N = v - P;
        h.barAlign === "top" ? N = 0 : h.barAlign === "bottom" && (N = y - Y), d[T](C * (S + R), N, S, Y, x), C = D, O = 0, j = 0;
      }
      const M = Math.abs(_[B] || 0), I = Math.abs(g[B] || 0);
      M > O && (O = M), I > j && (j = I);
    }
    d.fill(), d.closePath();
  }
  renderLineWaveform(a, h, d, u) {
    const _ = (g) => {
      const $ = a[g] || a[0], b = $.length, {
        height: y
      } = d.canvas, v = y / 2, E = d.canvas.width / b;
      d.moveTo(0, v);
      let S = 0, R = 0;
      for (let x = 0; x <= b; x++) {
        const H = Math.round(x * E);
        if (H > S) {
          const C = Math.round(R * v * u) || 1, O = v + C * (g === 0 ? -1 : 1);
          d.lineTo(S, O), S = H, R = 0;
        }
        const T = Math.abs($[x] || 0);
        T > R && (R = T);
      }
      d.lineTo(S, v);
    };
    d.beginPath(), _(0), _(1), d.fill(), d.closePath();
  }
  renderWaveform(a, h, d) {
    if (d.fillStyle = this.convertColorValues(h.waveColor), h.renderFunction) {
      h.renderFunction(a, d);
      return;
    }
    let u = h.barHeight || 1;
    if (h.normalize) {
      const _ = Array.from(a[0]).reduce((g, $) => Math.max(g, Math.abs($)), 0);
      u = _ ? 1 / _ : 1;
    }
    if (h.barWidth || h.barGap || h.barAlign) {
      this.renderBarWaveform(a, h, d, u);
      return;
    }
    this.renderLineWaveform(a, h, d, u);
  }
  renderSingleCanvas(a, h, d, u, _, g, $) {
    const b = this.getPixelRatio(), y = document.createElement("canvas");
    y.width = Math.round(d * b), y.height = Math.round(u * b), y.style.width = `${d}px`, y.style.height = `${u}px`, y.style.left = `${Math.round(_)}px`, g.appendChild(y);
    const v = y.getContext("2d");
    if (this.renderWaveform(a, h, v), y.width > 0 && y.height > 0) {
      const E = y.cloneNode(), S = E.getContext("2d");
      S.drawImage(y, 0, 0), S.globalCompositeOperation = "source-in", S.fillStyle = this.convertColorValues(h.progressColor), S.fillRect(0, 0, y.width, y.height), $.appendChild(E);
    }
  }
  renderMultiCanvas(a, h, d, u, _, g) {
    const $ = this.getPixelRatio(), {
      clientWidth: b
    } = this.scrollContainer, y = d / $;
    let v = Math.min(Renderer.MAX_CANVAS_WIDTH, b, y), E = {};
    if (v === 0) return;
    if (h.barWidth || h.barGap) {
      const C = h.barWidth || 0.5, O = h.barGap || C / 2, j = C + O;
      v % j !== 0 && (v = Math.floor(v / j) * j);
    }
    const S = (C) => {
      if (C < 0 || C >= x || E[C]) return;
      E[C] = !0;
      const O = C * v, j = Math.min(y - O, v);
      if (j <= 0) return;
      const B = a.map((D) => {
        const M = Math.floor(O / y * D.length), I = Math.floor((O + j) / y * D.length);
        return D.slice(M, I);
      });
      this.renderSingleCanvas(B, h, j, u, O, _, g);
    }, R = () => {
      Object.keys(E).length > Renderer.MAX_NODES && (_.innerHTML = "", g.innerHTML = "", E = {});
    }, x = Math.ceil(y / v);
    if (!this.isScrollable) {
      for (let C = 0; C < x; C++)
        S(C);
      return;
    }
    const H = this.scrollContainer.scrollLeft / y, T = Math.floor(H * x);
    if (S(T - 1), S(T), S(T + 1), x > 1) {
      const C = this.on("scroll", () => {
        const {
          scrollLeft: O
        } = this.scrollContainer, j = Math.floor(O / y * x);
        R(), S(j - 1), S(j), S(j + 1);
      });
      this.unsubscribeOnScroll.push(C);
    }
  }
  renderChannel(a, h, d, u) {
    var {
      overlay: _
    } = h, g = __rest$1(h, ["overlay"]);
    const $ = document.createElement("div"), b = this.getHeight(g.height, g.splitChannels);
    $.style.height = `${b}px`, _ && u > 0 && ($.style.marginTop = `-${b}px`), this.canvasWrapper.style.minHeight = `${b}px`, this.canvasWrapper.appendChild($);
    const y = $.cloneNode();
    this.progressWrapper.appendChild(y), this.renderMultiCanvas(a, g, d, b, $, y);
  }
  render(a) {
    return __awaiter$2(this, void 0, void 0, function* () {
      var h;
      this.timeouts.forEach((b) => b()), this.timeouts = [], this.canvasWrapper.innerHTML = "", this.progressWrapper.innerHTML = "", this.options.width != null && (this.scrollContainer.style.width = typeof this.options.width == "number" ? `${this.options.width}px` : this.options.width);
      const d = this.getPixelRatio(), u = this.scrollContainer.clientWidth, _ = Math.ceil(a.duration * (this.options.minPxPerSec || 0));
      this.isScrollable = _ > u;
      const g = this.options.fillParent && !this.isScrollable, $ = (g ? u : _) * d;
      if (this.wrapper.style.width = g ? "100%" : `${_}px`, this.scrollContainer.style.overflowX = this.isScrollable ? "auto" : "hidden", this.scrollContainer.classList.toggle("noScrollbar", !!this.options.hideScrollbar), this.cursor.style.backgroundColor = `${this.options.cursorColor || this.options.progressColor}`, this.cursor.style.width = `${this.options.cursorWidth}px`, this.audioData = a, this.emit("render"), this.options.splitChannels)
        for (let b = 0; b < a.numberOfChannels; b++) {
          const y = Object.assign(Object.assign({}, this.options), (h = this.options.splitChannels) === null || h === void 0 ? void 0 : h[b]);
          this.renderChannel([a.getChannelData(b)], y, $, b);
        }
      else {
        const b = [a.getChannelData(0)];
        a.numberOfChannels > 1 && b.push(a.getChannelData(1)), this.renderChannel(b, this.options, $, 0);
      }
      Promise.resolve().then(() => this.emit("rendered"));
    });
  }
  reRender() {
    if (this.unsubscribeOnScroll.forEach((d) => d()), this.unsubscribeOnScroll = [], !this.audioData) return;
    const {
      scrollWidth: a
    } = this.scrollContainer, {
      right: h
    } = this.progressWrapper.getBoundingClientRect();
    if (this.render(this.audioData), this.isScrollable && a !== this.scrollContainer.scrollWidth) {
      const {
        right: d
      } = this.progressWrapper.getBoundingClientRect();
      let u = d - h;
      u *= 2, u = u < 0 ? Math.floor(u) : Math.ceil(u), u /= 2, this.scrollContainer.scrollLeft += u;
    }
  }
  zoom(a) {
    this.options.minPxPerSec = a, this.reRender();
  }
  scrollIntoView(a, h = !1) {
    const {
      scrollLeft: d,
      scrollWidth: u,
      clientWidth: _
    } = this.scrollContainer, g = a * u, $ = d, b = d + _, y = _ / 2;
    if (this.isDragging)
      g + 30 > b ? this.scrollContainer.scrollLeft += 30 : g - 30 < $ && (this.scrollContainer.scrollLeft -= 30);
    else {
      (g < $ || g > b) && (this.scrollContainer.scrollLeft = g - (this.options.autoCenter ? y : 0));
      const v = g - d - y;
      h && this.options.autoCenter && v > 0 && (this.scrollContainer.scrollLeft += Math.min(v, 10));
    }
    {
      const v = this.scrollContainer.scrollLeft, E = v / u, S = (v + _) / u;
      this.emit("scroll", E, S, v, v + _);
    }
  }
  renderProgress(a, h) {
    if (isNaN(a)) return;
    const d = a * 100;
    this.canvasWrapper.style.clipPath = `polygon(${d}% 0, 100% 0, 100% 100%, ${d}% 100%)`, this.progressWrapper.style.width = `${d}%`, this.cursor.style.left = `${d}%`, this.cursor.style.transform = `translateX(-${Math.round(d) === 100 ? this.options.cursorWidth : 0}px)`, this.isScrollable && this.options.autoScroll && this.scrollIntoView(a, h);
  }
  exportImage(a, h, d) {
    return __awaiter$2(this, void 0, void 0, function* () {
      const u = this.canvasWrapper.querySelectorAll("canvas");
      if (!u.length)
        throw new Error("No waveform data");
      if (d === "dataURL") {
        const _ = Array.from(u).map((g) => g.toDataURL(a, h));
        return Promise.resolve(_);
      }
      return Promise.all(Array.from(u).map((_) => new Promise((g, $) => {
        _.toBlob((b) => {
          b ? g(b) : $(new Error("Could not export image"));
        }, a, h);
      })));
    });
  }
}
Renderer.MAX_CANVAS_WIDTH = 8e3;
Renderer.MAX_NODES = 10;
class Timer extends EventEmitter {
  constructor() {
    super(...arguments), this.unsubscribe = () => {
    };
  }
  start() {
    this.unsubscribe = this.on("tick", () => {
      requestAnimationFrame(() => {
        this.emit("tick");
      });
    }), this.emit("tick");
  }
  stop() {
    this.unsubscribe();
  }
  destroy() {
    this.unsubscribe();
  }
}
var __awaiter$1 = function(c, a, h, d) {
  function u(_) {
    return _ instanceof h ? _ : new h(function(g) {
      g(_);
    });
  }
  return new (h || (h = Promise))(function(_, g) {
    function $(v) {
      try {
        y(d.next(v));
      } catch (E) {
        g(E);
      }
    }
    function b(v) {
      try {
        y(d.throw(v));
      } catch (E) {
        g(E);
      }
    }
    function y(v) {
      v.done ? _(v.value) : u(v.value).then($, b);
    }
    y((d = d.apply(c, a || [])).next());
  });
};
class WebAudioPlayer extends EventEmitter {
  constructor(a = new AudioContext()) {
    super(), this.bufferNode = null, this.playStartTime = 0, this.playedDuration = 0, this._muted = !1, this._playbackRate = 1, this._duration = void 0, this.buffer = null, this.currentSrc = "", this.paused = !0, this.crossOrigin = null, this.seeking = !1, this.autoplay = !1, this.addEventListener = this.on, this.removeEventListener = this.un, this.audioContext = a, this.gainNode = this.audioContext.createGain(), this.gainNode.connect(this.audioContext.destination);
  }
  load() {
    return __awaiter$1(this, void 0, void 0, function* () {
    });
  }
  get src() {
    return this.currentSrc;
  }
  set src(a) {
    if (this.currentSrc = a, this._duration = void 0, !a) {
      this.buffer = null, this.emit("emptied");
      return;
    }
    fetch(a).then((h) => {
      if (h.status >= 400)
        throw new Error(`Failed to fetch ${a}: ${h.status} (${h.statusText})`);
      return h.arrayBuffer();
    }).then((h) => this.currentSrc !== a ? null : this.audioContext.decodeAudioData(h)).then((h) => {
      this.currentSrc === a && (this.buffer = h, this.emit("loadedmetadata"), this.emit("canplay"), this.autoplay && this.play());
    });
  }
  _play() {
    var a;
    if (!this.paused) return;
    this.paused = !1, (a = this.bufferNode) === null || a === void 0 || a.disconnect(), this.bufferNode = this.audioContext.createBufferSource(), this.buffer && (this.bufferNode.buffer = this.buffer), this.bufferNode.playbackRate.value = this._playbackRate, this.bufferNode.connect(this.gainNode);
    let h = this.playedDuration * this._playbackRate;
    (h >= this.duration || h < 0) && (h = 0, this.playedDuration = 0), this.bufferNode.start(this.audioContext.currentTime, h), this.playStartTime = this.audioContext.currentTime, this.bufferNode.onended = () => {
      this.currentTime >= this.duration && (this.pause(), this.emit("ended"));
    };
  }
  _pause() {
    var a;
    this.paused = !0, (a = this.bufferNode) === null || a === void 0 || a.stop(), this.playedDuration += this.audioContext.currentTime - this.playStartTime;
  }
  play() {
    return __awaiter$1(this, void 0, void 0, function* () {
      this.paused && (this._play(), this.emit("play"));
    });
  }
  pause() {
    this.paused || (this._pause(), this.emit("pause"));
  }
  stopAt(a) {
    var h, d;
    const u = a - this.currentTime;
    (h = this.bufferNode) === null || h === void 0 || h.stop(this.audioContext.currentTime + u), (d = this.bufferNode) === null || d === void 0 || d.addEventListener("ended", () => {
      this.bufferNode = null, this.pause();
    }, {
      once: !0
    });
  }
  setSinkId(a) {
    return __awaiter$1(this, void 0, void 0, function* () {
      return this.audioContext.setSinkId(a);
    });
  }
  get playbackRate() {
    return this._playbackRate;
  }
  set playbackRate(a) {
    this._playbackRate = a, this.bufferNode && (this.bufferNode.playbackRate.value = a);
  }
  get currentTime() {
    return (this.paused ? this.playedDuration : this.playedDuration + (this.audioContext.currentTime - this.playStartTime)) * this._playbackRate;
  }
  set currentTime(a) {
    const h = !this.paused;
    h && this._pause(), this.playedDuration = a / this._playbackRate, h && this._play(), this.emit("seeking"), this.emit("timeupdate");
  }
  get duration() {
    var a, h;
    return (a = this._duration) !== null && a !== void 0 ? a : ((h = this.buffer) === null || h === void 0 ? void 0 : h.duration) || 0;
  }
  set duration(a) {
    this._duration = a;
  }
  get volume() {
    return this.gainNode.gain.value;
  }
  set volume(a) {
    this.gainNode.gain.value = a, this.emit("volumechange");
  }
  get muted() {
    return this._muted;
  }
  set muted(a) {
    this._muted !== a && (this._muted = a, this._muted ? this.gainNode.disconnect() : this.gainNode.connect(this.audioContext.destination));
  }
  canPlayType(a) {
    return /^(audio|video)\//.test(a);
  }
  /** Get the GainNode used to play the audio. Can be used to attach filters. */
  getGainNode() {
    return this.gainNode;
  }
  /** Get decoded audio */
  getChannelData() {
    const a = [];
    if (!this.buffer) return a;
    const h = this.buffer.numberOfChannels;
    for (let d = 0; d < h; d++)
      a.push(this.buffer.getChannelData(d));
    return a;
  }
}
var __awaiter = function(c, a, h, d) {
  function u(_) {
    return _ instanceof h ? _ : new h(function(g) {
      g(_);
    });
  }
  return new (h || (h = Promise))(function(_, g) {
    function $(v) {
      try {
        y(d.next(v));
      } catch (E) {
        g(E);
      }
    }
    function b(v) {
      try {
        y(d.throw(v));
      } catch (E) {
        g(E);
      }
    }
    function y(v) {
      v.done ? _(v.value) : u(v.value).then($, b);
    }
    y((d = d.apply(c, a || [])).next());
  });
};
const defaultOptions$1 = {
  waveColor: "#999",
  progressColor: "#555",
  cursorWidth: 1,
  minPxPerSec: 0,
  fillParent: !0,
  interact: !0,
  dragToSeek: !1,
  autoScroll: !0,
  autoCenter: !0,
  sampleRate: 8e3
};
class WaveSurfer extends Player {
  /** Create a new WaveSurfer instance */
  static create(a) {
    return new WaveSurfer(a);
  }
  /** Create a new WaveSurfer instance */
  constructor(a) {
    const h = a.media || (a.backend === "WebAudio" ? new WebAudioPlayer() : void 0);
    super({
      media: h,
      mediaControls: a.mediaControls,
      autoplay: a.autoplay,
      playbackRate: a.audioRate
    }), this.plugins = [], this.decodedData = null, this.stopAtPosition = null, this.subscriptions = [], this.mediaSubscriptions = [], this.abortController = null, this.options = Object.assign({}, defaultOptions$1, a), this.timer = new Timer();
    const d = h ? void 0 : this.getMediaElement();
    this.renderer = new Renderer(this.options, d), this.initPlayerEvents(), this.initRendererEvents(), this.initTimerEvents(), this.initPlugins();
    const u = this.options.url || this.getSrc() || "";
    Promise.resolve().then(() => {
      this.emit("init");
      const {
        peaks: _,
        duration: g
      } = this.options;
      (u || _ && g) && this.load(u, _, g).catch(() => null);
    });
  }
  updateProgress(a = this.getCurrentTime()) {
    return this.renderer.renderProgress(a / this.getDuration(), this.isPlaying()), a;
  }
  initTimerEvents() {
    this.subscriptions.push(this.timer.on("tick", () => {
      if (!this.isSeeking()) {
        const a = this.updateProgress();
        this.emit("timeupdate", a), this.emit("audioprocess", a), this.stopAtPosition != null && this.isPlaying() && a >= this.stopAtPosition && this.pause();
      }
    }));
  }
  initPlayerEvents() {
    this.isPlaying() && (this.emit("play"), this.timer.start()), this.mediaSubscriptions.push(this.onMediaEvent("timeupdate", () => {
      const a = this.updateProgress();
      this.emit("timeupdate", a);
    }), this.onMediaEvent("play", () => {
      this.emit("play"), this.timer.start();
    }), this.onMediaEvent("pause", () => {
      this.emit("pause"), this.timer.stop(), this.stopAtPosition = null;
    }), this.onMediaEvent("emptied", () => {
      this.timer.stop(), this.stopAtPosition = null;
    }), this.onMediaEvent("ended", () => {
      this.emit("timeupdate", this.getDuration()), this.emit("finish"), this.stopAtPosition = null;
    }), this.onMediaEvent("seeking", () => {
      this.emit("seeking", this.getCurrentTime());
    }), this.onMediaEvent("error", () => {
      var a;
      this.emit("error", (a = this.getMediaElement().error) !== null && a !== void 0 ? a : new Error("Media error")), this.stopAtPosition = null;
    }));
  }
  initRendererEvents() {
    this.subscriptions.push(
      // Seek on click
      this.renderer.on("click", (a, h) => {
        this.options.interact && (this.seekTo(a), this.emit("interaction", a * this.getDuration()), this.emit("click", a, h));
      }),
      // Double click
      this.renderer.on("dblclick", (a, h) => {
        this.emit("dblclick", a, h);
      }),
      // Scroll
      this.renderer.on("scroll", (a, h, d, u) => {
        const _ = this.getDuration();
        this.emit("scroll", a * _, h * _, d, u);
      }),
      // Redraw
      this.renderer.on("render", () => {
        this.emit("redraw");
      }),
      // RedrawComplete
      this.renderer.on("rendered", () => {
        this.emit("redrawcomplete");
      }),
      // DragStart
      this.renderer.on("dragstart", (a) => {
        this.emit("dragstart", a);
      }),
      // DragEnd
      this.renderer.on("dragend", (a) => {
        this.emit("dragend", a);
      })
    );
    {
      let a;
      this.subscriptions.push(this.renderer.on("drag", (h) => {
        if (!this.options.interact) return;
        this.renderer.renderProgress(h), clearTimeout(a);
        let d;
        this.isPlaying() ? d = 0 : this.options.dragToSeek === !0 ? d = 200 : typeof this.options.dragToSeek == "object" && this.options.dragToSeek !== void 0 && (d = this.options.dragToSeek.debounceTime), a = setTimeout(() => {
          this.seekTo(h);
        }, d), this.emit("interaction", h * this.getDuration()), this.emit("drag", h);
      }));
    }
  }
  initPlugins() {
    var a;
    !((a = this.options.plugins) === null || a === void 0) && a.length && this.options.plugins.forEach((h) => {
      this.registerPlugin(h);
    });
  }
  unsubscribePlayerEvents() {
    this.mediaSubscriptions.forEach((a) => a()), this.mediaSubscriptions = [];
  }
  /** Set new wavesurfer options and re-render it */
  setOptions(a) {
    this.options = Object.assign({}, this.options, a), a.duration && !a.peaks && (this.decodedData = Decoder.createBuffer(this.exportPeaks(), a.duration)), a.peaks && a.duration && (this.decodedData = Decoder.createBuffer(a.peaks, a.duration)), this.renderer.setOptions(this.options), a.audioRate && this.setPlaybackRate(a.audioRate), a.mediaControls != null && (this.getMediaElement().controls = a.mediaControls);
  }
  /** Register a wavesurfer.js plugin */
  registerPlugin(a) {
    return a._init(this), this.plugins.push(a), this.subscriptions.push(a.once("destroy", () => {
      this.plugins = this.plugins.filter((h) => h !== a);
    })), a;
  }
  /** For plugins only: get the waveform wrapper div */
  getWrapper() {
    return this.renderer.getWrapper();
  }
  /** For plugins only: get the scroll container client width */
  getWidth() {
    return this.renderer.getWidth();
  }
  /** Get the current scroll position in pixels */
  getScroll() {
    return this.renderer.getScroll();
  }
  /** Set the current scroll position in pixels */
  setScroll(a) {
    return this.renderer.setScroll(a);
  }
  /** Move the start of the viewing window to a specific time in the audio (in seconds) */
  setScrollTime(a) {
    const h = a / this.getDuration();
    this.renderer.setScrollPercentage(h);
  }
  /** Get all registered plugins */
  getActivePlugins() {
    return this.plugins;
  }
  loadAudio(a, h, d, u) {
    return __awaiter(this, void 0, void 0, function* () {
      var _;
      if (this.emit("load", a), !this.options.media && this.isPlaying() && this.pause(), this.decodedData = null, this.stopAtPosition = null, !h && !d) {
        const $ = this.options.fetchParams || {};
        window.AbortController && !$.signal && (this.abortController = new AbortController(), $.signal = (_ = this.abortController) === null || _ === void 0 ? void 0 : _.signal);
        const b = (v) => this.emit("loading", v);
        h = yield Fetcher.fetchBlob(a, b, $);
        const y = this.options.blobMimeType;
        y && (h = new Blob([h], {
          type: y
        }));
      }
      this.setSrc(a, h);
      const g = yield new Promise(($) => {
        const b = u || this.getDuration();
        b ? $(b) : this.mediaSubscriptions.push(this.onMediaEvent("loadedmetadata", () => $(this.getDuration()), {
          once: !0
        }));
      });
      if (!a && !h) {
        const $ = this.getMediaElement();
        $ instanceof WebAudioPlayer && ($.duration = g);
      }
      if (d)
        this.decodedData = Decoder.createBuffer(d, g || 0);
      else if (h) {
        const $ = yield h.arrayBuffer();
        this.decodedData = yield Decoder.decode($, this.options.sampleRate);
      }
      this.decodedData && (this.emit("decode", this.getDuration()), this.renderer.render(this.decodedData)), this.emit("ready", this.getDuration());
    });
  }
  /** Load an audio file by URL, with optional pre-decoded audio data */
  load(a, h, d) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        return yield this.loadAudio(a, void 0, h, d);
      } catch (u) {
        throw this.emit("error", u), u;
      }
    });
  }
  /** Load an audio blob */
  loadBlob(a, h, d) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        return yield this.loadAudio("", a, h, d);
      } catch (u) {
        throw this.emit("error", u), u;
      }
    });
  }
  /** Zoom the waveform by a given pixels-per-second factor */
  zoom(a) {
    if (!this.decodedData)
      throw new Error("No audio loaded");
    this.renderer.zoom(a), this.emit("zoom", a);
  }
  /** Get the decoded audio data */
  getDecodedData() {
    return this.decodedData;
  }
  /** Get decoded peaks */
  exportPeaks({
    channels: a = 2,
    maxLength: h = 8e3,
    precision: d = 1e4
  } = {}) {
    if (!this.decodedData)
      throw new Error("The audio has not been decoded yet");
    const u = Math.min(a, this.decodedData.numberOfChannels), _ = [];
    for (let g = 0; g < u; g++) {
      const $ = this.decodedData.getChannelData(g), b = [], y = $.length / h;
      for (let v = 0; v < h; v++) {
        const E = $.slice(Math.floor(v * y), Math.ceil((v + 1) * y));
        let S = 0;
        for (let R = 0; R < E.length; R++) {
          const x = E[R];
          Math.abs(x) > Math.abs(S) && (S = x);
        }
        b.push(Math.round(S * d) / d);
      }
      _.push(b);
    }
    return _;
  }
  /** Get the duration of the audio in seconds */
  getDuration() {
    let a = super.getDuration() || 0;
    return (a === 0 || a === 1 / 0) && this.decodedData && (a = this.decodedData.duration), a;
  }
  /** Toggle if the waveform should react to clicks */
  toggleInteraction(a) {
    this.options.interact = a;
  }
  /** Jump to a specific time in the audio (in seconds) */
  setTime(a) {
    this.stopAtPosition = null, super.setTime(a), this.updateProgress(a), this.emit("timeupdate", a);
  }
  /** Seek to a percentage of audio as [0..1] (0 = beginning, 1 = end) */
  seekTo(a) {
    const h = this.getDuration() * a;
    this.setTime(h);
  }
  /** Start playing the audio */
  play(a, h) {
    const d = Object.create(null, {
      play: {
        get: () => super.play
      }
    });
    return __awaiter(this, void 0, void 0, function* () {
      return a != null && this.setTime(a), h != null && (this.media instanceof WebAudioPlayer ? this.media.stopAt(h) : this.stopAtPosition = h), d.play.call(this);
    });
  }
  /** Play or pause the audio */
  playPause() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.isPlaying() ? this.pause() : this.play();
    });
  }
  /** Stop the audio and go to the beginning */
  stop() {
    this.pause(), this.setTime(0);
  }
  /** Skip N or -N seconds from the current position */
  skip(a) {
    this.setTime(this.getCurrentTime() + a);
  }
  /** Empty the waveform */
  empty() {
    this.load("", [[0]], 1e-3);
  }
  /** Set HTML media element */
  setMediaElement(a) {
    this.unsubscribePlayerEvents(), super.setMediaElement(a), this.initPlayerEvents();
  }
  exportImage() {
    return __awaiter(this, arguments, void 0, function* (a = "image/png", h = 1, d = "dataURL") {
      return this.renderer.exportImage(a, h, d);
    });
  }
  /** Unmount wavesurfer */
  destroy() {
    var a;
    this.emit("destroy"), (a = this.abortController) === null || a === void 0 || a.abort(), this.plugins.forEach((h) => h.destroy()), this.subscriptions.forEach((h) => h()), this.unsubscribePlayerEvents(), this.timer.destroy(), this.renderer.destroy(), super.destroy();
  }
}
WaveSurfer.BasePlugin = BasePlugin;
WaveSurfer.dom = dom;
const {
  getContext: getContext$1,
  setContext
} = window.__gradio__svelte__internal, context_key = {}, setContextValue = (c) => setContext(context_key, c), getContextValue = () => getContext$1(context_key), {
  SvelteComponent: SvelteComponent$f,
  append_hydration: append_hydration$8,
  attr: attr$a,
  children: children$a,
  claim_svg_element: claim_svg_element$1,
  detach: detach$c,
  init: init$f,
  insert_hydration: insert_hydration$c,
  noop: noop$6,
  safe_not_equal: safe_not_equal$f,
  svg_element: svg_element$1
} = window.__gradio__svelte__internal;
function create_fragment$e(c) {
  let a, h;
  return {
    c() {
      a = svg_element$1("svg"), h = svg_element$1("path"), this.h();
    },
    l(d) {
      a = claim_svg_element$1(d, "svg", {
        xmlns: !0,
        viewBox: !0
      });
      var u = children$a(a);
      h = claim_svg_element$1(u, "path", {
        d: !0,
        fill: !0
      }), children$a(h).forEach(detach$c), u.forEach(detach$c), this.h();
    },
    h() {
      attr$a(h, "d", "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"), attr$a(h, "fill", "currentColor"), attr$a(a, "xmlns", "http://www.w3.org/2000/svg"), attr$a(a, "viewBox", "0 0 24 24");
    },
    m(d, u) {
      insert_hydration$c(d, a, u), append_hydration$8(a, h);
    },
    p: noop$6,
    i: noop$6,
    o: noop$6,
    d(d) {
      d && detach$c(a);
    }
  };
}
class RemoveIcon extends SvelteComponent$f {
  constructor(a) {
    super(), init$f(this, a, null, create_fragment$e, safe_not_equal$f, {});
  }
}
const prettyBytes = (c) => {
  const a = ["B", "KB", "MB", "GB", "PB"];
  let h = 0;
  for (; c > 1024; )
    c /= 1024, h++;
  const d = a[h];
  return c.toFixed(1) + "&nbsp;" + d;
};
function audioBufferToWav(c) {
  const a = function($, b, y) {
    for (let v = 0; v < y.length; v++)
      $.setUint8(b + v, y.charCodeAt(v));
  }, h = c.numberOfChannels, d = c.length * h * 2 + 44, u = new ArrayBuffer(d), _ = new DataView(u);
  let g = 0;
  a(_, g, "RIFF"), g += 4, _.setUint32(g, d - 8, !0), g += 4, a(_, g, "WAVE"), g += 4, a(_, g, "fmt "), g += 4, _.setUint32(g, 16, !0), g += 4, _.setUint16(g, 1, !0), g += 2, _.setUint16(g, h, !0), g += 2, _.setUint32(g, c.sampleRate, !0), g += 4, _.setUint32(g, c.sampleRate * 2 * h, !0), g += 4, _.setUint16(g, h * 2, !0), g += 2, _.setUint16(g, 16, !0), g += 2, a(_, g, "data"), g += 4, _.setUint32(g, c.length * h * 2, !0), g += 4;
  for (let $ = 0; $ < c.numberOfChannels; $++) {
    const b = c.getChannelData($);
    for (let y = 0; y < b.length; y++)
      _.setInt16(g, b[y] * 65535, !0), g += 2;
  }
  return new Uint8Array(u);
}
const process_audio = (c, a, h) => {
  const d = new AudioContext(), u = c.numberOfChannels, _ = c.sampleRate;
  let g = c.length, $ = 0;
  const b = d.createBuffer(u, g, _);
  for (let y = 0; y < u; y++) {
    const v = c.getChannelData(y), E = b.getChannelData(y);
    for (let S = 0; S < g; S++)
      E[S] = v[$ + S];
  }
  return Promise.resolve(audioBufferToWav(b));
}, format_time = (c) => {
  const a = Math.floor(c / 60), d = `0${Math.round(c) % 60}`.slice(-2);
  return `${a}:${d}`;
}, {
  SvelteComponent: SvelteComponent$e,
  append_hydration: append_hydration$7,
  attr: attr$9,
  binding_callbacks: binding_callbacks$6,
  check_outros: check_outros$7,
  children: children$9,
  claim_component: claim_component$b,
  claim_element: claim_element$8,
  claim_space: claim_space$7,
  claim_text: claim_text$7,
  create_component: create_component$b,
  destroy_component: destroy_component$b,
  destroy_each: destroy_each$3,
  detach: detach$b,
  element: element$8,
  empty: empty$4,
  ensure_array_like: ensure_array_like$3,
  group_outros: group_outros$7,
  init: init$e,
  insert_hydration: insert_hydration$b,
  listen: listen$5,
  mount_component: mount_component$b,
  noop: noop$5,
  null_to_empty,
  run_all: run_all$3,
  safe_not_equal: safe_not_equal$e,
  set_data: set_data$7,
  set_input_value: set_input_value$2,
  set_style: set_style$3,
  space: space$7,
  text: text$7,
  toggle_class: toggle_class$5,
  transition_in: transition_in$c,
  transition_out: transition_out$c
} = window.__gradio__svelte__internal, {
  createEventDispatcher: createEventDispatcher$5,
  onMount: onMount$2
} = window.__gradio__svelte__internal;
function get_each_context$3(c, a, h) {
  const d = c.slice();
  return d[25] = a[h], d;
}
function create_else_block_2$1(c) {
  let a, h = (
    /*i18n*/
    c[0]("audio.record") + ""
  ), d, u, _;
  return {
    c() {
      a = element$8("button"), d = text$7(h), this.h();
    },
    l(g) {
      a = claim_element$8(g, "BUTTON", {
        class: !0
      });
      var $ = children$9(a);
      d = claim_text$7($, h), $.forEach(detach$b), this.h();
    },
    h() {
      attr$9(a, "class", "record record-button svelte-gnr7v9");
    },
    m(g, $) {
      insert_hydration$b(g, a, $), append_hydration$7(a, d), u || (_ = listen$5(
        a,
        "click",
        /*click_handler_2*/
        c[15]
      ), u = !0);
    },
    p(g, $) {
      $ & /*i18n*/
      1 && h !== (h = /*i18n*/
      g[0]("audio.record") + "") && set_data$7(d, h);
    },
    i: noop$5,
    o: noop$5,
    d(g) {
      g && detach$b(a), u = !1, _();
    }
  };
}
function create_if_block_1$5(c) {
  let a, h = `${/*i18n*/
  c[0]("audio.stop")} ${format_time(
    /*seconds*/
    c[7]
  )}`, d, u, _, g, $, b, y, v, E, S;
  const R = [create_if_block_2$4, create_else_block_1$2], x = [];
  function H(T, C) {
    return (
      /*paused*/
      T[9] ? 0 : 1
    );
  }
  return $ = H(c), b = x[$] = R[$](c), {
    c() {
      a = element$8("button"), d = text$7(h), _ = space$7(), g = element$8("button"), b.c(), this.h();
    },
    l(T) {
      a = claim_element$8(T, "BUTTON", {
        class: !0
      });
      var C = children$9(a);
      d = claim_text$7(C, h), C.forEach(detach$b), _ = claim_space$7(T), g = claim_element$8(T, "BUTTON", {
        class: !0
      });
      var O = children$9(g);
      b.l(O), O.forEach(detach$b), this.h();
    },
    h() {
      attr$9(a, "class", u = null_to_empty(
        /*paused*/
        c[9] ? "stop-button-paused" : "stop-button"
      ) + " svelte-gnr7v9"), attr$9(g, "class", y = null_to_empty(
        /*paused*/
        c[9] ? "resume-button" : "pause-button"
      ) + " svelte-gnr7v9");
    },
    m(T, C) {
      insert_hydration$b(T, a, C), append_hydration$7(a, d), insert_hydration$b(T, _, C), insert_hydration$b(T, g, C), x[$].m(g, null), v = !0, E || (S = [listen$5(
        a,
        "click",
        /*cleanup*/
        c[11]
      ), listen$5(
        g,
        "click",
        /*click_handler_1*/
        c[14]
      )], E = !0);
    },
    p(T, C) {
      (!v || C & /*i18n, seconds*/
      129) && h !== (h = `${/*i18n*/
      T[0]("audio.stop")} ${format_time(
        /*seconds*/
        T[7]
      )}`) && set_data$7(d, h), (!v || C & /*paused*/
      512 && u !== (u = null_to_empty(
        /*paused*/
        T[9] ? "stop-button-paused" : "stop-button"
      ) + " svelte-gnr7v9")) && attr$9(a, "class", u);
      let O = $;
      $ = H(T), $ === O ? x[$].p(T, C) : (group_outros$7(), transition_out$c(x[O], 1, 1, () => {
        x[O] = null;
      }), check_outros$7(), b = x[$], b ? b.p(T, C) : (b = x[$] = R[$](T), b.c()), transition_in$c(b, 1), b.m(g, null)), (!v || C & /*paused*/
      512 && y !== (y = null_to_empty(
        /*paused*/
        T[9] ? "resume-button" : "pause-button"
      ) + " svelte-gnr7v9")) && attr$9(g, "class", y);
    },
    i(T) {
      v || (transition_in$c(b), v = !0);
    },
    o(T) {
      transition_out$c(b), v = !1;
    },
    d(T) {
      T && (detach$b(a), detach$b(_), detach$b(g)), x[$].d(), E = !1, run_all$3(S);
    }
  };
}
function create_else_block_1$2(c) {
  let a, h;
  return a = new Pause({}), {
    c() {
      create_component$b(a.$$.fragment);
    },
    l(d) {
      claim_component$b(a.$$.fragment, d);
    },
    m(d, u) {
      mount_component$b(a, d, u), h = !0;
    },
    p: noop$5,
    i(d) {
      h || (transition_in$c(a.$$.fragment, d), h = !0);
    },
    o(d) {
      transition_out$c(a.$$.fragment, d), h = !1;
    },
    d(d) {
      destroy_component$b(a, d);
    }
  };
}
function create_if_block_2$4(c) {
  let a = (
    /*i18n*/
    c[0]("audio.resume") + ""
  ), h;
  return {
    c() {
      h = text$7(a);
    },
    l(d) {
      h = claim_text$7(d, a);
    },
    m(d, u) {
      insert_hydration$b(d, h, u);
    },
    p(d, u) {
      u & /*i18n*/
      1 && a !== (a = /*i18n*/
      d[0]("audio.resume") + "") && set_data$7(h, a);
    },
    i: noop$5,
    o: noop$5,
    d(d) {
      d && detach$b(h);
    }
  };
}
function create_else_block$4(c) {
  let a, h = ensure_array_like$3(
    /*micDevices*/
    c[4]
  ), d = [];
  for (let u = 0; u < h.length; u += 1)
    d[u] = create_each_block$3(get_each_context$3(c, h, u));
  return {
    c() {
      for (let u = 0; u < d.length; u += 1)
        d[u].c();
      a = empty$4();
    },
    l(u) {
      for (let _ = 0; _ < d.length; _ += 1)
        d[_].l(u);
      a = empty$4();
    },
    m(u, _) {
      for (let g = 0; g < d.length; g += 1)
        d[g] && d[g].m(u, _);
      insert_hydration$b(u, a, _);
    },
    p(u, _) {
      if (_ & /*micDevices*/
      16) {
        h = ensure_array_like$3(
          /*micDevices*/
          u[4]
        );
        let g;
        for (g = 0; g < h.length; g += 1) {
          const $ = get_each_context$3(u, h, g);
          d[g] ? d[g].p($, _) : (d[g] = create_each_block$3($), d[g].c(), d[g].m(a.parentNode, a));
        }
        for (; g < d.length; g += 1)
          d[g].d(1);
        d.length = h.length;
      }
    },
    d(u) {
      u && detach$b(a), destroy_each$3(d, u);
    }
  };
}
function create_if_block$7(c) {
  let a, h = (
    /*i18n*/
    c[0]("audio.no_microphone") + ""
  ), d;
  return {
    c() {
      a = element$8("option"), d = text$7(h), this.h();
    },
    l(u) {
      a = claim_element$8(u, "OPTION", {});
      var _ = children$9(a);
      d = claim_text$7(_, h), _.forEach(detach$b), this.h();
    },
    h() {
      a.__value = "", set_input_value$2(a, a.__value);
    },
    m(u, _) {
      insert_hydration$b(u, a, _), append_hydration$7(a, d);
    },
    p(u, _) {
      _ & /*i18n*/
      1 && h !== (h = /*i18n*/
      u[0]("audio.no_microphone") + "") && set_data$7(d, h);
    },
    d(u) {
      u && detach$b(a);
    }
  };
}
function create_each_block$3(c) {
  let a, h = (
    /*micDevice*/
    c[25].label + ""
  ), d, u;
  return {
    c() {
      a = element$8("option"), d = text$7(h), this.h();
    },
    l(_) {
      a = claim_element$8(_, "OPTION", {});
      var g = children$9(a);
      d = claim_text$7(g, h), g.forEach(detach$b), this.h();
    },
    h() {
      a.__value = u = /*micDevice*/
      c[25].deviceId, set_input_value$2(a, a.__value);
    },
    m(_, g) {
      insert_hydration$b(_, a, g), append_hydration$7(a, d);
    },
    p(_, g) {
      g & /*micDevices*/
      16 && h !== (h = /*micDevice*/
      _[25].label + "") && set_data$7(d, h), g & /*micDevices*/
      16 && u !== (u = /*micDevice*/
      _[25].deviceId) && (a.__value = u, set_input_value$2(a, a.__value));
    },
    d(_) {
      _ && detach$b(a);
    }
  };
}
function create_fragment$d(c) {
  let a, h, d, u, _, g, $, b, y, v, E, S, R, x, H, T, C, O, j, B, D;
  u = new Microphone({});
  const M = [create_if_block_1$5, create_else_block_2$1], I = [];
  function P(W, V) {
    return (
      /*timing*/
      W[8] ? 0 : 1
    );
  }
  v = P(c), E = I[v] = M[v](c);
  function L(W, V) {
    return (
      /*micDevices*/
      W[4].length === 0 ? create_if_block$7 : create_else_block$4
    );
  }
  let Y = L(c), N = Y(c);
  return C = new RemoveIcon({}), {
    c() {
      a = element$8("div"), h = space$7(), d = element$8("button"), create_component$b(u.$$.fragment), g = space$7(), $ = element$8("div"), b = element$8("div"), y = element$8("div"), E.c(), S = space$7(), R = element$8("select"), N.c(), H = space$7(), T = element$8("button"), create_component$b(C.$$.fragment), this.h();
    },
    l(W) {
      a = claim_element$8(W, "DIV", {
        style: !0
      }), children$9(a).forEach(detach$b), h = claim_space$7(W), d = claim_element$8(W, "BUTTON", {
        style: !0,
        class: !0
      });
      var V = children$9(d);
      claim_component$b(u.$$.fragment, V), V.forEach(detach$b), g = claim_space$7(W), $ = claim_element$8(W, "DIV", {
        style: !0,
        class: !0
      });
      var ue = children$9($);
      b = claim_element$8(ue, "DIV", {
        class: !0
      });
      var se = children$9(b);
      y = claim_element$8(se, "DIV", {
        class: !0
      });
      var ce = children$9(y);
      E.l(ce), ce.forEach(detach$b), S = claim_space$7(se), R = claim_element$8(se, "SELECT", {
        class: !0,
        "aria-label": !0
      });
      var oe = children$9(R);
      N.l(oe), oe.forEach(detach$b), se.forEach(detach$b), H = claim_space$7(ue), T = claim_element$8(ue, "BUTTON", {
        class: !0
      });
      var ge = children$9(T);
      claim_component$b(C.$$.fragment, ge), ge.forEach(detach$b), ue.forEach(detach$b), this.h();
    },
    h() {
      set_style$3(a, "display", "none"), attr$9(d, "style", _ = /*open*/
      c[2] ? "display: none;" : ""), attr$9(d, "class", "icon-button svelte-gnr7v9"), toggle_class$5(
        d,
        "disabled",
        /*disabled*/
        c[1]
      ), attr$9(y, "class", "record-tools svelte-gnr7v9"), attr$9(R, "class", "mic-select svelte-gnr7v9"), attr$9(R, "aria-label", "Select input device"), R.disabled = x = /*micDevices*/
      c[4].length === 0, attr$9(b, "class", "wrapper svelte-gnr7v9"), attr$9(T, "class", "icon-button svelte-gnr7v9"), attr$9($, "style", O = /*open*/
      c[2] ? "" : "display: none;"), attr$9($, "class", "controls svelte-gnr7v9");
    },
    m(W, V) {
      insert_hydration$b(W, a, V), c[12](a), insert_hydration$b(W, h, V), insert_hydration$b(W, d, V), mount_component$b(u, d, null), insert_hydration$b(W, g, V), insert_hydration$b(W, $, V), append_hydration$7($, b), append_hydration$7(b, y), I[v].m(y, null), append_hydration$7(b, S), append_hydration$7(b, R), N.m(R, null), append_hydration$7($, H), append_hydration$7($, T), mount_component$b(C, T, null), j = !0, B || (D = [listen$5(
        d,
        "click",
        /*click_handler*/
        c[13]
      ), listen$5(
        R,
        "change",
        /*change_handler*/
        c[16]
      ), listen$5(
        T,
        "click",
        /*click_handler_3*/
        c[17]
      )], B = !0);
    },
    p(W, [V]) {
      (!j || V & /*open*/
      4 && _ !== (_ = /*open*/
      W[2] ? "display: none;" : "")) && attr$9(d, "style", _), (!j || V & /*disabled*/
      2) && toggle_class$5(
        d,
        "disabled",
        /*disabled*/
        W[1]
      );
      let ue = v;
      v = P(W), v === ue ? I[v].p(W, V) : (group_outros$7(), transition_out$c(I[ue], 1, 1, () => {
        I[ue] = null;
      }), check_outros$7(), E = I[v], E ? E.p(W, V) : (E = I[v] = M[v](W), E.c()), transition_in$c(E, 1), E.m(y, null)), Y === (Y = L(W)) && N ? N.p(W, V) : (N.d(1), N = Y(W), N && (N.c(), N.m(R, null))), (!j || V & /*micDevices*/
      16 && x !== (x = /*micDevices*/
      W[4].length === 0)) && (R.disabled = x), (!j || V & /*open*/
      4 && O !== (O = /*open*/
      W[2] ? "" : "display: none;")) && attr$9($, "style", O);
    },
    i(W) {
      j || (transition_in$c(u.$$.fragment, W), transition_in$c(E), transition_in$c(C.$$.fragment, W), j = !0);
    },
    o(W) {
      transition_out$c(u.$$.fragment, W), transition_out$c(E), transition_out$c(C.$$.fragment, W), j = !1;
    },
    d(W) {
      W && (detach$b(a), detach$b(h), detach$b(d), detach$b(g), detach$b($)), c[12](null), destroy_component$b(u), I[v].d(), N.d(), destroy_component$b(C), B = !1, run_all$3(D);
    }
  };
}
function instance$b(c, a, h) {
  let {
    i18n: d
  } = a, {
    disabled: u = !1
  } = a, _, g = null, $ = [], b, y, v = 0, E, S = !1, R = !1, x = !1;
  const H = createEventDispatcher$5(), {
    upload: T
  } = getContextValue(), C = async (W) => {
    const V = new File(W, "audio.wav", {
      type: "audio/wav"
    }), ue = (await T([V]))[0];
    H("change", ue);
  }, O = () => {
    r.getAvailableAudioDevices().then((W) => {
      h(4, $ = W.filter((V) => V.deviceId));
    });
  };
  O();
  const j = () => {
    clearInterval(E), E = setInterval(() => {
      h(7, v++, v);
    }, 1e3);
  }, B = () => {
    h(7, v = 0), h(8, S = !1), h(9, R = !1), clearInterval(E), g != null && g.isPaused() && (g == null || g.resumeRecording()), g == null || g.stopRecording();
  }, D = () => {
    _ && _.destroy(), b && (h(5, b.innerHTML = "", b), _ = WaveSurfer.create({
      normalize: !1,
      container: b
    }), h(3, g = _.registerPlugin(r.create())), g.on("record-start", () => {
      g == null || g.startMic(), $.length === 0 && O(), j(), h(9, R = !1), h(8, S = !0);
    }), g.on("record-pause", () => {
      h(9, R = !0), clearInterval(E);
    }), g.on("record-end", async (W) => {
      if (g != null && g.isPaused() && (g.resumeRecording(), g.stopRecording()), g == null || g.stopMic(), !x)
        return;
      const V = await W.arrayBuffer(), se = await new AudioContext().decodeAudioData(V);
      se && await process_audio(se).then((ce) => {
        C([ce]);
      });
    }), g.on("record-resume", () => {
      h(9, R = !1), j();
    }));
  };
  onMount$2(() => {
    D();
  });
  function M(W) {
    binding_callbacks$6[W ? "unshift" : "push"](() => {
      b = W, h(5, b);
    });
  }
  const I = () => {
    u || h(2, x = !0);
  }, P = () => {
    g != null && g.isPaused() ? g == null || g.resumeRecording() : g == null || g.pauseRecording();
  }, L = () => g == null ? void 0 : g.startRecording({
    deviceId: y
  }).catch(() => {
    H("error", d("audio.allow_recording_access"));
  }), Y = (W) => {
    h(6, y = W.currentTarget.value);
  }, N = () => {
    h(2, x = !1);
  };
  return c.$$set = (W) => {
    "i18n" in W && h(0, d = W.i18n), "disabled" in W && h(1, u = W.disabled);
  }, c.$$.update = () => {
    c.$$.dirty & /*disabled*/
    2 && u && h(2, x = !1), c.$$.dirty & /*open*/
    4 && (x || B());
  }, [d, u, x, g, $, b, y, v, S, R, H, B, M, I, P, L, Y, N];
}
class AudioRecorder extends SvelteComponent$e {
  constructor(a) {
    super(), init$e(this, a, instance$b, create_fragment$d, safe_not_equal$e, {
      i18n: 0,
      disabled: 1
    });
  }
}
function getDefaultExportFromCjs(c) {
  return c && c.__esModule && Object.prototype.hasOwnProperty.call(c, "default") ? c.default : c;
}
function getAugmentedNamespace(c) {
  if (c.__esModule) return c;
  var a = c.default;
  if (typeof a == "function") {
    var h = function d() {
      return this instanceof d ? Reflect.construct(a, arguments, this.constructor) : a.apply(this, arguments);
    };
    h.prototype = a.prototype;
  } else h = {};
  return Object.defineProperty(h, "__esModule", {
    value: !0
  }), Object.keys(c).forEach(function(d) {
    var u = Object.getOwnPropertyDescriptor(c, d);
    Object.defineProperty(h, d, u.get ? u : {
      enumerable: !0,
      get: function() {
        return c[d];
      }
    });
  }), h;
}
var jsxRuntime = {
  exports: {}
}, reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f = React, k = Symbol.for("react.element"), l = Symbol.for("react.fragment"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = {
  key: !0,
  ref: !0,
  __self: !0,
  __source: !0
};
function q(c, a, h) {
  var d, u = {}, _ = null, g = null;
  h !== void 0 && (_ = "" + h), a.key !== void 0 && (_ = "" + a.key), a.ref !== void 0 && (g = a.ref);
  for (d in a) m.call(a, d) && !p.hasOwnProperty(d) && (u[d] = a[d]);
  if (c && c.defaultProps) for (d in a = c.defaultProps, a) u[d] === void 0 && (u[d] = a[d]);
  return {
    $$typeof: k,
    type: c,
    key: _,
    ref: g,
    props: u,
    _owner: n.current
  };
}
reactJsxRuntime_production_min.Fragment = l;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
jsxRuntime.exports = reactJsxRuntime_production_min;
var jsxRuntimeExports = jsxRuntime.exports;
function defineComponent(c) {
  return c;
}
function usePreview() {
  const [c, a] = useState(!1);
  return useEffect(() => {
    c ? document.body.classList.add("ms-preview-container") : document.body.classList.remove("ms-preview-container");
  }, [c]), {
    visible: c,
    onVisibleChange: (h) => {
      a(h);
    }
  };
}
function commonjsRequire(c) {
  throw new Error('Could not dynamically require "' + c + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var pdf = {
  exports: {}
};
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, {
  value: "Module"
})), require$$5 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module, exports) {
  (function(a, h) {
    module.exports = a.pdfjsLib = h();
  })(globalThis, () => (
    /******/
    (() => {
      var __webpack_modules__ = [
        ,
        /* 1 */
        /***/
        (c, a) => {
          var dt;
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.VerbosityLevel = a.Util = a.UnknownErrorException = a.UnexpectedResponseException = a.TextRenderingMode = a.RenderingIntentFlag = a.PromiseCapability = a.PermissionFlag = a.PasswordResponses = a.PasswordException = a.PageActionEventType = a.OPS = a.MissingPDFException = a.MAX_IMAGE_SIZE_TO_CACHE = a.LINE_FACTOR = a.LINE_DESCENT_FACTOR = a.InvalidPDFException = a.ImageKind = a.IDENTITY_MATRIX = a.FormatError = a.FeatureTest = a.FONT_IDENTITY_MATRIX = a.DocumentActionEventType = a.CMapCompressionType = a.BaseException = a.BASELINE_FACTOR = a.AnnotationType = a.AnnotationReplyType = a.AnnotationPrefix = a.AnnotationMode = a.AnnotationFlag = a.AnnotationFieldFlag = a.AnnotationEditorType = a.AnnotationEditorPrefix = a.AnnotationEditorParamsType = a.AnnotationBorderStyleType = a.AnnotationActionEventType = a.AbortException = void 0, a.assert = J, a.bytesToString = Te, a.createValidAbsoluteUrl = le, a.getModificationDate = Be, a.getUuid = et, a.getVerbosityLevel = se, a.info = ce, a.isArrayBuffer = fe, a.isArrayEqual = He, a.isNodeJS = void 0, a.normalizeUnicode = Ve, a.objectFromMap = Fe, a.objectSize = Me, a.setVerbosityLevel = ue, a.shadow = z, a.string32 = Re, a.stringToBytes = Pe, a.stringToPDFString = xe, a.stringToUTF8String = Le, a.unreachable = ge, a.utf8StringToString = Ie, a.warn = oe;
          const h = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
          a.isNodeJS = h;
          const d = [1, 0, 0, 1, 0, 0];
          a.IDENTITY_MATRIX = d;
          const u = [1e-3, 0, 0, 1e-3, 0, 0];
          a.FONT_IDENTITY_MATRIX = u;
          const _ = 1e7;
          a.MAX_IMAGE_SIZE_TO_CACHE = _;
          const g = 1.35;
          a.LINE_FACTOR = g;
          const $ = 0.35;
          a.LINE_DESCENT_FACTOR = $;
          const b = $ / g;
          a.BASELINE_FACTOR = b;
          const y = {
            ANY: 1,
            DISPLAY: 2,
            PRINT: 4,
            SAVE: 8,
            ANNOTATIONS_FORMS: 16,
            ANNOTATIONS_STORAGE: 32,
            ANNOTATIONS_DISABLE: 64,
            OPLIST: 256
          };
          a.RenderingIntentFlag = y;
          const v = {
            DISABLE: 0,
            ENABLE: 1,
            ENABLE_FORMS: 2,
            ENABLE_STORAGE: 3
          };
          a.AnnotationMode = v;
          const E = "pdfjs_internal_editor_";
          a.AnnotationEditorPrefix = E;
          const S = {
            DISABLE: -1,
            NONE: 0,
            FREETEXT: 3,
            STAMP: 13,
            INK: 15
          };
          a.AnnotationEditorType = S;
          const R = {
            RESIZE: 1,
            CREATE: 2,
            FREETEXT_SIZE: 11,
            FREETEXT_COLOR: 12,
            FREETEXT_OPACITY: 13,
            INK_COLOR: 21,
            INK_THICKNESS: 22,
            INK_OPACITY: 23
          };
          a.AnnotationEditorParamsType = R;
          const x = {
            PRINT: 4,
            MODIFY_CONTENTS: 8,
            COPY: 16,
            MODIFY_ANNOTATIONS: 32,
            FILL_INTERACTIVE_FORMS: 256,
            COPY_FOR_ACCESSIBILITY: 512,
            ASSEMBLE: 1024,
            PRINT_HIGH_QUALITY: 2048
          };
          a.PermissionFlag = x;
          const H = {
            FILL: 0,
            STROKE: 1,
            FILL_STROKE: 2,
            INVISIBLE: 3,
            FILL_ADD_TO_PATH: 4,
            STROKE_ADD_TO_PATH: 5,
            FILL_STROKE_ADD_TO_PATH: 6,
            ADD_TO_PATH: 7,
            FILL_STROKE_MASK: 3,
            ADD_TO_PATH_FLAG: 4
          };
          a.TextRenderingMode = H;
          const T = {
            GRAYSCALE_1BPP: 1,
            RGB_24BPP: 2,
            RGBA_32BPP: 3
          };
          a.ImageKind = T;
          const C = {
            TEXT: 1,
            LINK: 2,
            FREETEXT: 3,
            LINE: 4,
            SQUARE: 5,
            CIRCLE: 6,
            POLYGON: 7,
            POLYLINE: 8,
            HIGHLIGHT: 9,
            UNDERLINE: 10,
            SQUIGGLY: 11,
            STRIKEOUT: 12,
            STAMP: 13,
            CARET: 14,
            INK: 15,
            POPUP: 16,
            FILEATTACHMENT: 17,
            SOUND: 18,
            MOVIE: 19,
            WIDGET: 20,
            SCREEN: 21,
            PRINTERMARK: 22,
            TRAPNET: 23,
            WATERMARK: 24,
            THREED: 25,
            REDACT: 26
          };
          a.AnnotationType = C;
          const O = {
            GROUP: "Group",
            REPLY: "R"
          };
          a.AnnotationReplyType = O;
          const j = {
            INVISIBLE: 1,
            HIDDEN: 2,
            PRINT: 4,
            NOZOOM: 8,
            NOROTATE: 16,
            NOVIEW: 32,
            READONLY: 64,
            LOCKED: 128,
            TOGGLENOVIEW: 256,
            LOCKEDCONTENTS: 512
          };
          a.AnnotationFlag = j;
          const B = {
            READONLY: 1,
            REQUIRED: 2,
            NOEXPORT: 4,
            MULTILINE: 4096,
            PASSWORD: 8192,
            NOTOGGLETOOFF: 16384,
            RADIO: 32768,
            PUSHBUTTON: 65536,
            COMBO: 131072,
            EDIT: 262144,
            SORT: 524288,
            FILESELECT: 1048576,
            MULTISELECT: 2097152,
            DONOTSPELLCHECK: 4194304,
            DONOTSCROLL: 8388608,
            COMB: 16777216,
            RICHTEXT: 33554432,
            RADIOSINUNISON: 33554432,
            COMMITONSELCHANGE: 67108864
          };
          a.AnnotationFieldFlag = B;
          const D = {
            SOLID: 1,
            DASHED: 2,
            BEVELED: 3,
            INSET: 4,
            UNDERLINE: 5
          };
          a.AnnotationBorderStyleType = D;
          const M = {
            E: "Mouse Enter",
            X: "Mouse Exit",
            D: "Mouse Down",
            U: "Mouse Up",
            Fo: "Focus",
            Bl: "Blur",
            PO: "PageOpen",
            PC: "PageClose",
            PV: "PageVisible",
            PI: "PageInvisible",
            K: "Keystroke",
            F: "Format",
            V: "Validate",
            C: "Calculate"
          };
          a.AnnotationActionEventType = M;
          const I = {
            WC: "WillClose",
            WS: "WillSave",
            DS: "DidSave",
            WP: "WillPrint",
            DP: "DidPrint"
          };
          a.DocumentActionEventType = I;
          const P = {
            O: "PageOpen",
            C: "PageClose"
          };
          a.PageActionEventType = P;
          const L = {
            ERRORS: 0,
            WARNINGS: 1,
            INFOS: 5
          };
          a.VerbosityLevel = L;
          const Y = {
            NONE: 0,
            BINARY: 1
          };
          a.CMapCompressionType = Y;
          const N = {
            dependency: 1,
            setLineWidth: 2,
            setLineCap: 3,
            setLineJoin: 4,
            setMiterLimit: 5,
            setDash: 6,
            setRenderingIntent: 7,
            setFlatness: 8,
            setGState: 9,
            save: 10,
            restore: 11,
            transform: 12,
            moveTo: 13,
            lineTo: 14,
            curveTo: 15,
            curveTo2: 16,
            curveTo3: 17,
            closePath: 18,
            rectangle: 19,
            stroke: 20,
            closeStroke: 21,
            fill: 22,
            eoFill: 23,
            fillStroke: 24,
            eoFillStroke: 25,
            closeFillStroke: 26,
            closeEOFillStroke: 27,
            endPath: 28,
            clip: 29,
            eoClip: 30,
            beginText: 31,
            endText: 32,
            setCharSpacing: 33,
            setWordSpacing: 34,
            setHScale: 35,
            setLeading: 36,
            setFont: 37,
            setTextRenderingMode: 38,
            setTextRise: 39,
            moveText: 40,
            setLeadingMoveText: 41,
            setTextMatrix: 42,
            nextLine: 43,
            showText: 44,
            showSpacedText: 45,
            nextLineShowText: 46,
            nextLineSetSpacingShowText: 47,
            setCharWidth: 48,
            setCharWidthAndBounds: 49,
            setStrokeColorSpace: 50,
            setFillColorSpace: 51,
            setStrokeColor: 52,
            setStrokeColorN: 53,
            setFillColor: 54,
            setFillColorN: 55,
            setStrokeGray: 56,
            setFillGray: 57,
            setStrokeRGBColor: 58,
            setFillRGBColor: 59,
            setStrokeCMYKColor: 60,
            setFillCMYKColor: 61,
            shadingFill: 62,
            beginInlineImage: 63,
            beginImageData: 64,
            endInlineImage: 65,
            paintXObject: 66,
            markPoint: 67,
            markPointProps: 68,
            beginMarkedContent: 69,
            beginMarkedContentProps: 70,
            endMarkedContent: 71,
            beginCompat: 72,
            endCompat: 73,
            paintFormXObjectBegin: 74,
            paintFormXObjectEnd: 75,
            beginGroup: 76,
            endGroup: 77,
            beginAnnotation: 80,
            endAnnotation: 81,
            paintImageMaskXObject: 83,
            paintImageMaskXObjectGroup: 84,
            paintImageXObject: 85,
            paintInlineImageXObject: 86,
            paintInlineImageXObjectGroup: 87,
            paintImageXObjectRepeat: 88,
            paintImageMaskXObjectRepeat: 89,
            paintSolidColorImageMask: 90,
            constructPath: 91
          };
          a.OPS = N;
          const W = {
            NEED_PASSWORD: 1,
            INCORRECT_PASSWORD: 2
          };
          a.PasswordResponses = W;
          let V = L.WARNINGS;
          function ue(De) {
            Number.isInteger(De) && (V = De);
          }
          function se() {
            return V;
          }
          function ce(De) {
            V >= L.INFOS && console.log(`Info: ${De}`);
          }
          function oe(De) {
            V >= L.WARNINGS && console.log(`Warning: ${De}`);
          }
          function ge(De) {
            throw new Error(De);
          }
          function J(De, $e) {
            De || ge($e);
          }
          function ae(De) {
            switch (De == null ? void 0 : De.protocol) {
              case "http:":
              case "https:":
              case "ftp:":
              case "mailto:":
              case "tel:":
                return !0;
              default:
                return !1;
            }
          }
          function le(De, $e = null, we = null) {
            if (!De)
              return null;
            try {
              if (we && typeof De == "string") {
                if (we.addDefaultProtocol && De.startsWith("www.")) {
                  const at = De.match(/\./g);
                  (at == null ? void 0 : at.length) >= 2 && (De = `http://${De}`);
                }
                if (we.tryConvertEncoding)
                  try {
                    De = Le(De);
                  } catch {
                  }
              }
              const ze = $e ? new URL(De, $e) : new URL(De);
              if (ae(ze))
                return ze;
            } catch {
            }
            return null;
          }
          function z(De, $e, we, ze = !1) {
            return Object.defineProperty(De, $e, {
              value: we,
              enumerable: !ze,
              configurable: !0,
              writable: !1
            }), we;
          }
          const A = function() {
            function $e(we, ze) {
              this.constructor === $e && ge("Cannot initialize BaseException."), this.message = we, this.name = ze;
            }
            return $e.prototype = new Error(), $e.constructor = $e, $e;
          }();
          a.BaseException = A;
          class F extends A {
            constructor($e, we) {
              super($e, "PasswordException"), this.code = we;
            }
          }
          a.PasswordException = F;
          class U extends A {
            constructor($e, we) {
              super($e, "UnknownErrorException"), this.details = we;
            }
          }
          a.UnknownErrorException = U;
          class Z extends A {
            constructor($e) {
              super($e, "InvalidPDFException");
            }
          }
          a.InvalidPDFException = Z;
          class G extends A {
            constructor($e) {
              super($e, "MissingPDFException");
            }
          }
          a.MissingPDFException = G;
          class Q extends A {
            constructor($e, we) {
              super($e, "UnexpectedResponseException"), this.status = we;
            }
          }
          a.UnexpectedResponseException = Q;
          class he extends A {
            constructor($e) {
              super($e, "FormatError");
            }
          }
          a.FormatError = he;
          class me extends A {
            constructor($e) {
              super($e, "AbortException");
            }
          }
          a.AbortException = me;
          function Te(De) {
            (typeof De != "object" || (De == null ? void 0 : De.length) === void 0) && ge("Invalid argument for bytesToString");
            const $e = De.length, we = 8192;
            if ($e < we)
              return String.fromCharCode.apply(null, De);
            const ze = [];
            for (let at = 0; at < $e; at += we) {
              const ct = Math.min(at + we, $e), ie = De.subarray(at, ct);
              ze.push(String.fromCharCode.apply(null, ie));
            }
            return ze.join("");
          }
          function Pe(De) {
            typeof De != "string" && ge("Invalid argument for stringToBytes");
            const $e = De.length, we = new Uint8Array($e);
            for (let ze = 0; ze < $e; ++ze)
              we[ze] = De.charCodeAt(ze) & 255;
            return we;
          }
          function Re(De) {
            return String.fromCharCode(De >> 24 & 255, De >> 16 & 255, De >> 8 & 255, De & 255);
          }
          function Me(De) {
            return Object.keys(De).length;
          }
          function Fe(De) {
            const $e = /* @__PURE__ */ Object.create(null);
            for (const [we, ze] of De)
              $e[we] = ze;
            return $e;
          }
          function ve() {
            const De = new Uint8Array(4);
            return De[0] = 1, new Uint32Array(De.buffer, 0, 1)[0] === 1;
          }
          function be() {
            try {
              return new Function(""), !0;
            } catch {
              return !1;
            }
          }
          class X {
            static get isLittleEndian() {
              return z(this, "isLittleEndian", ve());
            }
            static get isEvalSupported() {
              return z(this, "isEvalSupported", be());
            }
            static get isOffscreenCanvasSupported() {
              return z(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u");
            }
            static get platform() {
              return typeof navigator > "u" ? z(this, "platform", {
                isWin: !1,
                isMac: !1
              }) : z(this, "platform", {
                isWin: navigator.platform.includes("Win"),
                isMac: navigator.platform.includes("Mac")
              });
            }
            static get isCSSRoundSupported() {
              var $e, we;
              return z(this, "isCSSRoundSupported", (we = ($e = globalThis.CSS) == null ? void 0 : $e.supports) == null ? void 0 : we.call($e, "width: round(1.5px, 1px)"));
            }
          }
          a.FeatureTest = X;
          const ne = [...Array(256).keys()].map((De) => De.toString(16).padStart(2, "0"));
          class te {
            static makeHexColor($e, we, ze) {
              return `#${ne[$e]}${ne[we]}${ne[ze]}`;
            }
            static scaleMinMax($e, we) {
              let ze;
              $e[0] ? ($e[0] < 0 && (ze = we[0], we[0] = we[1], we[1] = ze), we[0] *= $e[0], we[1] *= $e[0], $e[3] < 0 && (ze = we[2], we[2] = we[3], we[3] = ze), we[2] *= $e[3], we[3] *= $e[3]) : (ze = we[0], we[0] = we[2], we[2] = ze, ze = we[1], we[1] = we[3], we[3] = ze, $e[1] < 0 && (ze = we[2], we[2] = we[3], we[3] = ze), we[2] *= $e[1], we[3] *= $e[1], $e[2] < 0 && (ze = we[0], we[0] = we[1], we[1] = ze), we[0] *= $e[2], we[1] *= $e[2]), we[0] += $e[4], we[1] += $e[4], we[2] += $e[5], we[3] += $e[5];
            }
            static transform($e, we) {
              return [$e[0] * we[0] + $e[2] * we[1], $e[1] * we[0] + $e[3] * we[1], $e[0] * we[2] + $e[2] * we[3], $e[1] * we[2] + $e[3] * we[3], $e[0] * we[4] + $e[2] * we[5] + $e[4], $e[1] * we[4] + $e[3] * we[5] + $e[5]];
            }
            static applyTransform($e, we) {
              const ze = $e[0] * we[0] + $e[1] * we[2] + we[4], at = $e[0] * we[1] + $e[1] * we[3] + we[5];
              return [ze, at];
            }
            static applyInverseTransform($e, we) {
              const ze = we[0] * we[3] - we[1] * we[2], at = ($e[0] * we[3] - $e[1] * we[2] + we[2] * we[5] - we[4] * we[3]) / ze, ct = (-$e[0] * we[1] + $e[1] * we[0] + we[4] * we[1] - we[5] * we[0]) / ze;
              return [at, ct];
            }
            static getAxialAlignedBoundingBox($e, we) {
              const ze = this.applyTransform($e, we), at = this.applyTransform($e.slice(2, 4), we), ct = this.applyTransform([$e[0], $e[3]], we), ie = this.applyTransform([$e[2], $e[1]], we);
              return [Math.min(ze[0], at[0], ct[0], ie[0]), Math.min(ze[1], at[1], ct[1], ie[1]), Math.max(ze[0], at[0], ct[0], ie[0]), Math.max(ze[1], at[1], ct[1], ie[1])];
            }
            static inverseTransform($e) {
              const we = $e[0] * $e[3] - $e[1] * $e[2];
              return [$e[3] / we, -$e[1] / we, -$e[2] / we, $e[0] / we, ($e[2] * $e[5] - $e[4] * $e[3]) / we, ($e[4] * $e[1] - $e[5] * $e[0]) / we];
            }
            static singularValueDecompose2dScale($e) {
              const we = [$e[0], $e[2], $e[1], $e[3]], ze = $e[0] * we[0] + $e[1] * we[2], at = $e[0] * we[1] + $e[1] * we[3], ct = $e[2] * we[0] + $e[3] * we[2], ie = $e[2] * we[1] + $e[3] * we[3], Ce = (ze + ie) / 2, Ue = Math.sqrt((ze + ie) ** 2 - 4 * (ze * ie - ct * at)) / 2, Ze = Ce + Ue || 1, Qe = Ce - Ue || 1;
              return [Math.sqrt(Ze), Math.sqrt(Qe)];
            }
            static normalizeRect($e) {
              const we = $e.slice(0);
              return $e[0] > $e[2] && (we[0] = $e[2], we[2] = $e[0]), $e[1] > $e[3] && (we[1] = $e[3], we[3] = $e[1]), we;
            }
            static intersect($e, we) {
              const ze = Math.max(Math.min($e[0], $e[2]), Math.min(we[0], we[2])), at = Math.min(Math.max($e[0], $e[2]), Math.max(we[0], we[2]));
              if (ze > at)
                return null;
              const ct = Math.max(Math.min($e[1], $e[3]), Math.min(we[1], we[3])), ie = Math.min(Math.max($e[1], $e[3]), Math.max(we[1], we[3]));
              return ct > ie ? null : [ze, ct, at, ie];
            }
            static bezierBoundingBox($e, we, ze, at, ct, ie, Ce, Ue) {
              const Ze = [], Qe = [[], []];
              let We, ee, K, de, Ae, ke, Oe, Ne;
              for (let rt = 0; rt < 2; ++rt) {
                if (rt === 0 ? (ee = 6 * $e - 12 * ze + 6 * ct, We = -3 * $e + 9 * ze - 9 * ct + 3 * Ce, K = 3 * ze - 3 * $e) : (ee = 6 * we - 12 * at + 6 * ie, We = -3 * we + 9 * at - 9 * ie + 3 * Ue, K = 3 * at - 3 * we), Math.abs(We) < 1e-12) {
                  if (Math.abs(ee) < 1e-12)
                    continue;
                  de = -K / ee, 0 < de && de < 1 && Ze.push(de);
                  continue;
                }
                Oe = ee * ee - 4 * K * We, Ne = Math.sqrt(Oe), !(Oe < 0) && (Ae = (-ee + Ne) / (2 * We), 0 < Ae && Ae < 1 && Ze.push(Ae), ke = (-ee - Ne) / (2 * We), 0 < ke && ke < 1 && Ze.push(ke));
              }
              let Xe = Ze.length, Ye;
              const qe = Xe;
              for (; Xe--; )
                de = Ze[Xe], Ye = 1 - de, Qe[0][Xe] = Ye * Ye * Ye * $e + 3 * Ye * Ye * de * ze + 3 * Ye * de * de * ct + de * de * de * Ce, Qe[1][Xe] = Ye * Ye * Ye * we + 3 * Ye * Ye * de * at + 3 * Ye * de * de * ie + de * de * de * Ue;
              return Qe[0][qe] = $e, Qe[1][qe] = we, Qe[0][qe + 1] = Ce, Qe[1][qe + 1] = Ue, Qe[0].length = Qe[1].length = qe + 2, [Math.min(...Qe[0]), Math.min(...Qe[1]), Math.max(...Qe[0]), Math.max(...Qe[1])];
            }
          }
          a.Util = te;
          const ye = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364];
          function xe(De) {
            if (De[0] >= "ï") {
              let we;
              if (De[0] === "þ" && De[1] === "ÿ" ? we = "utf-16be" : De[0] === "ÿ" && De[1] === "þ" ? we = "utf-16le" : De[0] === "ï" && De[1] === "»" && De[2] === "¿" && (we = "utf-8"), we)
                try {
                  const ze = new TextDecoder(we, {
                    fatal: !0
                  }), at = Pe(De);
                  return ze.decode(at);
                } catch (ze) {
                  oe(`stringToPDFString: "${ze}".`);
                }
            }
            const $e = [];
            for (let we = 0, ze = De.length; we < ze; we++) {
              const at = ye[De.charCodeAt(we)];
              $e.push(at ? String.fromCharCode(at) : De.charAt(we));
            }
            return $e.join("");
          }
          function Le(De) {
            return decodeURIComponent(escape(De));
          }
          function Ie(De) {
            return unescape(encodeURIComponent(De));
          }
          function fe(De) {
            return typeof De == "object" && (De == null ? void 0 : De.byteLength) !== void 0;
          }
          function He(De, $e) {
            if (De.length !== $e.length)
              return !1;
            for (let we = 0, ze = De.length; we < ze; we++)
              if (De[we] !== $e[we])
                return !1;
            return !0;
          }
          function Be(De = /* @__PURE__ */ new Date()) {
            return [De.getUTCFullYear().toString(), (De.getUTCMonth() + 1).toString().padStart(2, "0"), De.getUTCDate().toString().padStart(2, "0"), De.getUTCHours().toString().padStart(2, "0"), De.getUTCMinutes().toString().padStart(2, "0"), De.getUTCSeconds().toString().padStart(2, "0")].join("");
          }
          class st {
            constructor() {
              Ee(this, dt, !1);
              this.promise = new Promise(($e, we) => {
                this.resolve = (ze) => {
                  Se(this, dt, !0), $e(ze);
                }, this.reject = (ze) => {
                  Se(this, dt, !0), we(ze);
                };
              });
            }
            get settled() {
              return w(this, dt);
            }
          }
          dt = new WeakMap(), a.PromiseCapability = st;
          let nt = null, ht = null;
          function Ve(De) {
            return nt || (nt = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, ht = /* @__PURE__ */ new Map([["ﬅ", "ſt"]])), De.replaceAll(nt, ($e, we, ze) => we ? we.normalize("NFKC") : ht.get(ze));
          }
          function et() {
            if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.randomUUID) == "function")
              return crypto.randomUUID();
            const De = new Uint8Array(32);
            if (typeof crypto < "u" && typeof (crypto == null ? void 0 : crypto.getRandomValues) == "function")
              crypto.getRandomValues(De);
            else
              for (let $e = 0; $e < 32; $e++)
                De[$e] = Math.floor(Math.random() * 255);
            return Te(De);
          }
          const lt = "pdfjs_internal_id_";
          a.AnnotationPrefix = lt;
        },
        /* 2 */
        /***/
        (__unused_webpack_module, exports, __w_pdfjs_require__) => {
          var c, h, d, u, Ct, Ut, $, b, y, v, E, S, R, x, H, Ht, C, O, tn, B, D;
          Object.defineProperty(exports, "__esModule", {
            value: !0
          }), exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0, Object.defineProperty(exports, "SVGGraphics", {
            enumerable: !0,
            get: function() {
              return _displaySvg.SVGGraphics;
            }
          }), exports.build = void 0, exports.getDocument = getDocument, exports.version = void 0;
          var _util = __w_pdfjs_require__(1), _annotation_storage = __w_pdfjs_require__(3), _display_utils = __w_pdfjs_require__(6), _font_loader = __w_pdfjs_require__(9), _displayNode_utils = __w_pdfjs_require__(10), _canvas = __w_pdfjs_require__(11), _worker_options = __w_pdfjs_require__(14), _message_handler = __w_pdfjs_require__(15), _metadata = __w_pdfjs_require__(16), _optional_content_config = __w_pdfjs_require__(17), _transport_stream = __w_pdfjs_require__(18), _displayFetch_stream = __w_pdfjs_require__(19), _displayNetwork = __w_pdfjs_require__(22), _displayNode_stream = __w_pdfjs_require__(23), _displaySvg = __w_pdfjs_require__(24), _xfa_text = __w_pdfjs_require__(25);
          const DEFAULT_RANGE_CHUNK_SIZE = 65536, RENDERING_CANCELLED_TIMEOUT = 100, DELAYED_CLEANUP_TIMEOUT = 5e3, DefaultCanvasFactory = _util.isNodeJS ? _displayNode_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;
          exports.DefaultCanvasFactory = DefaultCanvasFactory;
          const DefaultCMapReaderFactory = _util.isNodeJS ? _displayNode_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;
          exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;
          const DefaultFilterFactory = _util.isNodeJS ? _displayNode_utils.NodeFilterFactory : _display_utils.DOMFilterFactory;
          exports.DefaultFilterFactory = DefaultFilterFactory;
          const DefaultStandardFontDataFactory = _util.isNodeJS ? _displayNode_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;
          exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;
          function getDocument(I) {
            if (typeof I == "string" || I instanceof URL ? I = {
              url: I
            } : (0, _util.isArrayBuffer)(I) && (I = {
              data: I
            }), typeof I != "object")
              throw new Error("Invalid parameter in getDocument, need parameter object.");
            if (!I.url && !I.data && !I.range)
              throw new Error("Invalid parameter object: need either .data, .range or .url");
            const P = new PDFDocumentLoadingTask(), {
              docId: L
            } = P, Y = I.url ? getUrlProp(I.url) : null, N = I.data ? getDataProp(I.data) : null, W = I.httpHeaders || null, V = I.withCredentials === !0, ue = I.password ?? null, se = I.range instanceof PDFDataRangeTransport ? I.range : null, ce = Number.isInteger(I.rangeChunkSize) && I.rangeChunkSize > 0 ? I.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;
            let oe = I.worker instanceof PDFWorker ? I.worker : null;
            const ge = I.verbosity, J = typeof I.docBaseUrl == "string" && !(0, _display_utils.isDataScheme)(I.docBaseUrl) ? I.docBaseUrl : null, ae = typeof I.cMapUrl == "string" ? I.cMapUrl : null, le = I.cMapPacked !== !1, z = I.CMapReaderFactory || DefaultCMapReaderFactory, A = typeof I.standardFontDataUrl == "string" ? I.standardFontDataUrl : null, F = I.StandardFontDataFactory || DefaultStandardFontDataFactory, U = I.stopAtErrors !== !0, Z = Number.isInteger(I.maxImageSize) && I.maxImageSize > -1 ? I.maxImageSize : -1, G = I.isEvalSupported !== !1, Q = typeof I.isOffscreenCanvasSupported == "boolean" ? I.isOffscreenCanvasSupported : !_util.isNodeJS, he = Number.isInteger(I.canvasMaxAreaInBytes) ? I.canvasMaxAreaInBytes : -1, me = typeof I.disableFontFace == "boolean" ? I.disableFontFace : _util.isNodeJS, Te = I.fontExtraProperties === !0, Pe = I.enableXfa === !0, Re = I.ownerDocument || globalThis.document, Me = I.disableRange === !0, Fe = I.disableStream === !0, ve = I.disableAutoFetch === !0, be = I.pdfBug === !0, X = se ? se.length : I.length ?? NaN, ne = typeof I.useSystemFonts == "boolean" ? I.useSystemFonts : !_util.isNodeJS && !me, te = typeof I.useWorkerFetch == "boolean" ? I.useWorkerFetch : z === _display_utils.DOMCMapReaderFactory && F === _display_utils.DOMStandardFontDataFactory && ae && A && (0, _display_utils.isValidFetchUrl)(ae, document.baseURI) && (0, _display_utils.isValidFetchUrl)(A, document.baseURI), ye = I.canvasFactory || new DefaultCanvasFactory({
              ownerDocument: Re
            }), xe = I.filterFactory || new DefaultFilterFactory({
              docId: L,
              ownerDocument: Re
            }), Le = null;
            (0, _util.setVerbosityLevel)(ge);
            const Ie = {
              canvasFactory: ye,
              filterFactory: xe
            };
            if (te || (Ie.cMapReaderFactory = new z({
              baseUrl: ae,
              isCompressed: le
            }), Ie.standardFontDataFactory = new F({
              baseUrl: A
            })), !oe) {
              const Be = {
                verbosity: ge,
                port: _worker_options.GlobalWorkerOptions.workerPort
              };
              oe = Be.port ? PDFWorker.fromPort(Be) : new PDFWorker(Be), P._worker = oe;
            }
            const fe = {
              docId: L,
              apiVersion: "3.11.174",
              data: N,
              password: ue,
              disableAutoFetch: ve,
              rangeChunkSize: ce,
              length: X,
              docBaseUrl: J,
              enableXfa: Pe,
              evaluatorOptions: {
                maxImageSize: Z,
                disableFontFace: me,
                ignoreErrors: U,
                isEvalSupported: G,
                isOffscreenCanvasSupported: Q,
                canvasMaxAreaInBytes: he,
                fontExtraProperties: Te,
                useSystemFonts: ne,
                cMapUrl: te ? ae : null,
                standardFontDataUrl: te ? A : null
              }
            }, He = {
              ignoreErrors: U,
              isEvalSupported: G,
              disableFontFace: me,
              fontExtraProperties: Te,
              enableXfa: Pe,
              ownerDocument: Re,
              disableAutoFetch: ve,
              pdfBug: be,
              styleElement: Le
            };
            return oe.promise.then(function() {
              if (P.destroyed)
                throw new Error("Loading aborted");
              const Be = _fetchDocument(oe, fe), st = new Promise(function(nt) {
                let ht;
                se ? ht = new _transport_stream.PDFDataTransportStream({
                  length: X,
                  initialData: se.initialData,
                  progressiveDone: se.progressiveDone,
                  contentDispositionFilename: se.contentDispositionFilename,
                  disableRange: Me,
                  disableStream: Fe
                }, se) : N || (ht = ((et) => _util.isNodeJS ? new _displayNode_stream.PDFNodeStream(et) : (0, _display_utils.isValidFetchUrl)(et.url) ? new _displayFetch_stream.PDFFetchStream(et) : new _displayNetwork.PDFNetworkStream(et))({
                  url: Y,
                  length: X,
                  httpHeaders: W,
                  withCredentials: V,
                  rangeChunkSize: ce,
                  disableRange: Me,
                  disableStream: Fe
                })), nt(ht);
              });
              return Promise.all([Be, st]).then(function([nt, ht]) {
                if (P.destroyed)
                  throw new Error("Loading aborted");
                const Ve = new _message_handler.MessageHandler(L, nt, oe.port), et = new WorkerTransport(Ve, P, ht, He, Ie);
                P._transport = et, Ve.send("Ready", null);
              });
            }).catch(P._capability.reject), P;
          }
          async function _fetchDocument(I, P) {
            if (I.destroyed)
              throw new Error("Worker was destroyed");
            const L = await I.messageHandler.sendWithPromise("GetDocRequest", P, P.data ? [P.data.buffer] : null);
            if (I.destroyed)
              throw new Error("Worker was destroyed");
            return L;
          }
          function getUrlProp(I) {
            if (I instanceof URL)
              return I.href;
            try {
              return new URL(I, window.location).href;
            } catch {
              if (_util.isNodeJS && typeof I == "string")
                return I;
            }
            throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
          }
          function getDataProp(I) {
            if (_util.isNodeJS && typeof Buffer < "u" && I instanceof Buffer)
              throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
            if (I instanceof Uint8Array && I.byteLength === I.buffer.byteLength)
              return I;
            if (typeof I == "string")
              return (0, _util.stringToBytes)(I);
            if (typeof I == "object" && !isNaN(I == null ? void 0 : I.length) || (0, _util.isArrayBuffer)(I))
              return new Uint8Array(I);
            throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
          }
          const a = class a {
            constructor() {
              this._capability = new _util.PromiseCapability(), this._transport = null, this._worker = null, this.docId = `d${Mt(a, c)._++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null;
            }
            get promise() {
              return this._capability.promise;
            }
            async destroy() {
              var P, L, Y;
              this.destroyed = !0;
              try {
                (P = this._worker) != null && P.port && (this._worker._pendingDestroy = !0), await ((L = this._transport) == null ? void 0 : L.destroy());
              } catch (N) {
                throw (Y = this._worker) != null && Y.port && delete this._worker._pendingDestroy, N;
              }
              this._transport = null, this._worker && (this._worker.destroy(), this._worker = null);
            }
          };
          c = new WeakMap(), Ee(a, c, 0);
          let PDFDocumentLoadingTask = a;
          exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;
          class PDFDataRangeTransport {
            constructor(P, L, Y = !1, N = null) {
              this.length = P, this.initialData = L, this.progressiveDone = Y, this.contentDispositionFilename = N, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = new _util.PromiseCapability();
            }
            addRangeListener(P) {
              this._rangeListeners.push(P);
            }
            addProgressListener(P) {
              this._progressListeners.push(P);
            }
            addProgressiveReadListener(P) {
              this._progressiveReadListeners.push(P);
            }
            addProgressiveDoneListener(P) {
              this._progressiveDoneListeners.push(P);
            }
            onDataRange(P, L) {
              for (const Y of this._rangeListeners)
                Y(P, L);
            }
            onDataProgress(P, L) {
              this._readyCapability.promise.then(() => {
                for (const Y of this._progressListeners)
                  Y(P, L);
              });
            }
            onDataProgressiveRead(P) {
              this._readyCapability.promise.then(() => {
                for (const L of this._progressiveReadListeners)
                  L(P);
              });
            }
            onDataProgressiveDone() {
              this._readyCapability.promise.then(() => {
                for (const P of this._progressiveDoneListeners)
                  P();
              });
            }
            transportReady() {
              this._readyCapability.resolve();
            }
            requestDataRange(P, L) {
              (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange");
            }
            abort() {
            }
          }
          exports.PDFDataRangeTransport = PDFDataRangeTransport;
          class PDFDocumentProxy {
            constructor(P, L) {
              this._pdfInfo = P, this._transport = L, Object.defineProperty(this, "getJavaScript", {
                value: () => ((0, _display_utils.deprecated)("`PDFDocumentProxy.getJavaScript`, please use `PDFDocumentProxy.getJSActions` instead."), this.getJSActions().then((Y) => {
                  if (!Y)
                    return Y;
                  const N = [];
                  for (const W in Y)
                    N.push(...Y[W]);
                  return N;
                }))
              });
            }
            get annotationStorage() {
              return this._transport.annotationStorage;
            }
            get filterFactory() {
              return this._transport.filterFactory;
            }
            get numPages() {
              return this._pdfInfo.numPages;
            }
            get fingerprints() {
              return this._pdfInfo.fingerprints;
            }
            get isPureXfa() {
              return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
            }
            get allXfaHtml() {
              return this._transport._htmlForXfa;
            }
            getPage(P) {
              return this._transport.getPage(P);
            }
            getPageIndex(P) {
              return this._transport.getPageIndex(P);
            }
            getDestinations() {
              return this._transport.getDestinations();
            }
            getDestination(P) {
              return this._transport.getDestination(P);
            }
            getPageLabels() {
              return this._transport.getPageLabels();
            }
            getPageLayout() {
              return this._transport.getPageLayout();
            }
            getPageMode() {
              return this._transport.getPageMode();
            }
            getViewerPreferences() {
              return this._transport.getViewerPreferences();
            }
            getOpenAction() {
              return this._transport.getOpenAction();
            }
            getAttachments() {
              return this._transport.getAttachments();
            }
            getJSActions() {
              return this._transport.getDocJSActions();
            }
            getOutline() {
              return this._transport.getOutline();
            }
            getOptionalContentConfig() {
              return this._transport.getOptionalContentConfig();
            }
            getPermissions() {
              return this._transport.getPermissions();
            }
            getMetadata() {
              return this._transport.getMetadata();
            }
            getMarkInfo() {
              return this._transport.getMarkInfo();
            }
            getData() {
              return this._transport.getData();
            }
            saveDocument() {
              return this._transport.saveDocument();
            }
            getDownloadInfo() {
              return this._transport.downloadInfoCapability.promise;
            }
            cleanup(P = !1) {
              return this._transport.startCleanup(P || this.isPureXfa);
            }
            destroy() {
              return this.loadingTask.destroy();
            }
            get loadingParams() {
              return this._transport.loadingParams;
            }
            get loadingTask() {
              return this._transport.loadingTask;
            }
            getFieldObjects() {
              return this._transport.getFieldObjects();
            }
            hasJSActions() {
              return this._transport.hasJSActions();
            }
            getCalculationOrderIds() {
              return this._transport.getCalculationOrderIds();
            }
          }
          exports.PDFDocumentProxy = PDFDocumentProxy;
          class PDFPageProxy {
            constructor(P, L, Y, N = !1) {
              Ee(this, u);
              Ee(this, h, null);
              Ee(this, d, !1);
              this._pageIndex = P, this._pageInfo = L, this._transport = Y, this._stats = N ? new _display_utils.StatTimer() : null, this._pdfBug = N, this.commonObjs = Y.commonObjs, this.objs = new PDFObjects(), this._maybeCleanupAfterRender = !1, this._intentStates = /* @__PURE__ */ new Map(), this.destroyed = !1;
            }
            get pageNumber() {
              return this._pageIndex + 1;
            }
            get rotate() {
              return this._pageInfo.rotate;
            }
            get ref() {
              return this._pageInfo.ref;
            }
            get userUnit() {
              return this._pageInfo.userUnit;
            }
            get view() {
              return this._pageInfo.view;
            }
            getViewport({
              scale: P,
              rotation: L = this.rotate,
              offsetX: Y = 0,
              offsetY: N = 0,
              dontFlip: W = !1
            } = {}) {
              return new _display_utils.PageViewport({
                viewBox: this.view,
                scale: P,
                rotation: L,
                offsetX: Y,
                offsetY: N,
                dontFlip: W
              });
            }
            getAnnotations({
              intent: P = "display"
            } = {}) {
              const L = this._transport.getRenderingIntent(P);
              return this._transport.getAnnotations(this._pageIndex, L.renderingIntent);
            }
            getJSActions() {
              return this._transport.getPageJSActions(this._pageIndex);
            }
            get filterFactory() {
              return this._transport.filterFactory;
            }
            get isPureXfa() {
              return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa);
            }
            async getXfa() {
              var P;
              return ((P = this._transport._htmlForXfa) == null ? void 0 : P.children[this._pageIndex]) || null;
            }
            render({
              canvasContext: P,
              viewport: L,
              intent: Y = "display",
              annotationMode: N = _util.AnnotationMode.ENABLE,
              transform: W = null,
              background: V = null,
              optionalContentConfigPromise: ue = null,
              annotationCanvasMap: se = null,
              pageColors: ce = null,
              printAnnotationStorage: oe = null
            }) {
              var F, U;
              (F = this._stats) == null || F.time("Overall");
              const ge = this._transport.getRenderingIntent(Y, N, oe);
              Se(this, d, !1), _e(this, u, Ut).call(this), ue || (ue = this._transport.getOptionalContentConfig());
              let J = this._intentStates.get(ge.cacheKey);
              J || (J = /* @__PURE__ */ Object.create(null), this._intentStates.set(ge.cacheKey, J)), J.streamReaderCancelTimeout && (clearTimeout(J.streamReaderCancelTimeout), J.streamReaderCancelTimeout = null);
              const ae = !!(ge.renderingIntent & _util.RenderingIntentFlag.PRINT);
              J.displayReadyCapability || (J.displayReadyCapability = new _util.PromiseCapability(), J.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: !1,
                separateAnnots: null
              }, (U = this._stats) == null || U.time("Page Request"), this._pumpOperatorList(ge));
              const le = (Z) => {
                var G, Q;
                J.renderTasks.delete(z), (this._maybeCleanupAfterRender || ae) && Se(this, d, !0), _e(this, u, Ct).call(this, !ae), Z ? (z.capability.reject(Z), this._abortOperatorList({
                  intentState: J,
                  reason: Z instanceof Error ? Z : new Error(Z)
                })) : z.capability.resolve(), (G = this._stats) == null || G.timeEnd("Rendering"), (Q = this._stats) == null || Q.timeEnd("Overall");
              }, z = new InternalRenderTask({
                callback: le,
                params: {
                  canvasContext: P,
                  viewport: L,
                  transform: W,
                  background: V
                },
                objs: this.objs,
                commonObjs: this.commonObjs,
                annotationCanvasMap: se,
                operatorList: J.operatorList,
                pageIndex: this._pageIndex,
                canvasFactory: this._transport.canvasFactory,
                filterFactory: this._transport.filterFactory,
                useRequestAnimationFrame: !ae,
                pdfBug: this._pdfBug,
                pageColors: ce
              });
              (J.renderTasks || (J.renderTasks = /* @__PURE__ */ new Set())).add(z);
              const A = z.task;
              return Promise.all([J.displayReadyCapability.promise, ue]).then(([Z, G]) => {
                var Q;
                if (this.destroyed) {
                  le();
                  return;
                }
                (Q = this._stats) == null || Q.time("Rendering"), z.initializeGraphics({
                  transparency: Z,
                  optionalContentConfig: G
                }), z.operatorListChanged();
              }).catch(le), A;
            }
            getOperatorList({
              intent: P = "display",
              annotationMode: L = _util.AnnotationMode.ENABLE,
              printAnnotationStorage: Y = null
            } = {}) {
              var se;
              function N() {
                V.operatorList.lastChunk && (V.opListReadCapability.resolve(V.operatorList), V.renderTasks.delete(ue));
              }
              const W = this._transport.getRenderingIntent(P, L, Y, !0);
              let V = this._intentStates.get(W.cacheKey);
              V || (V = /* @__PURE__ */ Object.create(null), this._intentStates.set(W.cacheKey, V));
              let ue;
              return V.opListReadCapability || (ue = /* @__PURE__ */ Object.create(null), ue.operatorListChanged = N, V.opListReadCapability = new _util.PromiseCapability(), (V.renderTasks || (V.renderTasks = /* @__PURE__ */ new Set())).add(ue), V.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: !1,
                separateAnnots: null
              }, (se = this._stats) == null || se.time("Page Request"), this._pumpOperatorList(W)), V.opListReadCapability.promise;
            }
            streamTextContent({
              includeMarkedContent: P = !1,
              disableNormalization: L = !1
            } = {}) {
              return this._transport.messageHandler.sendWithStream("GetTextContent", {
                pageIndex: this._pageIndex,
                includeMarkedContent: P === !0,
                disableNormalization: L === !0
              }, {
                highWaterMark: 100,
                size(N) {
                  return N.items.length;
                }
              });
            }
            getTextContent(P = {}) {
              if (this._transport._htmlForXfa)
                return this.getXfa().then((Y) => _xfa_text.XfaText.textContent(Y));
              const L = this.streamTextContent(P);
              return new Promise(function(Y, N) {
                function W() {
                  V.read().then(function({
                    value: se,
                    done: ce
                  }) {
                    if (ce) {
                      Y(ue);
                      return;
                    }
                    Object.assign(ue.styles, se.styles), ue.items.push(...se.items), W();
                  }, N);
                }
                const V = L.getReader(), ue = {
                  items: [],
                  styles: /* @__PURE__ */ Object.create(null)
                };
                W();
              });
            }
            getStructTree() {
              return this._transport.getStructTree(this._pageIndex);
            }
            _destroy() {
              this.destroyed = !0;
              const P = [];
              for (const L of this._intentStates.values())
                if (this._abortOperatorList({
                  intentState: L,
                  reason: new Error("Page was destroyed."),
                  force: !0
                }), !L.opListReadCapability)
                  for (const Y of L.renderTasks)
                    P.push(Y.completed), Y.cancel();
              return this.objs.clear(), Se(this, d, !1), _e(this, u, Ut).call(this), Promise.all(P);
            }
            cleanup(P = !1) {
              Se(this, d, !0);
              const L = _e(this, u, Ct).call(this, !1);
              return P && L && this._stats && (this._stats = new _display_utils.StatTimer()), L;
            }
            _startRenderPage(P, L) {
              var N, W;
              const Y = this._intentStates.get(L);
              Y && ((N = this._stats) == null || N.timeEnd("Page Request"), (W = Y.displayReadyCapability) == null || W.resolve(P));
            }
            _renderPageChunk(P, L) {
              for (let Y = 0, N = P.length; Y < N; Y++)
                L.operatorList.fnArray.push(P.fnArray[Y]), L.operatorList.argsArray.push(P.argsArray[Y]);
              L.operatorList.lastChunk = P.lastChunk, L.operatorList.separateAnnots = P.separateAnnots;
              for (const Y of L.renderTasks)
                Y.operatorListChanged();
              P.lastChunk && _e(this, u, Ct).call(this, !0);
            }
            _pumpOperatorList({
              renderingIntent: P,
              cacheKey: L,
              annotationStorageSerializable: Y
            }) {
              const {
                map: N,
                transfers: W
              } = Y, ue = this._transport.messageHandler.sendWithStream("GetOperatorList", {
                pageIndex: this._pageIndex,
                intent: P,
                cacheKey: L,
                annotationStorage: N
              }, W).getReader(), se = this._intentStates.get(L);
              se.streamReader = ue;
              const ce = () => {
                ue.read().then(({
                  value: oe,
                  done: ge
                }) => {
                  if (ge) {
                    se.streamReader = null;
                    return;
                  }
                  this._transport.destroyed || (this._renderPageChunk(oe, se), ce());
                }, (oe) => {
                  if (se.streamReader = null, !this._transport.destroyed) {
                    if (se.operatorList) {
                      se.operatorList.lastChunk = !0;
                      for (const ge of se.renderTasks)
                        ge.operatorListChanged();
                      _e(this, u, Ct).call(this, !0);
                    }
                    if (se.displayReadyCapability)
                      se.displayReadyCapability.reject(oe);
                    else if (se.opListReadCapability)
                      se.opListReadCapability.reject(oe);
                    else
                      throw oe;
                  }
                });
              };
              ce();
            }
            _abortOperatorList({
              intentState: P,
              reason: L,
              force: Y = !1
            }) {
              if (P.streamReader) {
                if (P.streamReaderCancelTimeout && (clearTimeout(P.streamReaderCancelTimeout), P.streamReaderCancelTimeout = null), !Y) {
                  if (P.renderTasks.size > 0)
                    return;
                  if (L instanceof _display_utils.RenderingCancelledException) {
                    let N = RENDERING_CANCELLED_TIMEOUT;
                    L.extraDelay > 0 && L.extraDelay < 1e3 && (N += L.extraDelay), P.streamReaderCancelTimeout = setTimeout(() => {
                      P.streamReaderCancelTimeout = null, this._abortOperatorList({
                        intentState: P,
                        reason: L,
                        force: !0
                      });
                    }, N);
                    return;
                  }
                }
                if (P.streamReader.cancel(new _util.AbortException(L.message)).catch(() => {
                }), P.streamReader = null, !this._transport.destroyed) {
                  for (const [N, W] of this._intentStates)
                    if (W === P) {
                      this._intentStates.delete(N);
                      break;
                    }
                  this.cleanup();
                }
              }
            }
            get stats() {
              return this._stats;
            }
          }
          h = new WeakMap(), d = new WeakMap(), u = new WeakSet(), Ct = function(P = !1) {
            if (_e(this, u, Ut).call(this), !w(this, d) || this.destroyed)
              return !1;
            if (P)
              return Se(this, h, setTimeout(() => {
                Se(this, h, null), _e(this, u, Ct).call(this, !1);
              }, DELAYED_CLEANUP_TIMEOUT)), !1;
            for (const {
              renderTasks: L,
              operatorList: Y
            } of this._intentStates.values())
              if (L.size > 0 || !Y.lastChunk)
                return !1;
            return this._intentStates.clear(), this.objs.clear(), Se(this, d, !1), !0;
          }, Ut = function() {
            w(this, h) && (clearTimeout(w(this, h)), Se(this, h, null));
          }, exports.PDFPageProxy = PDFPageProxy;
          class LoopbackPort {
            constructor() {
              Ee(this, $, /* @__PURE__ */ new Set());
              Ee(this, b, Promise.resolve());
            }
            postMessage(P, L) {
              const Y = {
                data: structuredClone(P, L ? {
                  transfer: L
                } : null)
              };
              w(this, b).then(() => {
                for (const N of w(this, $))
                  N.call(this, Y);
              });
            }
            addEventListener(P, L) {
              w(this, $).add(L);
            }
            removeEventListener(P, L) {
              w(this, $).delete(L);
            }
            terminate() {
              w(this, $).clear();
            }
          }
          $ = new WeakMap(), b = new WeakMap(), exports.LoopbackPort = LoopbackPort;
          const PDFWorkerUtil = {
            isWorkerDisabled: !1,
            fallbackWorkerSrc: null,
            fakeWorkerId: 0
          };
          exports.PDFWorkerUtil = PDFWorkerUtil;
          {
            if (_util.isNodeJS && typeof commonjsRequire == "function")
              PDFWorkerUtil.isWorkerDisabled = !0, PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js";
            else if (typeof document == "object") {
              const I = (y = document == null ? void 0 : document.currentScript) == null ? void 0 : y.src;
              I && (PDFWorkerUtil.fallbackWorkerSrc = I.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2"));
            }
            PDFWorkerUtil.isSameOrigin = function(I, P) {
              let L;
              try {
                if (L = new URL(I), !L.origin || L.origin === "null")
                  return !1;
              } catch {
                return !1;
              }
              const Y = new URL(P, L);
              return L.origin === Y.origin;
            }, PDFWorkerUtil.createCDNWrapper = function(I) {
              const P = `importScripts("${I}");`;
              return URL.createObjectURL(new Blob([P]));
            };
          }
          const _PDFWorker = class _PDFWorker {
            constructor({
              name: I = null,
              port: P = null,
              verbosity: L = (0, _util.getVerbosityLevel)()
            } = {}) {
              var Y;
              if (this.name = I, this.destroyed = !1, this.verbosity = L, this._readyCapability = new _util.PromiseCapability(), this._port = null, this._webWorker = null, this._messageHandler = null, P) {
                if ((Y = w(_PDFWorker, v)) != null && Y.has(P))
                  throw new Error("Cannot use more than one PDFWorker per port.");
                (w(_PDFWorker, v) || Se(_PDFWorker, v, /* @__PURE__ */ new WeakMap())).set(P, this), this._initializeFromPort(P);
                return;
              }
              this._initialize();
            }
            get promise() {
              return this._readyCapability.promise;
            }
            get port() {
              return this._port;
            }
            get messageHandler() {
              return this._messageHandler;
            }
            _initializeFromPort(I) {
              this._port = I, this._messageHandler = new _message_handler.MessageHandler("main", "worker", I), this._messageHandler.on("ready", function() {
              }), this._readyCapability.resolve(), this._messageHandler.send("configure", {
                verbosity: this.verbosity
              });
            }
            _initialize() {
              if (!PDFWorkerUtil.isWorkerDisabled && !_PDFWorker._mainThreadWorkerMessageHandler) {
                let {
                  workerSrc: I
                } = _PDFWorker;
                try {
                  PDFWorkerUtil.isSameOrigin(window.location.href, I) || (I = PDFWorkerUtil.createCDNWrapper(new URL(I, window.location).href));
                  const P = new Worker(I), L = new _message_handler.MessageHandler("main", "worker", P), Y = () => {
                    P.removeEventListener("error", N), L.destroy(), P.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker();
                  }, N = () => {
                    this._webWorker || Y();
                  };
                  P.addEventListener("error", N), L.on("test", (V) => {
                    if (P.removeEventListener("error", N), this.destroyed) {
                      Y();
                      return;
                    }
                    V ? (this._messageHandler = L, this._port = P, this._webWorker = P, this._readyCapability.resolve(), L.send("configure", {
                      verbosity: this.verbosity
                    })) : (this._setupFakeWorker(), L.destroy(), P.terminate());
                  }), L.on("ready", (V) => {
                    if (P.removeEventListener("error", N), this.destroyed) {
                      Y();
                      return;
                    }
                    try {
                      W();
                    } catch {
                      this._setupFakeWorker();
                    }
                  });
                  const W = () => {
                    const V = new Uint8Array();
                    L.send("test", V, [V.buffer]);
                  };
                  W();
                  return;
                } catch {
                  (0, _util.info)("The worker has been disabled.");
                }
              }
              this._setupFakeWorker();
            }
            _setupFakeWorker() {
              PDFWorkerUtil.isWorkerDisabled || ((0, _util.warn)("Setting up fake worker."), PDFWorkerUtil.isWorkerDisabled = !0), _PDFWorker._setupFakeWorkerGlobal.then((I) => {
                if (this.destroyed) {
                  this._readyCapability.reject(new Error("Worker was destroyed"));
                  return;
                }
                const P = new LoopbackPort();
                this._port = P;
                const L = `fake${PDFWorkerUtil.fakeWorkerId++}`, Y = new _message_handler.MessageHandler(L + "_worker", L, P);
                I.setup(Y, P);
                const N = new _message_handler.MessageHandler(L, L + "_worker", P);
                this._messageHandler = N, this._readyCapability.resolve(), N.send("configure", {
                  verbosity: this.verbosity
                });
              }).catch((I) => {
                this._readyCapability.reject(new Error(`Setting up fake worker failed: "${I.message}".`));
              });
            }
            destroy() {
              var I;
              this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), (I = w(_PDFWorker, v)) == null || I.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null);
            }
            static fromPort(I) {
              var L;
              if (!(I != null && I.port))
                throw new Error("PDFWorker.fromPort - invalid method signature.");
              const P = (L = w(this, v)) == null ? void 0 : L.get(I.port);
              if (P) {
                if (P._pendingDestroy)
                  throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
                return P;
              }
              return new _PDFWorker(I);
            }
            static get workerSrc() {
              if (_worker_options.GlobalWorkerOptions.workerSrc)
                return _worker_options.GlobalWorkerOptions.workerSrc;
              if (PDFWorkerUtil.fallbackWorkerSrc !== null)
                return _util.isNodeJS || (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.'), PDFWorkerUtil.fallbackWorkerSrc;
              throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
            }
            static get _mainThreadWorkerMessageHandler() {
              var I;
              try {
                return ((I = globalThis.pdfjsWorker) == null ? void 0 : I.WorkerMessageHandler) || null;
              } catch {
                return null;
              }
            }
            static get _setupFakeWorkerGlobal() {
              const loader = async () => {
                const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;
                if (mainWorkerMessageHandler)
                  return mainWorkerMessageHandler;
                if (_util.isNodeJS && typeof commonjsRequire == "function") {
                  const worker = eval("require")(this.workerSrc);
                  return worker.WorkerMessageHandler;
                }
                return await (0, _display_utils.loadScript)(this.workerSrc), window.pdfjsWorker.WorkerMessageHandler;
              };
              return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader());
            }
          };
          v = new WeakMap(), Ee(_PDFWorker, v);
          let PDFWorker = _PDFWorker;
          exports.PDFWorker = PDFWorker;
          class WorkerTransport {
            constructor(P, L, Y, N, W) {
              Ee(this, H);
              Ee(this, E, /* @__PURE__ */ new Map());
              Ee(this, S, /* @__PURE__ */ new Map());
              Ee(this, R, /* @__PURE__ */ new Map());
              Ee(this, x, null);
              this.messageHandler = P, this.loadingTask = L, this.commonObjs = new PDFObjects(), this.fontLoader = new _font_loader.FontLoader({
                ownerDocument: N.ownerDocument,
                styleElement: N.styleElement
              }), this._params = N, this.canvasFactory = W.canvasFactory, this.filterFactory = W.filterFactory, this.cMapReaderFactory = W.cMapReaderFactory, this.standardFontDataFactory = W.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = Y, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = new _util.PromiseCapability(), this.setupMessageHandler();
            }
            get annotationStorage() {
              return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage());
            }
            getRenderingIntent(P, L = _util.AnnotationMode.ENABLE, Y = null, N = !1) {
              let W = _util.RenderingIntentFlag.DISPLAY, V = _annotation_storage.SerializableEmpty;
              switch (P) {
                case "any":
                  W = _util.RenderingIntentFlag.ANY;
                  break;
                case "display":
                  break;
                case "print":
                  W = _util.RenderingIntentFlag.PRINT;
                  break;
                default:
                  (0, _util.warn)(`getRenderingIntent - invalid intent: ${P}`);
              }
              switch (L) {
                case _util.AnnotationMode.DISABLE:
                  W += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;
                  break;
                case _util.AnnotationMode.ENABLE:
                  break;
                case _util.AnnotationMode.ENABLE_FORMS:
                  W += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;
                  break;
                case _util.AnnotationMode.ENABLE_STORAGE:
                  W += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE, V = (W & _util.RenderingIntentFlag.PRINT && Y instanceof _annotation_storage.PrintAnnotationStorage ? Y : this.annotationStorage).serializable;
                  break;
                default:
                  (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${L}`);
              }
              return N && (W += _util.RenderingIntentFlag.OPLIST), {
                renderingIntent: W,
                cacheKey: `${W}_${V.hash}`,
                annotationStorageSerializable: V
              };
            }
            destroy() {
              var Y;
              if (this.destroyCapability)
                return this.destroyCapability.promise;
              this.destroyed = !0, this.destroyCapability = new _util.PromiseCapability(), (Y = w(this, x)) == null || Y.reject(new Error("Worker was destroyed during onPassword callback"));
              const P = [];
              for (const N of w(this, S).values())
                P.push(N._destroy());
              w(this, S).clear(), w(this, R).clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified();
              const L = this.messageHandler.sendWithPromise("Terminate", null);
              return P.push(L), Promise.all(P).then(() => {
                var N;
                this.commonObjs.clear(), this.fontLoader.clear(), w(this, E).clear(), this.filterFactory.destroy(), (N = this._networkStream) == null || N.cancelAllRequests(new _util.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve();
              }, this.destroyCapability.reject), this.destroyCapability.promise;
            }
            setupMessageHandler() {
              const {
                messageHandler: P,
                loadingTask: L
              } = this;
              P.on("GetReader", (Y, N) => {
                (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = (W) => {
                  this._lastProgress = {
                    loaded: W.loaded,
                    total: W.total
                  };
                }, N.onPull = () => {
                  this._fullReader.read().then(function({
                    value: W,
                    done: V
                  }) {
                    if (V) {
                      N.close();
                      return;
                    }
                    (0, _util.assert)(W instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), N.enqueue(new Uint8Array(W), 1, [W]);
                  }).catch((W) => {
                    N.error(W);
                  });
                }, N.onCancel = (W) => {
                  this._fullReader.cancel(W), N.ready.catch((V) => {
                    if (!this.destroyed)
                      throw V;
                  });
                };
              }), P.on("ReaderHeadersReady", (Y) => {
                const N = new _util.PromiseCapability(), W = this._fullReader;
                return W.headersReady.then(() => {
                  var V;
                  (!W.isStreamingSupported || !W.isRangeSupported) && (this._lastProgress && ((V = L.onProgress) == null || V.call(L, this._lastProgress)), W.onProgress = (ue) => {
                    var se;
                    (se = L.onProgress) == null || se.call(L, {
                      loaded: ue.loaded,
                      total: ue.total
                    });
                  }), N.resolve({
                    isStreamingSupported: W.isStreamingSupported,
                    isRangeSupported: W.isRangeSupported,
                    contentLength: W.contentLength
                  });
                }, N.reject), N.promise;
              }), P.on("GetRangeReader", (Y, N) => {
                (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
                const W = this._networkStream.getRangeReader(Y.begin, Y.end);
                if (!W) {
                  N.close();
                  return;
                }
                N.onPull = () => {
                  W.read().then(function({
                    value: V,
                    done: ue
                  }) {
                    if (ue) {
                      N.close();
                      return;
                    }
                    (0, _util.assert)(V instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), N.enqueue(new Uint8Array(V), 1, [V]);
                  }).catch((V) => {
                    N.error(V);
                  });
                }, N.onCancel = (V) => {
                  W.cancel(V), N.ready.catch((ue) => {
                    if (!this.destroyed)
                      throw ue;
                  });
                };
              }), P.on("GetDoc", ({
                pdfInfo: Y
              }) => {
                this._numPages = Y.numPages, this._htmlForXfa = Y.htmlForXfa, delete Y.htmlForXfa, L._capability.resolve(new PDFDocumentProxy(Y, this));
              }), P.on("DocException", function(Y) {
                let N;
                switch (Y.name) {
                  case "PasswordException":
                    N = new _util.PasswordException(Y.message, Y.code);
                    break;
                  case "InvalidPDFException":
                    N = new _util.InvalidPDFException(Y.message);
                    break;
                  case "MissingPDFException":
                    N = new _util.MissingPDFException(Y.message);
                    break;
                  case "UnexpectedResponseException":
                    N = new _util.UnexpectedResponseException(Y.message, Y.status);
                    break;
                  case "UnknownErrorException":
                    N = new _util.UnknownErrorException(Y.message, Y.details);
                    break;
                  default:
                    (0, _util.unreachable)("DocException - expected a valid Error.");
                }
                L._capability.reject(N);
              }), P.on("PasswordRequest", (Y) => {
                if (Se(this, x, new _util.PromiseCapability()), L.onPassword) {
                  const N = (W) => {
                    W instanceof Error ? w(this, x).reject(W) : w(this, x).resolve({
                      password: W
                    });
                  };
                  try {
                    L.onPassword(N, Y.code);
                  } catch (W) {
                    w(this, x).reject(W);
                  }
                } else
                  w(this, x).reject(new _util.PasswordException(Y.message, Y.code));
                return w(this, x).promise;
              }), P.on("DataLoaded", (Y) => {
                var N;
                (N = L.onProgress) == null || N.call(L, {
                  loaded: Y.length,
                  total: Y.length
                }), this.downloadInfoCapability.resolve(Y);
              }), P.on("StartRenderPage", (Y) => {
                if (this.destroyed)
                  return;
                w(this, S).get(Y.pageIndex)._startRenderPage(Y.transparency, Y.cacheKey);
              }), P.on("commonobj", ([Y, N, W]) => {
                var V;
                if (!this.destroyed && !this.commonObjs.has(Y))
                  switch (N) {
                    case "Font":
                      const ue = this._params;
                      if ("error" in W) {
                        const oe = W.error;
                        (0, _util.warn)(`Error during font loading: ${oe}`), this.commonObjs.resolve(Y, oe);
                        break;
                      }
                      const se = ue.pdfBug && ((V = globalThis.FontInspector) != null && V.enabled) ? (oe, ge) => globalThis.FontInspector.fontAdded(oe, ge) : null, ce = new _font_loader.FontFaceObject(W, {
                        isEvalSupported: ue.isEvalSupported,
                        disableFontFace: ue.disableFontFace,
                        ignoreErrors: ue.ignoreErrors,
                        inspectFont: se
                      });
                      this.fontLoader.bind(ce).catch((oe) => P.sendWithPromise("FontFallback", {
                        id: Y
                      })).finally(() => {
                        !ue.fontExtraProperties && ce.data && (ce.data = null), this.commonObjs.resolve(Y, ce);
                      });
                      break;
                    case "FontPath":
                    case "Image":
                    case "Pattern":
                      this.commonObjs.resolve(Y, W);
                      break;
                    default:
                      throw new Error(`Got unknown common object type ${N}`);
                  }
              }), P.on("obj", ([Y, N, W, V]) => {
                var se;
                if (this.destroyed)
                  return;
                const ue = w(this, S).get(N);
                if (!ue.objs.has(Y))
                  switch (W) {
                    case "Image":
                      if (ue.objs.resolve(Y, V), V) {
                        let ce;
                        if (V.bitmap) {
                          const {
                            width: oe,
                            height: ge
                          } = V;
                          ce = oe * ge * 4;
                        } else
                          ce = ((se = V.data) == null ? void 0 : se.length) || 0;
                        ce > _util.MAX_IMAGE_SIZE_TO_CACHE && (ue._maybeCleanupAfterRender = !0);
                      }
                      break;
                    case "Pattern":
                      ue.objs.resolve(Y, V);
                      break;
                    default:
                      throw new Error(`Got unknown object type ${W}`);
                  }
              }), P.on("DocProgress", (Y) => {
                var N;
                this.destroyed || (N = L.onProgress) == null || N.call(L, {
                  loaded: Y.loaded,
                  total: Y.total
                });
              }), P.on("FetchBuiltInCMap", (Y) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(Y) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), P.on("FetchStandardFontData", (Y) => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(Y) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.")));
            }
            getData() {
              return this.messageHandler.sendWithPromise("GetData", null);
            }
            saveDocument() {
              var Y;
              this.annotationStorage.size <= 0 && (0, _util.warn)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
              const {
                map: P,
                transfers: L
              } = this.annotationStorage.serializable;
              return this.messageHandler.sendWithPromise("SaveDocument", {
                isPureXfa: !!this._htmlForXfa,
                numPages: this._numPages,
                annotationStorage: P,
                filename: ((Y = this._fullReader) == null ? void 0 : Y.filename) ?? null
              }, L).finally(() => {
                this.annotationStorage.resetModified();
              });
            }
            getPage(P) {
              if (!Number.isInteger(P) || P <= 0 || P > this._numPages)
                return Promise.reject(new Error("Invalid page request."));
              const L = P - 1, Y = w(this, R).get(L);
              if (Y)
                return Y;
              const N = this.messageHandler.sendWithPromise("GetPage", {
                pageIndex: L
              }).then((W) => {
                if (this.destroyed)
                  throw new Error("Transport destroyed");
                const V = new PDFPageProxy(L, W, this, this._params.pdfBug);
                return w(this, S).set(L, V), V;
              });
              return w(this, R).set(L, N), N;
            }
            getPageIndex(P) {
              return typeof P != "object" || P === null || !Number.isInteger(P.num) || P.num < 0 || !Number.isInteger(P.gen) || P.gen < 0 ? Promise.reject(new Error("Invalid pageIndex request.")) : this.messageHandler.sendWithPromise("GetPageIndex", {
                num: P.num,
                gen: P.gen
              });
            }
            getAnnotations(P, L) {
              return this.messageHandler.sendWithPromise("GetAnnotations", {
                pageIndex: P,
                intent: L
              });
            }
            getFieldObjects() {
              return _e(this, H, Ht).call(this, "GetFieldObjects");
            }
            hasJSActions() {
              return _e(this, H, Ht).call(this, "HasJSActions");
            }
            getCalculationOrderIds() {
              return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
            }
            getDestinations() {
              return this.messageHandler.sendWithPromise("GetDestinations", null);
            }
            getDestination(P) {
              return typeof P != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", {
                id: P
              });
            }
            getPageLabels() {
              return this.messageHandler.sendWithPromise("GetPageLabels", null);
            }
            getPageLayout() {
              return this.messageHandler.sendWithPromise("GetPageLayout", null);
            }
            getPageMode() {
              return this.messageHandler.sendWithPromise("GetPageMode", null);
            }
            getViewerPreferences() {
              return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
            }
            getOpenAction() {
              return this.messageHandler.sendWithPromise("GetOpenAction", null);
            }
            getAttachments() {
              return this.messageHandler.sendWithPromise("GetAttachments", null);
            }
            getDocJSActions() {
              return _e(this, H, Ht).call(this, "GetDocJSActions");
            }
            getPageJSActions(P) {
              return this.messageHandler.sendWithPromise("GetPageJSActions", {
                pageIndex: P
              });
            }
            getStructTree(P) {
              return this.messageHandler.sendWithPromise("GetStructTree", {
                pageIndex: P
              });
            }
            getOutline() {
              return this.messageHandler.sendWithPromise("GetOutline", null);
            }
            getOptionalContentConfig() {
              return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then((P) => new _optional_content_config.OptionalContentConfig(P));
            }
            getPermissions() {
              return this.messageHandler.sendWithPromise("GetPermissions", null);
            }
            getMetadata() {
              const P = "GetMetadata", L = w(this, E).get(P);
              if (L)
                return L;
              const Y = this.messageHandler.sendWithPromise(P, null).then((N) => {
                var W, V;
                return {
                  info: N[0],
                  metadata: N[1] ? new _metadata.Metadata(N[1]) : null,
                  contentDispositionFilename: ((W = this._fullReader) == null ? void 0 : W.filename) ?? null,
                  contentLength: ((V = this._fullReader) == null ? void 0 : V.contentLength) ?? null
                };
              });
              return w(this, E).set(P, Y), Y;
            }
            getMarkInfo() {
              return this.messageHandler.sendWithPromise("GetMarkInfo", null);
            }
            async startCleanup(P = !1) {
              if (!this.destroyed) {
                await this.messageHandler.sendWithPromise("Cleanup", null);
                for (const L of w(this, S).values())
                  if (!L.cleanup())
                    throw new Error(`startCleanup: Page ${L.pageNumber} is currently rendering.`);
                this.commonObjs.clear(), P || this.fontLoader.clear(), w(this, E).clear(), this.filterFactory.destroy(!0);
              }
            }
            get loadingParams() {
              const {
                disableAutoFetch: P,
                enableXfa: L
              } = this._params;
              return (0, _util.shadow)(this, "loadingParams", {
                disableAutoFetch: P,
                enableXfa: L
              });
            }
          }
          E = new WeakMap(), S = new WeakMap(), R = new WeakMap(), x = new WeakMap(), H = new WeakSet(), Ht = function(P, L = null) {
            const Y = w(this, E).get(P);
            if (Y)
              return Y;
            const N = this.messageHandler.sendWithPromise(P, L);
            return w(this, E).set(P, N), N;
          };
          class PDFObjects {
            constructor() {
              Ee(this, O);
              Ee(this, C, /* @__PURE__ */ Object.create(null));
            }
            get(P, L = null) {
              if (L) {
                const N = _e(this, O, tn).call(this, P);
                return N.capability.promise.then(() => L(N.data)), null;
              }
              const Y = w(this, C)[P];
              if (!(Y != null && Y.capability.settled))
                throw new Error(`Requesting object that isn't resolved yet ${P}.`);
              return Y.data;
            }
            has(P) {
              const L = w(this, C)[P];
              return (L == null ? void 0 : L.capability.settled) || !1;
            }
            resolve(P, L = null) {
              const Y = _e(this, O, tn).call(this, P);
              Y.data = L, Y.capability.resolve();
            }
            clear() {
              var P;
              for (const L in w(this, C)) {
                const {
                  data: Y
                } = w(this, C)[L];
                (P = Y == null ? void 0 : Y.bitmap) == null || P.close();
              }
              Se(this, C, /* @__PURE__ */ Object.create(null));
            }
          }
          C = new WeakMap(), O = new WeakSet(), tn = function(P) {
            var L;
            return (L = w(this, C))[P] || (L[P] = {
              capability: new _util.PromiseCapability(),
              data: null
            });
          };
          class RenderTask {
            constructor(P) {
              Ee(this, B, null);
              Se(this, B, P), this.onContinue = null;
            }
            get promise() {
              return w(this, B).capability.promise;
            }
            cancel(P = 0) {
              w(this, B).cancel(null, P);
            }
            get separateAnnots() {
              const {
                separateAnnots: P
              } = w(this, B).operatorList;
              if (!P)
                return !1;
              const {
                annotationCanvasMap: L
              } = w(this, B);
              return P.form || P.canvas && (L == null ? void 0 : L.size) > 0;
            }
          }
          B = new WeakMap(), exports.RenderTask = RenderTask;
          const M = class M {
            constructor({
              callback: P,
              params: L,
              objs: Y,
              commonObjs: N,
              annotationCanvasMap: W,
              operatorList: V,
              pageIndex: ue,
              canvasFactory: se,
              filterFactory: ce,
              useRequestAnimationFrame: oe = !1,
              pdfBug: ge = !1,
              pageColors: J = null
            }) {
              this.callback = P, this.params = L, this.objs = Y, this.commonObjs = N, this.annotationCanvasMap = W, this.operatorListIdx = null, this.operatorList = V, this._pageIndex = ue, this.canvasFactory = se, this.filterFactory = ce, this._pdfBug = ge, this.pageColors = J, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = oe === !0 && typeof window < "u", this.cancelled = !1, this.capability = new _util.PromiseCapability(), this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = L.canvasContext.canvas;
            }
            get completed() {
              return this.capability.promise.catch(function() {
              });
            }
            initializeGraphics({
              transparency: P = !1,
              optionalContentConfig: L
            }) {
              var ue, se;
              if (this.cancelled)
                return;
              if (this._canvas) {
                if (w(M, D).has(this._canvas))
                  throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
                w(M, D).add(this._canvas);
              }
              this._pdfBug && ((ue = globalThis.StepperManager) != null && ue.enabled) && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint());
              const {
                canvasContext: Y,
                viewport: N,
                transform: W,
                background: V
              } = this.params;
              this.gfx = new _canvas.CanvasGraphics(Y, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                optionalContentConfig: L
              }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({
                transform: W,
                viewport: N,
                transparency: P,
                background: V
              }), this.operatorListIdx = 0, this.graphicsReady = !0, (se = this.graphicsReadyCallback) == null || se.call(this);
            }
            cancel(P = null, L = 0) {
              var Y;
              this.running = !1, this.cancelled = !0, (Y = this.gfx) == null || Y.endDrawing(), w(M, D).delete(this._canvas), this.callback(P || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, L));
            }
            operatorListChanged() {
              var P;
              if (!this.graphicsReady) {
                this.graphicsReadyCallback || (this.graphicsReadyCallback = this._continueBound);
                return;
              }
              (P = this.stepper) == null || P.updateOperatorList(this.operatorList), !this.running && this._continue();
            }
            _continue() {
              this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext());
            }
            _scheduleNext() {
              this._useRequestAnimationFrame ? window.requestAnimationFrame(() => {
                this._nextBound().catch(this._cancelBound);
              }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound);
            }
            async _next() {
              this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), w(M, D).delete(this._canvas), this.callback())));
            }
          };
          D = new WeakMap(), Ee(M, D, /* @__PURE__ */ new WeakSet());
          let InternalRenderTask = M;
          const version = "3.11.174";
          exports.version = version;
          const build = "ce8716743";
          exports.build = build;
        },
        /* 3 */
        /***/
        (c, a, h) => {
          var y, v, E, Bn, R;
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.SerializableEmpty = a.PrintAnnotationStorage = a.AnnotationStorage = void 0;
          var d = h(1), u = h(4), _ = h(8);
          const g = Object.freeze({
            map: null,
            hash: "",
            transfers: void 0
          });
          a.SerializableEmpty = g;
          class $ {
            constructor() {
              Ee(this, E);
              Ee(this, y, !1);
              Ee(this, v, /* @__PURE__ */ new Map());
              this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null;
            }
            getValue(H, T) {
              const C = w(this, v).get(H);
              return C === void 0 ? T : Object.assign(T, C);
            }
            getRawValue(H) {
              return w(this, v).get(H);
            }
            remove(H) {
              if (w(this, v).delete(H), w(this, v).size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") {
                for (const T of w(this, v).values())
                  if (T instanceof u.AnnotationEditor)
                    return;
                this.onAnnotationEditor(null);
              }
            }
            setValue(H, T) {
              const C = w(this, v).get(H);
              let O = !1;
              if (C !== void 0)
                for (const [j, B] of Object.entries(T))
                  C[j] !== B && (O = !0, C[j] = B);
              else
                O = !0, w(this, v).set(H, T);
              O && _e(this, E, Bn).call(this), T instanceof u.AnnotationEditor && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(T.constructor._type);
            }
            has(H) {
              return w(this, v).has(H);
            }
            getAll() {
              return w(this, v).size > 0 ? (0, d.objectFromMap)(w(this, v)) : null;
            }
            setAll(H) {
              for (const [T, C] of Object.entries(H))
                this.setValue(T, C);
            }
            get size() {
              return w(this, v).size;
            }
            resetModified() {
              w(this, y) && (Se(this, y, !1), typeof this.onResetModified == "function" && this.onResetModified());
            }
            get print() {
              return new b(this);
            }
            get serializable() {
              if (w(this, v).size === 0)
                return g;
              const H = /* @__PURE__ */ new Map(), T = new _.MurmurHash3_64(), C = [], O = /* @__PURE__ */ Object.create(null);
              let j = !1;
              for (const [B, D] of w(this, v)) {
                const M = D instanceof u.AnnotationEditor ? D.serialize(!1, O) : D;
                M && (H.set(B, M), T.update(`${B}:${JSON.stringify(M)}`), j || (j = !!M.bitmap));
              }
              if (j)
                for (const B of H.values())
                  B.bitmap && C.push(B.bitmap);
              return H.size > 0 ? {
                map: H,
                hash: T.hexdigest(),
                transfers: C
              } : g;
            }
          }
          y = new WeakMap(), v = new WeakMap(), E = new WeakSet(), Bn = function() {
            w(this, y) || (Se(this, y, !0), typeof this.onSetModified == "function" && this.onSetModified());
          }, a.AnnotationStorage = $;
          class b extends $ {
            constructor(T) {
              super();
              Ee(this, R);
              const {
                map: C,
                hash: O,
                transfers: j
              } = T.serializable, B = structuredClone(C, j ? {
                transfer: j
              } : null);
              Se(this, R, {
                map: B,
                hash: O,
                transfers: j
              });
            }
            get print() {
              (0, d.unreachable)("Should not call PrintAnnotationStorage.print");
            }
            get serializable() {
              return w(this, R);
            }
          }
          R = new WeakMap(), a.PrintAnnotationStorage = b;
        },
        /* 4 */
        /***/
        (c, a, h) => {
          var b, y, v, E, S, R, x, H, T, C, O, j, B, D, M, nn, sn, L, rn, an, Un, Hn, qn, on, jn;
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.AnnotationEditor = void 0;
          var d = h(5), u = h(1), _ = h(6);
          const oe = class oe {
            constructor(J) {
              Ee(this, M);
              Ee(this, b, "");
              Ee(this, y, !1);
              Ee(this, v, null);
              Ee(this, E, null);
              Ee(this, S, null);
              Ee(this, R, !1);
              Ee(this, x, null);
              Ee(this, H, this.focusin.bind(this));
              Ee(this, T, this.focusout.bind(this));
              Ee(this, C, !1);
              Ee(this, O, !1);
              Ee(this, j, !1);
              _t(this, "_initialOptions", /* @__PURE__ */ Object.create(null));
              _t(this, "_uiManager", null);
              _t(this, "_focusEventsAllowed", !0);
              _t(this, "_l10nPromise", null);
              Ee(this, B, !1);
              Ee(this, D, oe._zIndex++);
              this.constructor === oe && (0, u.unreachable)("Cannot initialize AnnotationEditor."), this.parent = J.parent, this.id = J.id, this.width = this.height = null, this.pageIndex = J.parent.pageIndex, this.name = J.name, this.div = null, this._uiManager = J.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = J.isCentered, this._structTreeParentId = null;
              const {
                rotation: ae,
                rawDims: {
                  pageWidth: le,
                  pageHeight: z,
                  pageX: A,
                  pageY: F
                }
              } = this.parent.viewport;
              this.rotation = ae, this.pageRotation = (360 + ae - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [le, z], this.pageTranslation = [A, F];
              const [U, Z] = this.parentDimensions;
              this.x = J.x / U, this.y = J.y / Z, this.isAttachedToDOM = !1, this.deleted = !1;
            }
            get editorType() {
              return Object.getPrototypeOf(this).constructor._type;
            }
            static get _defaultLineColor() {
              return (0, u.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
            }
            static deleteAnnotationElement(J) {
              const ae = new $({
                id: J.parent.getNextId(),
                parent: J.parent,
                uiManager: J._uiManager
              });
              ae.annotationElementId = J.annotationElementId, ae.deleted = !0, ae._uiManager.addToAnnotationStorage(ae);
            }
            static initialize(J, ae = null) {
              if (oe._l10nPromise || (oe._l10nPromise = new Map(["editor_alt_text_button_label", "editor_alt_text_edit_button_label", "editor_alt_text_decorative_tooltip"].map((z) => [z, J.get(z)]))), ae != null && ae.strings)
                for (const z of ae.strings)
                  oe._l10nPromise.set(z, J.get(z));
              if (oe._borderLineWidth !== -1)
                return;
              const le = getComputedStyle(document.documentElement);
              oe._borderLineWidth = parseFloat(le.getPropertyValue("--outline-width")) || 0;
            }
            static updateDefaultParams(J, ae) {
            }
            static get defaultPropertiesToUpdate() {
              return [];
            }
            static isHandlingMimeForPasting(J) {
              return !1;
            }
            static paste(J, ae) {
              (0, u.unreachable)("Not implemented");
            }
            get propertiesToUpdate() {
              return [];
            }
            get _isDraggable() {
              return w(this, B);
            }
            set _isDraggable(J) {
              var ae;
              Se(this, B, J), (ae = this.div) == null || ae.classList.toggle("draggable", J);
            }
            center() {
              const [J, ae] = this.pageDimensions;
              switch (this.parentRotation) {
                case 90:
                  this.x -= this.height * ae / (J * 2), this.y += this.width * J / (ae * 2);
                  break;
                case 180:
                  this.x += this.width / 2, this.y += this.height / 2;
                  break;
                case 270:
                  this.x += this.height * ae / (J * 2), this.y -= this.width * J / (ae * 2);
                  break;
                default:
                  this.x -= this.width / 2, this.y -= this.height / 2;
                  break;
              }
              this.fixAndSetPosition();
            }
            addCommands(J) {
              this._uiManager.addCommands(J);
            }
            get currentLayer() {
              return this._uiManager.currentLayer;
            }
            setInBackground() {
              this.div.style.zIndex = 0;
            }
            setInForeground() {
              this.div.style.zIndex = w(this, D);
            }
            setParent(J) {
              J !== null && (this.pageIndex = J.pageIndex, this.pageDimensions = J.pageDimensions), this.parent = J;
            }
            focusin(J) {
              this._focusEventsAllowed && (w(this, C) ? Se(this, C, !1) : this.parent.setSelected(this));
            }
            focusout(J) {
              var le;
              if (!this._focusEventsAllowed || !this.isAttachedToDOM)
                return;
              const ae = J.relatedTarget;
              ae != null && ae.closest(`#${this.id}`) || (J.preventDefault(), (le = this.parent) != null && le.isMultipleSelection || this.commitOrRemove());
            }
            commitOrRemove() {
              this.isEmpty() ? this.remove() : this.commit();
            }
            commit() {
              this.addToAnnotationStorage();
            }
            addToAnnotationStorage() {
              this._uiManager.addToAnnotationStorage(this);
            }
            setAt(J, ae, le, z) {
              const [A, F] = this.parentDimensions;
              [le, z] = this.screenToPageTranslation(le, z), this.x = (J + le) / A, this.y = (ae + z) / F, this.fixAndSetPosition();
            }
            translate(J, ae) {
              _e(this, M, nn).call(this, this.parentDimensions, J, ae);
            }
            translateInPage(J, ae) {
              _e(this, M, nn).call(this, this.pageDimensions, J, ae), this.div.scrollIntoView({
                block: "nearest"
              });
            }
            drag(J, ae) {
              const [le, z] = this.parentDimensions;
              if (this.x += J / le, this.y += ae / z, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
                const {
                  x: G,
                  y: Q
                } = this.div.getBoundingClientRect();
                this.parent.findNewParent(this, G, Q) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y));
              }
              let {
                x: A,
                y: F
              } = this;
              const [U, Z] = _e(this, M, sn).call(this);
              A += U, F += Z, this.div.style.left = `${(100 * A).toFixed(2)}%`, this.div.style.top = `${(100 * F).toFixed(2)}%`, this.div.scrollIntoView({
                block: "nearest"
              });
            }
            fixAndSetPosition() {
              const [J, ae] = this.pageDimensions;
              let {
                x: le,
                y: z,
                width: A,
                height: F
              } = this;
              switch (A *= J, F *= ae, le *= J, z *= ae, this.rotation) {
                case 0:
                  le = Math.max(0, Math.min(J - A, le)), z = Math.max(0, Math.min(ae - F, z));
                  break;
                case 90:
                  le = Math.max(0, Math.min(J - F, le)), z = Math.min(ae, Math.max(A, z));
                  break;
                case 180:
                  le = Math.min(J, Math.max(A, le)), z = Math.min(ae, Math.max(F, z));
                  break;
                case 270:
                  le = Math.min(J, Math.max(F, le)), z = Math.max(0, Math.min(ae - A, z));
                  break;
              }
              this.x = le /= J, this.y = z /= ae;
              const [U, Z] = _e(this, M, sn).call(this);
              le += U, z += Z;
              const {
                style: G
              } = this.div;
              G.left = `${(100 * le).toFixed(2)}%`, G.top = `${(100 * z).toFixed(2)}%`, this.moveInDOM();
            }
            screenToPageTranslation(J, ae) {
              var le;
              return _e(le = oe, L, rn).call(le, J, ae, this.parentRotation);
            }
            pageTranslationToScreen(J, ae) {
              var le;
              return _e(le = oe, L, rn).call(le, J, ae, 360 - this.parentRotation);
            }
            get parentScale() {
              return this._uiManager.viewParameters.realScale;
            }
            get parentRotation() {
              return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
            }
            get parentDimensions() {
              const {
                parentScale: J,
                pageDimensions: [ae, le]
              } = this, z = ae * J, A = le * J;
              return u.FeatureTest.isCSSRoundSupported ? [Math.round(z), Math.round(A)] : [z, A];
            }
            setDims(J, ae) {
              var A;
              const [le, z] = this.parentDimensions;
              this.div.style.width = `${(100 * J / le).toFixed(2)}%`, w(this, R) || (this.div.style.height = `${(100 * ae / z).toFixed(2)}%`), (A = w(this, v)) == null || A.classList.toggle("small", J < oe.SMALL_EDITOR_SIZE || ae < oe.SMALL_EDITOR_SIZE);
            }
            fixDims() {
              const {
                style: J
              } = this.div, {
                height: ae,
                width: le
              } = J, z = le.endsWith("%"), A = !w(this, R) && ae.endsWith("%");
              if (z && A)
                return;
              const [F, U] = this.parentDimensions;
              z || (J.width = `${(100 * parseFloat(le) / F).toFixed(2)}%`), !w(this, R) && !A && (J.height = `${(100 * parseFloat(ae) / U).toFixed(2)}%`);
            }
            getInitialTranslation() {
              return [0, 0];
            }
            async addAltTextButton() {
              if (w(this, v))
                return;
              const J = Se(this, v, document.createElement("button"));
              J.className = "altText";
              const ae = await oe._l10nPromise.get("editor_alt_text_button_label");
              J.textContent = ae, J.setAttribute("aria-label", ae), J.tabIndex = "0", J.addEventListener("contextmenu", _.noContextMenu), J.addEventListener("pointerdown", (le) => le.stopPropagation()), J.addEventListener("click", (le) => {
                le.preventDefault(), this._uiManager.editAltText(this);
              }, {
                capture: !0
              }), J.addEventListener("keydown", (le) => {
                le.target === J && le.key === "Enter" && (le.preventDefault(), this._uiManager.editAltText(this));
              }), _e(this, M, on).call(this), this.div.append(J), oe.SMALL_EDITOR_SIZE || (oe.SMALL_EDITOR_SIZE = Math.min(128, Math.round(J.getBoundingClientRect().width * 1.4)));
            }
            getClientDimensions() {
              return this.div.getBoundingClientRect();
            }
            get altTextData() {
              return {
                altText: w(this, b),
                decorative: w(this, y)
              };
            }
            set altTextData({
              altText: J,
              decorative: ae
            }) {
              w(this, b) === J && w(this, y) === ae || (Se(this, b, J), Se(this, y, ae), _e(this, M, on).call(this));
            }
            render() {
              this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.setAttribute("tabIndex", 0), this.setInForeground(), this.div.addEventListener("focusin", w(this, H)), this.div.addEventListener("focusout", w(this, T));
              const [J, ae] = this.parentDimensions;
              this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = `${(100 * ae / J).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * J / ae).toFixed(2)}%`);
              const [le, z] = this.getInitialTranslation();
              return this.translate(le, z), (0, d.bindEvents)(this, this.div, ["pointerdown"]), this.div;
            }
            pointerdown(J) {
              const {
                isMac: ae
              } = u.FeatureTest.platform;
              if (J.button !== 0 || J.ctrlKey && ae) {
                J.preventDefault();
                return;
              }
              Se(this, C, !0), _e(this, M, jn).call(this, J);
            }
            moveInDOM() {
              var J;
              (J = this.parent) == null || J.moveEditorInDOM(this);
            }
            _setParentAndPosition(J, ae, le) {
              J.changeParent(this), this.x = ae, this.y = le, this.fixAndSetPosition();
            }
            getRect(J, ae) {
              const le = this.parentScale, [z, A] = this.pageDimensions, [F, U] = this.pageTranslation, Z = J / le, G = ae / le, Q = this.x * z, he = this.y * A, me = this.width * z, Te = this.height * A;
              switch (this.rotation) {
                case 0:
                  return [Q + Z + F, A - he - G - Te + U, Q + Z + me + F, A - he - G + U];
                case 90:
                  return [Q + G + F, A - he + Z + U, Q + G + Te + F, A - he + Z + me + U];
                case 180:
                  return [Q - Z - me + F, A - he + G + U, Q - Z + F, A - he + G + Te + U];
                case 270:
                  return [Q - G - Te + F, A - he - Z - me + U, Q - G + F, A - he - Z + U];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            getRectInCurrentCoords(J, ae) {
              const [le, z, A, F] = J, U = A - le, Z = F - z;
              switch (this.rotation) {
                case 0:
                  return [le, ae - F, U, Z];
                case 90:
                  return [le, ae - z, Z, U];
                case 180:
                  return [A, ae - z, U, Z];
                case 270:
                  return [A, ae - F, Z, U];
                default:
                  throw new Error("Invalid rotation");
              }
            }
            onceAdded() {
            }
            isEmpty() {
              return !1;
            }
            enableEditMode() {
              Se(this, j, !0);
            }
            disableEditMode() {
              Se(this, j, !1);
            }
            isInEditMode() {
              return w(this, j);
            }
            shouldGetKeyboardEvents() {
              return !1;
            }
            needsToBeRebuilt() {
              return this.div && !this.isAttachedToDOM;
            }
            rebuild() {
              var J, ae;
              (J = this.div) == null || J.addEventListener("focusin", w(this, H)), (ae = this.div) == null || ae.addEventListener("focusout", w(this, T));
            }
            serialize(J = !1, ae = null) {
              (0, u.unreachable)("An editor must be serializable");
            }
            static deserialize(J, ae, le) {
              const z = new this.prototype.constructor({
                parent: ae,
                id: ae.getNextId(),
                uiManager: le
              });
              z.rotation = J.rotation;
              const [A, F] = z.pageDimensions, [U, Z, G, Q] = z.getRectInCurrentCoords(J.rect, F);
              return z.x = U / A, z.y = Z / F, z.width = G / A, z.height = Q / F, z;
            }
            remove() {
              var J;
              this.div.removeEventListener("focusin", w(this, H)), this.div.removeEventListener("focusout", w(this, T)), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), (J = w(this, v)) == null || J.remove(), Se(this, v, null), Se(this, E, null);
            }
            get isResizable() {
              return !1;
            }
            makeResizable() {
              this.isResizable && (_e(this, M, Un).call(this), w(this, x).classList.remove("hidden"));
            }
            select() {
              var J;
              this.makeResizable(), (J = this.div) == null || J.classList.add("selectedEditor");
            }
            unselect() {
              var J, ae, le;
              (J = w(this, x)) == null || J.classList.add("hidden"), (ae = this.div) == null || ae.classList.remove("selectedEditor"), (le = this.div) != null && le.contains(document.activeElement) && this._uiManager.currentLayer.div.focus();
            }
            updateParams(J, ae) {
            }
            disableEditing() {
              w(this, v) && (w(this, v).hidden = !0);
            }
            enableEditing() {
              w(this, v) && (w(this, v).hidden = !1);
            }
            enterInEditMode() {
            }
            get contentDiv() {
              return this.div;
            }
            get isEditing() {
              return w(this, O);
            }
            set isEditing(J) {
              Se(this, O, J), this.parent && (J ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null));
            }
            setAspectRatio(J, ae) {
              Se(this, R, !0);
              const le = J / ae, {
                style: z
              } = this.div;
              z.aspectRatio = le, z.height = "auto";
            }
            static get MIN_SIZE() {
              return 16;
            }
          };
          b = new WeakMap(), y = new WeakMap(), v = new WeakMap(), E = new WeakMap(), S = new WeakMap(), R = new WeakMap(), x = new WeakMap(), H = new WeakMap(), T = new WeakMap(), C = new WeakMap(), O = new WeakMap(), j = new WeakMap(), B = new WeakMap(), D = new WeakMap(), M = new WeakSet(), nn = function([J, ae], le, z) {
            [le, z] = this.screenToPageTranslation(le, z), this.x += le / J, this.y += z / ae, this.fixAndSetPosition();
          }, sn = function() {
            const [J, ae] = this.parentDimensions, {
              _borderLineWidth: le
            } = oe, z = le / J, A = le / ae;
            switch (this.rotation) {
              case 90:
                return [-z, A];
              case 180:
                return [z, A];
              case 270:
                return [z, -A];
              default:
                return [-z, -A];
            }
          }, L = new WeakSet(), rn = function(J, ae, le) {
            switch (le) {
              case 90:
                return [ae, -J];
              case 180:
                return [-J, -ae];
              case 270:
                return [-ae, J];
              default:
                return [J, ae];
            }
          }, an = function(J) {
            switch (J) {
              case 90: {
                const [ae, le] = this.pageDimensions;
                return [0, -ae / le, le / ae, 0];
              }
              case 180:
                return [-1, 0, 0, -1];
              case 270: {
                const [ae, le] = this.pageDimensions;
                return [0, ae / le, -le / ae, 0];
              }
              default:
                return [1, 0, 0, 1];
            }
          }, Un = function() {
            if (w(this, x))
              return;
            Se(this, x, document.createElement("div")), w(this, x).classList.add("resizers");
            const J = ["topLeft", "topRight", "bottomRight", "bottomLeft"];
            this._willKeepAspectRatio || J.push("topMiddle", "middleRight", "bottomMiddle", "middleLeft");
            for (const ae of J) {
              const le = document.createElement("div");
              w(this, x).append(le), le.classList.add("resizer", ae), le.addEventListener("pointerdown", _e(this, M, Hn).bind(this, ae)), le.addEventListener("contextmenu", _.noContextMenu);
            }
            this.div.prepend(w(this, x));
          }, Hn = function(J, ae) {
            ae.preventDefault();
            const {
              isMac: le
            } = u.FeatureTest.platform;
            if (ae.button !== 0 || ae.ctrlKey && le)
              return;
            const z = _e(this, M, qn).bind(this, J), A = this._isDraggable;
            this._isDraggable = !1;
            const F = {
              passive: !0,
              capture: !0
            };
            window.addEventListener("pointermove", z, F);
            const U = this.x, Z = this.y, G = this.width, Q = this.height, he = this.parent.div.style.cursor, me = this.div.style.cursor;
            this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(ae.target).cursor;
            const Te = () => {
              this._isDraggable = A, window.removeEventListener("pointerup", Te), window.removeEventListener("blur", Te), window.removeEventListener("pointermove", z, F), this.parent.div.style.cursor = he, this.div.style.cursor = me;
              const Pe = this.x, Re = this.y, Me = this.width, Fe = this.height;
              Pe === U && Re === Z && Me === G && Fe === Q || this.addCommands({
                cmd: () => {
                  this.width = Me, this.height = Fe, this.x = Pe, this.y = Re;
                  const [ve, be] = this.parentDimensions;
                  this.setDims(ve * Me, be * Fe), this.fixAndSetPosition();
                },
                undo: () => {
                  this.width = G, this.height = Q, this.x = U, this.y = Z;
                  const [ve, be] = this.parentDimensions;
                  this.setDims(ve * G, be * Q), this.fixAndSetPosition();
                },
                mustExec: !0
              });
            };
            window.addEventListener("pointerup", Te), window.addEventListener("blur", Te);
          }, qn = function(J, ae) {
            const [le, z] = this.parentDimensions, A = this.x, F = this.y, U = this.width, Z = this.height, G = oe.MIN_SIZE / le, Q = oe.MIN_SIZE / z, he = (Ve) => Math.round(Ve * 1e4) / 1e4, me = _e(this, M, an).call(this, this.rotation), Te = (Ve, et) => [me[0] * Ve + me[2] * et, me[1] * Ve + me[3] * et], Pe = _e(this, M, an).call(this, 360 - this.rotation), Re = (Ve, et) => [Pe[0] * Ve + Pe[2] * et, Pe[1] * Ve + Pe[3] * et];
            let Me, Fe, ve = !1, be = !1;
            switch (J) {
              case "topLeft":
                ve = !0, Me = (Ve, et) => [0, 0], Fe = (Ve, et) => [Ve, et];
                break;
              case "topMiddle":
                Me = (Ve, et) => [Ve / 2, 0], Fe = (Ve, et) => [Ve / 2, et];
                break;
              case "topRight":
                ve = !0, Me = (Ve, et) => [Ve, 0], Fe = (Ve, et) => [0, et];
                break;
              case "middleRight":
                be = !0, Me = (Ve, et) => [Ve, et / 2], Fe = (Ve, et) => [0, et / 2];
                break;
              case "bottomRight":
                ve = !0, Me = (Ve, et) => [Ve, et], Fe = (Ve, et) => [0, 0];
                break;
              case "bottomMiddle":
                Me = (Ve, et) => [Ve / 2, et], Fe = (Ve, et) => [Ve / 2, 0];
                break;
              case "bottomLeft":
                ve = !0, Me = (Ve, et) => [0, et], Fe = (Ve, et) => [Ve, 0];
                break;
              case "middleLeft":
                be = !0, Me = (Ve, et) => [0, et / 2], Fe = (Ve, et) => [Ve, et / 2];
                break;
            }
            const X = Me(U, Z), ne = Fe(U, Z);
            let te = Te(...ne);
            const ye = he(A + te[0]), xe = he(F + te[1]);
            let Le = 1, Ie = 1, [fe, He] = this.screenToPageTranslation(ae.movementX, ae.movementY);
            if ([fe, He] = Re(fe / le, He / z), ve) {
              const Ve = Math.hypot(U, Z);
              Le = Ie = Math.max(Math.min(Math.hypot(ne[0] - X[0] - fe, ne[1] - X[1] - He) / Ve, 1 / U, 1 / Z), G / U, Q / Z);
            } else be ? Le = Math.max(G, Math.min(1, Math.abs(ne[0] - X[0] - fe))) / U : Ie = Math.max(Q, Math.min(1, Math.abs(ne[1] - X[1] - He))) / Z;
            const Be = he(U * Le), st = he(Z * Ie);
            te = Te(...Fe(Be, st));
            const nt = ye - te[0], ht = xe - te[1];
            this.width = Be, this.height = st, this.x = nt, this.y = ht, this.setDims(le * Be, z * st), this.fixAndSetPosition();
          }, on = async function() {
            var le;
            const J = w(this, v);
            if (!J)
              return;
            if (!w(this, b) && !w(this, y)) {
              J.classList.remove("done"), (le = w(this, E)) == null || le.remove();
              return;
            }
            oe._l10nPromise.get("editor_alt_text_edit_button_label").then((z) => {
              J.setAttribute("aria-label", z);
            });
            let ae = w(this, E);
            if (!ae) {
              Se(this, E, ae = document.createElement("span")), ae.className = "tooltip", ae.setAttribute("role", "tooltip");
              const z = ae.id = `alt-text-tooltip-${this.id}`;
              J.setAttribute("aria-describedby", z);
              const A = 100;
              J.addEventListener("mouseenter", () => {
                Se(this, S, setTimeout(() => {
                  Se(this, S, null), w(this, E).classList.add("show"), this._uiManager._eventBus.dispatch("reporttelemetry", {
                    source: this,
                    details: {
                      type: "editing",
                      subtype: this.editorType,
                      data: {
                        action: "alt_text_tooltip"
                      }
                    }
                  });
                }, A));
              }), J.addEventListener("mouseleave", () => {
                var F;
                clearTimeout(w(this, S)), Se(this, S, null), (F = w(this, E)) == null || F.classList.remove("show");
              });
            }
            J.classList.add("done"), ae.innerText = w(this, y) ? await oe._l10nPromise.get("editor_alt_text_decorative_tooltip") : w(this, b), ae.parentNode || J.append(ae);
          }, jn = function(J) {
            if (!this._isDraggable)
              return;
            const ae = this._uiManager.isSelected(this);
            this._uiManager.setUpDragSession();
            let le, z;
            ae && (le = {
              passive: !0,
              capture: !0
            }, z = (F) => {
              const [U, Z] = this.screenToPageTranslation(F.movementX, F.movementY);
              this._uiManager.dragSelectedEditors(U, Z);
            }, window.addEventListener("pointermove", z, le));
            const A = () => {
              if (window.removeEventListener("pointerup", A), window.removeEventListener("blur", A), ae && window.removeEventListener("pointermove", z, le), Se(this, C, !1), !this._uiManager.endDragSession()) {
                const {
                  isMac: F
                } = u.FeatureTest.platform;
                J.ctrlKey && !F || J.shiftKey || J.metaKey && F ? this.parent.toggleSelected(this) : this.parent.setSelected(this);
              }
            };
            window.addEventListener("pointerup", A), window.addEventListener("blur", A);
          }, Ee(oe, L), _t(oe, "_borderLineWidth", -1), _t(oe, "_colorManager", new d.ColorManager()), _t(oe, "_zIndex", 1), _t(oe, "SMALL_EDITOR_SIZE", 0);
          let g = oe;
          a.AnnotationEditor = g;
          class $ extends g {
            constructor(J) {
              super(J), this.annotationElementId = J.annotationElementId, this.deleted = !0;
            }
            serialize() {
              return {
                id: this.annotationElementId,
                deleted: !0,
                pageIndex: this.pageIndex
              };
            }
          }
        },
        /* 5 */
        /***/
        (c, a, h) => {
          var R, x, H, T, C, ln, B, D, M, I, P, Wn, N, W, V, ue, se, ce, oe, ge, J, ae, le, z, A, F, U, Z, G, Q, he, me, Te, Pe, Re, Me, Fe, ve, be, X, ne, te, ye, xe, Le, Ie, fe, zn, cn, hn, qt, dn, un, $t, Dt, Gn, Vn, _n, It, fn;
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.KeyboardManager = a.CommandManager = a.ColorManager = a.AnnotationEditorUIManager = void 0, a.bindEvents = _, a.opacityToHex = g;
          var d = h(1), u = h(6);
          function _(ct, ie, Ce) {
            for (const Ue of Ce)
              ie.addEventListener(Ue, ct[Ue].bind(ct));
          }
          function g(ct) {
            return Math.round(Math.min(255, Math.max(1, 255 * ct))).toString(16).padStart(2, "0");
          }
          class $ {
            constructor() {
              Ee(this, R, 0);
            }
            getId() {
              return `${d.AnnotationEditorPrefix}${Mt(this, R)._++}`;
            }
          }
          R = new WeakMap();
          const j = class j {
            constructor() {
              Ee(this, C);
              Ee(this, x, (0, d.getUuid)());
              Ee(this, H, 0);
              Ee(this, T, null);
            }
            static get _isSVGFittingCanvas() {
              const ie = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>', Ue = new OffscreenCanvas(1, 3).getContext("2d"), Ze = new Image();
              Ze.src = ie;
              const Qe = Ze.decode().then(() => (Ue.drawImage(Ze, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(Ue.getImageData(0, 0, 1, 1).data.buffer)[0] === 0));
              return (0, d.shadow)(this, "_isSVGFittingCanvas", Qe);
            }
            async getFromFile(ie) {
              const {
                lastModified: Ce,
                name: Ue,
                size: Ze,
                type: Qe
              } = ie;
              return _e(this, C, ln).call(this, `${Ce}_${Ue}_${Ze}_${Qe}`, ie);
            }
            async getFromUrl(ie) {
              return _e(this, C, ln).call(this, ie, ie);
            }
            async getFromId(ie) {
              w(this, T) || Se(this, T, /* @__PURE__ */ new Map());
              const Ce = w(this, T).get(ie);
              return Ce ? Ce.bitmap ? (Ce.refCounter += 1, Ce) : Ce.file ? this.getFromFile(Ce.file) : this.getFromUrl(Ce.url) : null;
            }
            getSvgUrl(ie) {
              const Ce = w(this, T).get(ie);
              return Ce != null && Ce.isSvg ? Ce.svgUrl : null;
            }
            deleteId(ie) {
              w(this, T) || Se(this, T, /* @__PURE__ */ new Map());
              const Ce = w(this, T).get(ie);
              Ce && (Ce.refCounter -= 1, Ce.refCounter === 0 && (Ce.bitmap = null));
            }
            isValidId(ie) {
              return ie.startsWith(`image_${w(this, x)}_`);
            }
          };
          x = new WeakMap(), H = new WeakMap(), T = new WeakMap(), C = new WeakSet(), ln = async function(ie, Ce) {
            w(this, T) || Se(this, T, /* @__PURE__ */ new Map());
            let Ue = w(this, T).get(ie);
            if (Ue === null)
              return null;
            if (Ue != null && Ue.bitmap)
              return Ue.refCounter += 1, Ue;
            try {
              Ue || (Ue = {
                bitmap: null,
                id: `image_${w(this, x)}_${Mt(this, H)._++}`,
                refCounter: 0,
                isSvg: !1
              });
              let Ze;
              if (typeof Ce == "string") {
                Ue.url = Ce;
                const Qe = await fetch(Ce);
                if (!Qe.ok)
                  throw new Error(Qe.statusText);
                Ze = await Qe.blob();
              } else
                Ze = Ue.file = Ce;
              if (Ze.type === "image/svg+xml") {
                const Qe = j._isSVGFittingCanvas, We = new FileReader(), ee = new Image(), K = new Promise((de, Ae) => {
                  ee.onload = () => {
                    Ue.bitmap = ee, Ue.isSvg = !0, de();
                  }, We.onload = async () => {
                    const ke = Ue.svgUrl = We.result;
                    ee.src = await Qe ? `${ke}#svgView(preserveAspectRatio(none))` : ke;
                  }, ee.onerror = We.onerror = Ae;
                });
                We.readAsDataURL(Ze), await K;
              } else
                Ue.bitmap = await createImageBitmap(Ze);
              Ue.refCounter = 1;
            } catch (Ze) {
              console.error(Ze), Ue = null;
            }
            return w(this, T).set(ie, Ue), Ue && w(this, T).set(Ue.id, Ue), Ue;
          };
          let b = j;
          class y {
            constructor(ie = 128) {
              Ee(this, B, []);
              Ee(this, D, !1);
              Ee(this, M);
              Ee(this, I, -1);
              Se(this, M, ie);
            }
            add({
              cmd: ie,
              undo: Ce,
              mustExec: Ue,
              type: Ze = NaN,
              overwriteIfSameType: Qe = !1,
              keepUndo: We = !1
            }) {
              if (Ue && ie(), w(this, D))
                return;
              const ee = {
                cmd: ie,
                undo: Ce,
                type: Ze
              };
              if (w(this, I) === -1) {
                w(this, B).length > 0 && (w(this, B).length = 0), Se(this, I, 0), w(this, B).push(ee);
                return;
              }
              if (Qe && w(this, B)[w(this, I)].type === Ze) {
                We && (ee.undo = w(this, B)[w(this, I)].undo), w(this, B)[w(this, I)] = ee;
                return;
              }
              const K = w(this, I) + 1;
              K === w(this, M) ? w(this, B).splice(0, 1) : (Se(this, I, K), K < w(this, B).length && w(this, B).splice(K)), w(this, B).push(ee);
            }
            undo() {
              w(this, I) !== -1 && (Se(this, D, !0), w(this, B)[w(this, I)].undo(), Se(this, D, !1), Se(this, I, w(this, I) - 1));
            }
            redo() {
              w(this, I) < w(this, B).length - 1 && (Se(this, I, w(this, I) + 1), Se(this, D, !0), w(this, B)[w(this, I)].cmd(), Se(this, D, !1));
            }
            hasSomethingToUndo() {
              return w(this, I) !== -1;
            }
            hasSomethingToRedo() {
              return w(this, I) < w(this, B).length - 1;
            }
            destroy() {
              Se(this, B, null);
            }
          }
          B = new WeakMap(), D = new WeakMap(), M = new WeakMap(), I = new WeakMap(), a.CommandManager = y;
          class v {
            constructor(ie) {
              Ee(this, P);
              this.buffer = [], this.callbacks = /* @__PURE__ */ new Map(), this.allKeys = /* @__PURE__ */ new Set();
              const {
                isMac: Ce
              } = d.FeatureTest.platform;
              for (const [Ue, Ze, Qe = {}] of ie)
                for (const We of Ue) {
                  const ee = We.startsWith("mac+");
                  Ce && ee ? (this.callbacks.set(We.slice(4), {
                    callback: Ze,
                    options: Qe
                  }), this.allKeys.add(We.split("+").at(-1))) : !Ce && !ee && (this.callbacks.set(We, {
                    callback: Ze,
                    options: Qe
                  }), this.allKeys.add(We.split("+").at(-1)));
                }
            }
            exec(ie, Ce) {
              if (!this.allKeys.has(Ce.key))
                return;
              const Ue = this.callbacks.get(_e(this, P, Wn).call(this, Ce));
              if (!Ue)
                return;
              const {
                callback: Ze,
                options: {
                  bubbles: Qe = !1,
                  args: We = [],
                  checker: ee = null
                }
              } = Ue;
              ee && !ee(ie, Ce) || (Ze.bind(ie, ...We)(), Qe || (Ce.stopPropagation(), Ce.preventDefault()));
            }
          }
          P = new WeakSet(), Wn = function(ie) {
            ie.altKey && this.buffer.push("alt"), ie.ctrlKey && this.buffer.push("ctrl"), ie.metaKey && this.buffer.push("meta"), ie.shiftKey && this.buffer.push("shift"), this.buffer.push(ie.key);
            const Ce = this.buffer.join("+");
            return this.buffer.length = 0, Ce;
          }, a.KeyboardManager = v;
          const Y = class Y {
            get _colors() {
              const ie = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
              return (0, u.getColorValues)(ie), (0, d.shadow)(this, "_colors", ie);
            }
            convert(ie) {
              const Ce = (0, u.getRGB)(ie);
              if (!window.matchMedia("(forced-colors: active)").matches)
                return Ce;
              for (const [Ue, Ze] of this._colors)
                if (Ze.every((Qe, We) => Qe === Ce[We]))
                  return Y._colorsMapping.get(Ue);
              return Ce;
            }
            getHexCode(ie) {
              const Ce = this._colors.get(ie);
              return Ce ? d.Util.makeHexColor(...Ce) : ie;
            }
          };
          _t(Y, "_colorsMapping", /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]));
          let E = Y;
          a.ColorManager = E;
          const at = class at {
            constructor(ie, Ce, Ue, Ze, Qe, We) {
              Ee(this, fe);
              Ee(this, N, null);
              Ee(this, W, /* @__PURE__ */ new Map());
              Ee(this, V, /* @__PURE__ */ new Map());
              Ee(this, ue, null);
              Ee(this, se, null);
              Ee(this, ce, new y());
              Ee(this, oe, 0);
              Ee(this, ge, /* @__PURE__ */ new Set());
              Ee(this, J, null);
              Ee(this, ae, null);
              Ee(this, le, /* @__PURE__ */ new Set());
              Ee(this, z, null);
              Ee(this, A, new $());
              Ee(this, F, !1);
              Ee(this, U, !1);
              Ee(this, Z, null);
              Ee(this, G, d.AnnotationEditorType.NONE);
              Ee(this, Q, /* @__PURE__ */ new Set());
              Ee(this, he, null);
              Ee(this, me, this.blur.bind(this));
              Ee(this, Te, this.focus.bind(this));
              Ee(this, Pe, this.copy.bind(this));
              Ee(this, Re, this.cut.bind(this));
              Ee(this, Me, this.paste.bind(this));
              Ee(this, Fe, this.keydown.bind(this));
              Ee(this, ve, this.onEditingAction.bind(this));
              Ee(this, be, this.onPageChanging.bind(this));
              Ee(this, X, this.onScaleChanging.bind(this));
              Ee(this, ne, this.onRotationChanging.bind(this));
              Ee(this, te, {
                isEditing: !1,
                isEmpty: !0,
                hasSomethingToUndo: !1,
                hasSomethingToRedo: !1,
                hasSelectedEditor: !1
              });
              Ee(this, ye, [0, 0]);
              Ee(this, xe, null);
              Ee(this, Le, null);
              Ee(this, Ie, null);
              Se(this, Le, ie), Se(this, Ie, Ce), Se(this, ue, Ue), this._eventBus = Ze, this._eventBus._on("editingaction", w(this, ve)), this._eventBus._on("pagechanging", w(this, be)), this._eventBus._on("scalechanging", w(this, X)), this._eventBus._on("rotationchanging", w(this, ne)), Se(this, se, Qe.annotationStorage), Se(this, z, Qe.filterFactory), Se(this, he, We), this.viewParameters = {
                realScale: u.PixelsPerInch.PDF_TO_CSS_UNITS,
                rotation: 0
              };
            }
            static get _keyboardManager() {
              const ie = at.prototype, Ce = (Qe) => {
                const {
                  activeElement: We
                } = document;
                return We && w(Qe, Le).contains(We) && Qe.hasSomethingToControl();
              }, Ue = this.TRANSLATE_SMALL, Ze = this.TRANSLATE_BIG;
              return (0, d.shadow)(this, "_keyboardManager", new v([[["ctrl+a", "mac+meta+a"], ie.selectAll], [["ctrl+z", "mac+meta+z"], ie.undo], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], ie.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], ie.delete], [["Escape", "mac+Escape"], ie.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], ie.translateSelectedEditors, {
                args: [-Ue, 0],
                checker: Ce
              }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], ie.translateSelectedEditors, {
                args: [-Ze, 0],
                checker: Ce
              }], [["ArrowRight", "mac+ArrowRight"], ie.translateSelectedEditors, {
                args: [Ue, 0],
                checker: Ce
              }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], ie.translateSelectedEditors, {
                args: [Ze, 0],
                checker: Ce
              }], [["ArrowUp", "mac+ArrowUp"], ie.translateSelectedEditors, {
                args: [0, -Ue],
                checker: Ce
              }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], ie.translateSelectedEditors, {
                args: [0, -Ze],
                checker: Ce
              }], [["ArrowDown", "mac+ArrowDown"], ie.translateSelectedEditors, {
                args: [0, Ue],
                checker: Ce
              }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], ie.translateSelectedEditors, {
                args: [0, Ze],
                checker: Ce
              }]]));
            }
            destroy() {
              _e(this, fe, qt).call(this), _e(this, fe, cn).call(this), this._eventBus._off("editingaction", w(this, ve)), this._eventBus._off("pagechanging", w(this, be)), this._eventBus._off("scalechanging", w(this, X)), this._eventBus._off("rotationchanging", w(this, ne));
              for (const ie of w(this, V).values())
                ie.destroy();
              w(this, V).clear(), w(this, W).clear(), w(this, le).clear(), Se(this, N, null), w(this, Q).clear(), w(this, ce).destroy(), w(this, ue).destroy();
            }
            get hcmFilter() {
              return (0, d.shadow)(this, "hcmFilter", w(this, he) ? w(this, z).addHCMFilter(w(this, he).foreground, w(this, he).background) : "none");
            }
            get direction() {
              return (0, d.shadow)(this, "direction", getComputedStyle(w(this, Le)).direction);
            }
            editAltText(ie) {
              var Ce;
              (Ce = w(this, ue)) == null || Ce.editAltText(this, ie);
            }
            onPageChanging({
              pageNumber: ie
            }) {
              Se(this, oe, ie - 1);
            }
            focusMainContainer() {
              w(this, Le).focus();
            }
            findParent(ie, Ce) {
              for (const Ue of w(this, V).values()) {
                const {
                  x: Ze,
                  y: Qe,
                  width: We,
                  height: ee
                } = Ue.div.getBoundingClientRect();
                if (ie >= Ze && ie <= Ze + We && Ce >= Qe && Ce <= Qe + ee)
                  return Ue;
              }
              return null;
            }
            disableUserSelect(ie = !1) {
              w(this, Ie).classList.toggle("noUserSelect", ie);
            }
            addShouldRescale(ie) {
              w(this, le).add(ie);
            }
            removeShouldRescale(ie) {
              w(this, le).delete(ie);
            }
            onScaleChanging({
              scale: ie
            }) {
              this.commitOrRemove(), this.viewParameters.realScale = ie * u.PixelsPerInch.PDF_TO_CSS_UNITS;
              for (const Ce of w(this, le))
                Ce.onScaleChanging();
            }
            onRotationChanging({
              pagesRotation: ie
            }) {
              this.commitOrRemove(), this.viewParameters.rotation = ie;
            }
            addToAnnotationStorage(ie) {
              !ie.isEmpty() && w(this, se) && !w(this, se).has(ie.id) && w(this, se).setValue(ie.id, ie);
            }
            blur() {
              if (!this.hasSelection)
                return;
              const {
                activeElement: ie
              } = document;
              for (const Ce of w(this, Q))
                if (Ce.div.contains(ie)) {
                  Se(this, Z, [Ce, ie]), Ce._focusEventsAllowed = !1;
                  break;
                }
            }
            focus() {
              if (!w(this, Z))
                return;
              const [ie, Ce] = w(this, Z);
              Se(this, Z, null), Ce.addEventListener("focusin", () => {
                ie._focusEventsAllowed = !0;
              }, {
                once: !0
              }), Ce.focus();
            }
            addEditListeners() {
              _e(this, fe, hn).call(this), _e(this, fe, dn).call(this);
            }
            removeEditListeners() {
              _e(this, fe, qt).call(this), _e(this, fe, un).call(this);
            }
            copy(ie) {
              var Ue;
              if (ie.preventDefault(), (Ue = w(this, N)) == null || Ue.commitOrRemove(), !this.hasSelection)
                return;
              const Ce = [];
              for (const Ze of w(this, Q)) {
                const Qe = Ze.serialize(!0);
                Qe && Ce.push(Qe);
              }
              Ce.length !== 0 && ie.clipboardData.setData("application/pdfjs", JSON.stringify(Ce));
            }
            cut(ie) {
              this.copy(ie), this.delete();
            }
            paste(ie) {
              ie.preventDefault();
              const {
                clipboardData: Ce
              } = ie;
              for (const Qe of Ce.items)
                for (const We of w(this, ae))
                  if (We.isHandlingMimeForPasting(Qe.type)) {
                    We.paste(Qe, this.currentLayer);
                    return;
                  }
              let Ue = Ce.getData("application/pdfjs");
              if (!Ue)
                return;
              try {
                Ue = JSON.parse(Ue);
              } catch (Qe) {
                (0, d.warn)(`paste: "${Qe.message}".`);
                return;
              }
              if (!Array.isArray(Ue))
                return;
              this.unselectAll();
              const Ze = this.currentLayer;
              try {
                const Qe = [];
                for (const K of Ue) {
                  const de = Ze.deserialize(K);
                  if (!de)
                    return;
                  Qe.push(de);
                }
                const We = () => {
                  for (const K of Qe)
                    _e(this, fe, _n).call(this, K);
                  _e(this, fe, fn).call(this, Qe);
                }, ee = () => {
                  for (const K of Qe)
                    K.remove();
                };
                this.addCommands({
                  cmd: We,
                  undo: ee,
                  mustExec: !0
                });
              } catch (Qe) {
                (0, d.warn)(`paste: "${Qe.message}".`);
              }
            }
            keydown(ie) {
              var Ce;
              (Ce = this.getActive()) != null && Ce.shouldGetKeyboardEvents() || at._keyboardManager.exec(this, ie);
            }
            onEditingAction(ie) {
              ["undo", "redo", "delete", "selectAll"].includes(ie.name) && this[ie.name]();
            }
            setEditingState(ie) {
              ie ? (_e(this, fe, zn).call(this), _e(this, fe, hn).call(this), _e(this, fe, dn).call(this), _e(this, fe, $t).call(this, {
                isEditing: w(this, G) !== d.AnnotationEditorType.NONE,
                isEmpty: _e(this, fe, It).call(this),
                hasSomethingToUndo: w(this, ce).hasSomethingToUndo(),
                hasSomethingToRedo: w(this, ce).hasSomethingToRedo(),
                hasSelectedEditor: !1
              })) : (_e(this, fe, cn).call(this), _e(this, fe, qt).call(this), _e(this, fe, un).call(this), _e(this, fe, $t).call(this, {
                isEditing: !1
              }), this.disableUserSelect(!1));
            }
            registerEditorTypes(ie) {
              if (!w(this, ae)) {
                Se(this, ae, ie);
                for (const Ce of w(this, ae))
                  _e(this, fe, Dt).call(this, Ce.defaultPropertiesToUpdate);
              }
            }
            getId() {
              return w(this, A).getId();
            }
            get currentLayer() {
              return w(this, V).get(w(this, oe));
            }
            getLayer(ie) {
              return w(this, V).get(ie);
            }
            get currentPageIndex() {
              return w(this, oe);
            }
            addLayer(ie) {
              w(this, V).set(ie.pageIndex, ie), w(this, F) ? ie.enable() : ie.disable();
            }
            removeLayer(ie) {
              w(this, V).delete(ie.pageIndex);
            }
            updateMode(ie, Ce = null) {
              if (w(this, G) !== ie) {
                if (Se(this, G, ie), ie === d.AnnotationEditorType.NONE) {
                  this.setEditingState(!1), _e(this, fe, Vn).call(this);
                  return;
                }
                this.setEditingState(!0), _e(this, fe, Gn).call(this), this.unselectAll();
                for (const Ue of w(this, V).values())
                  Ue.updateMode(ie);
                if (Ce) {
                  for (const Ue of w(this, W).values())
                    if (Ue.annotationElementId === Ce) {
                      this.setSelected(Ue), Ue.enterInEditMode();
                      break;
                    }
                }
              }
            }
            updateToolbar(ie) {
              ie !== w(this, G) && this._eventBus.dispatch("switchannotationeditormode", {
                source: this,
                mode: ie
              });
            }
            updateParams(ie, Ce) {
              if (w(this, ae)) {
                if (ie === d.AnnotationEditorParamsType.CREATE) {
                  this.currentLayer.addNewEditor(ie);
                  return;
                }
                for (const Ue of w(this, Q))
                  Ue.updateParams(ie, Ce);
                for (const Ue of w(this, ae))
                  Ue.updateDefaultParams(ie, Ce);
              }
            }
            enableWaiting(ie = !1) {
              if (w(this, U) !== ie) {
                Se(this, U, ie);
                for (const Ce of w(this, V).values())
                  ie ? Ce.disableClick() : Ce.enableClick(), Ce.div.classList.toggle("waiting", ie);
              }
            }
            getEditors(ie) {
              const Ce = [];
              for (const Ue of w(this, W).values())
                Ue.pageIndex === ie && Ce.push(Ue);
              return Ce;
            }
            getEditor(ie) {
              return w(this, W).get(ie);
            }
            addEditor(ie) {
              w(this, W).set(ie.id, ie);
            }
            removeEditor(ie) {
              var Ce;
              w(this, W).delete(ie.id), this.unselect(ie), (!ie.annotationElementId || !w(this, ge).has(ie.annotationElementId)) && ((Ce = w(this, se)) == null || Ce.remove(ie.id));
            }
            addDeletedAnnotationElement(ie) {
              w(this, ge).add(ie.annotationElementId), ie.deleted = !0;
            }
            isDeletedAnnotationElement(ie) {
              return w(this, ge).has(ie);
            }
            removeDeletedAnnotationElement(ie) {
              w(this, ge).delete(ie.annotationElementId), ie.deleted = !1;
            }
            setActiveEditor(ie) {
              w(this, N) !== ie && (Se(this, N, ie), ie && _e(this, fe, Dt).call(this, ie.propertiesToUpdate));
            }
            toggleSelected(ie) {
              if (w(this, Q).has(ie)) {
                w(this, Q).delete(ie), ie.unselect(), _e(this, fe, $t).call(this, {
                  hasSelectedEditor: this.hasSelection
                });
                return;
              }
              w(this, Q).add(ie), ie.select(), _e(this, fe, Dt).call(this, ie.propertiesToUpdate), _e(this, fe, $t).call(this, {
                hasSelectedEditor: !0
              });
            }
            setSelected(ie) {
              for (const Ce of w(this, Q))
                Ce !== ie && Ce.unselect();
              w(this, Q).clear(), w(this, Q).add(ie), ie.select(), _e(this, fe, Dt).call(this, ie.propertiesToUpdate), _e(this, fe, $t).call(this, {
                hasSelectedEditor: !0
              });
            }
            isSelected(ie) {
              return w(this, Q).has(ie);
            }
            unselect(ie) {
              ie.unselect(), w(this, Q).delete(ie), _e(this, fe, $t).call(this, {
                hasSelectedEditor: this.hasSelection
              });
            }
            get hasSelection() {
              return w(this, Q).size !== 0;
            }
            undo() {
              w(this, ce).undo(), _e(this, fe, $t).call(this, {
                hasSomethingToUndo: w(this, ce).hasSomethingToUndo(),
                hasSomethingToRedo: !0,
                isEmpty: _e(this, fe, It).call(this)
              });
            }
            redo() {
              w(this, ce).redo(), _e(this, fe, $t).call(this, {
                hasSomethingToUndo: !0,
                hasSomethingToRedo: w(this, ce).hasSomethingToRedo(),
                isEmpty: _e(this, fe, It).call(this)
              });
            }
            addCommands(ie) {
              w(this, ce).add(ie), _e(this, fe, $t).call(this, {
                hasSomethingToUndo: !0,
                hasSomethingToRedo: !1,
                isEmpty: _e(this, fe, It).call(this)
              });
            }
            delete() {
              if (this.commitOrRemove(), !this.hasSelection)
                return;
              const ie = [...w(this, Q)], Ce = () => {
                for (const Ze of ie)
                  Ze.remove();
              }, Ue = () => {
                for (const Ze of ie)
                  _e(this, fe, _n).call(this, Ze);
              };
              this.addCommands({
                cmd: Ce,
                undo: Ue,
                mustExec: !0
              });
            }
            commitOrRemove() {
              var ie;
              (ie = w(this, N)) == null || ie.commitOrRemove();
            }
            hasSomethingToControl() {
              return w(this, N) || this.hasSelection;
            }
            selectAll() {
              for (const ie of w(this, Q))
                ie.commit();
              _e(this, fe, fn).call(this, w(this, W).values());
            }
            unselectAll() {
              if (w(this, N)) {
                w(this, N).commitOrRemove();
                return;
              }
              if (this.hasSelection) {
                for (const ie of w(this, Q))
                  ie.unselect();
                w(this, Q).clear(), _e(this, fe, $t).call(this, {
                  hasSelectedEditor: !1
                });
              }
            }
            translateSelectedEditors(ie, Ce, Ue = !1) {
              if (Ue || this.commitOrRemove(), !this.hasSelection)
                return;
              w(this, ye)[0] += ie, w(this, ye)[1] += Ce;
              const [Ze, Qe] = w(this, ye), We = [...w(this, Q)], ee = 1e3;
              w(this, xe) && clearTimeout(w(this, xe)), Se(this, xe, setTimeout(() => {
                Se(this, xe, null), w(this, ye)[0] = w(this, ye)[1] = 0, this.addCommands({
                  cmd: () => {
                    for (const K of We)
                      w(this, W).has(K.id) && K.translateInPage(Ze, Qe);
                  },
                  undo: () => {
                    for (const K of We)
                      w(this, W).has(K.id) && K.translateInPage(-Ze, -Qe);
                  },
                  mustExec: !1
                });
              }, ee));
              for (const K of We)
                K.translateInPage(ie, Ce);
            }
            setUpDragSession() {
              if (this.hasSelection) {
                this.disableUserSelect(!0), Se(this, J, /* @__PURE__ */ new Map());
                for (const ie of w(this, Q))
                  w(this, J).set(ie, {
                    savedX: ie.x,
                    savedY: ie.y,
                    savedPageIndex: ie.pageIndex,
                    newX: 0,
                    newY: 0,
                    newPageIndex: -1
                  });
              }
            }
            endDragSession() {
              if (!w(this, J))
                return !1;
              this.disableUserSelect(!1);
              const ie = w(this, J);
              Se(this, J, null);
              let Ce = !1;
              for (const [{
                x: Ze,
                y: Qe,
                pageIndex: We
              }, ee] of ie)
                ee.newX = Ze, ee.newY = Qe, ee.newPageIndex = We, Ce || (Ce = Ze !== ee.savedX || Qe !== ee.savedY || We !== ee.savedPageIndex);
              if (!Ce)
                return !1;
              const Ue = (Ze, Qe, We, ee) => {
                if (w(this, W).has(Ze.id)) {
                  const K = w(this, V).get(ee);
                  K ? Ze._setParentAndPosition(K, Qe, We) : (Ze.pageIndex = ee, Ze.x = Qe, Ze.y = We);
                }
              };
              return this.addCommands({
                cmd: () => {
                  for (const [Ze, {
                    newX: Qe,
                    newY: We,
                    newPageIndex: ee
                  }] of ie)
                    Ue(Ze, Qe, We, ee);
                },
                undo: () => {
                  for (const [Ze, {
                    savedX: Qe,
                    savedY: We,
                    savedPageIndex: ee
                  }] of ie)
                    Ue(Ze, Qe, We, ee);
                },
                mustExec: !0
              }), !0;
            }
            dragSelectedEditors(ie, Ce) {
              if (w(this, J))
                for (const Ue of w(this, J).keys())
                  Ue.drag(ie, Ce);
            }
            rebuild(ie) {
              if (ie.parent === null) {
                const Ce = this.getLayer(ie.pageIndex);
                Ce ? (Ce.changeParent(ie), Ce.addOrRebuild(ie)) : (this.addEditor(ie), this.addToAnnotationStorage(ie), ie.rebuild());
              } else
                ie.parent.addOrRebuild(ie);
            }
            isActive(ie) {
              return w(this, N) === ie;
            }
            getActive() {
              return w(this, N);
            }
            getMode() {
              return w(this, G);
            }
            get imageManager() {
              return (0, d.shadow)(this, "imageManager", new b());
            }
          };
          N = new WeakMap(), W = new WeakMap(), V = new WeakMap(), ue = new WeakMap(), se = new WeakMap(), ce = new WeakMap(), oe = new WeakMap(), ge = new WeakMap(), J = new WeakMap(), ae = new WeakMap(), le = new WeakMap(), z = new WeakMap(), A = new WeakMap(), F = new WeakMap(), U = new WeakMap(), Z = new WeakMap(), G = new WeakMap(), Q = new WeakMap(), he = new WeakMap(), me = new WeakMap(), Te = new WeakMap(), Pe = new WeakMap(), Re = new WeakMap(), Me = new WeakMap(), Fe = new WeakMap(), ve = new WeakMap(), be = new WeakMap(), X = new WeakMap(), ne = new WeakMap(), te = new WeakMap(), ye = new WeakMap(), xe = new WeakMap(), Le = new WeakMap(), Ie = new WeakMap(), fe = new WeakSet(), zn = function() {
            window.addEventListener("focus", w(this, Te)), window.addEventListener("blur", w(this, me));
          }, cn = function() {
            window.removeEventListener("focus", w(this, Te)), window.removeEventListener("blur", w(this, me));
          }, hn = function() {
            window.addEventListener("keydown", w(this, Fe), {
              capture: !0
            });
          }, qt = function() {
            window.removeEventListener("keydown", w(this, Fe), {
              capture: !0
            });
          }, dn = function() {
            document.addEventListener("copy", w(this, Pe)), document.addEventListener("cut", w(this, Re)), document.addEventListener("paste", w(this, Me));
          }, un = function() {
            document.removeEventListener("copy", w(this, Pe)), document.removeEventListener("cut", w(this, Re)), document.removeEventListener("paste", w(this, Me));
          }, $t = function(ie) {
            Object.entries(ie).some(([Ue, Ze]) => w(this, te)[Ue] !== Ze) && this._eventBus.dispatch("annotationeditorstateschanged", {
              source: this,
              details: Object.assign(w(this, te), ie)
            });
          }, Dt = function(ie) {
            this._eventBus.dispatch("annotationeditorparamschanged", {
              source: this,
              details: ie
            });
          }, Gn = function() {
            if (!w(this, F)) {
              Se(this, F, !0);
              for (const ie of w(this, V).values())
                ie.enable();
            }
          }, Vn = function() {
            if (this.unselectAll(), w(this, F)) {
              Se(this, F, !1);
              for (const ie of w(this, V).values())
                ie.disable();
            }
          }, _n = function(ie) {
            const Ce = w(this, V).get(ie.pageIndex);
            Ce ? Ce.addOrRebuild(ie) : this.addEditor(ie);
          }, It = function() {
            if (w(this, W).size === 0)
              return !0;
            if (w(this, W).size === 1)
              for (const ie of w(this, W).values())
                return ie.isEmpty();
            return !1;
          }, fn = function(ie) {
            w(this, Q).clear();
            for (const Ce of ie)
              Ce.isEmpty() || (w(this, Q).add(Ce), Ce.select());
            _e(this, fe, $t).call(this, {
              hasSelectedEditor: !0
            });
          }, _t(at, "TRANSLATE_SMALL", 1), _t(at, "TRANSLATE_BIG", 10);
          let S = at;
          a.AnnotationEditorUIManager = S;
        },
        /* 6 */
        /***/
        (c, a, h) => {
          var oe, ge, J, ae, le, z, A, F, U, Z, G, Q, Tt, kt, pn, jt, Wt, Ot, Ft;
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.StatTimer = a.RenderingCancelledException = a.PixelsPerInch = a.PageViewport = a.PDFDateString = a.DOMStandardFontDataFactory = a.DOMSVGFactory = a.DOMFilterFactory = a.DOMCanvasFactory = a.DOMCMapReaderFactory = void 0, a.deprecated = I, a.getColorValues = W, a.getCurrentTransform = V, a.getCurrentTransformInverse = ue, a.getFilenameFromUrl = C, a.getPdfFilenameFromUrl = O, a.getRGB = N, a.getXfaPageViewport = Y, a.isDataScheme = H, a.isPdfFile = T, a.isValidFetchUrl = B, a.loadScript = M, a.noContextMenu = D, a.setLayerDimensions = se;
          var d = h(7), u = h(1);
          const _ = "http://www.w3.org/2000/svg", ce = class ce {
          };
          _t(ce, "CSS", 96), _t(ce, "PDF", 72), _t(ce, "PDF_TO_CSS_UNITS", ce.CSS / ce.PDF);
          let g = ce;
          a.PixelsPerInch = g;
          class $ extends d.BaseFilterFactory {
            constructor({
              docId: X,
              ownerDocument: ne = globalThis.document
            } = {}) {
              super();
              Ee(this, Q);
              Ee(this, oe);
              Ee(this, ge);
              Ee(this, J);
              Ee(this, ae);
              Ee(this, le);
              Ee(this, z);
              Ee(this, A);
              Ee(this, F);
              Ee(this, U);
              Ee(this, Z);
              Ee(this, G, 0);
              Se(this, J, X), Se(this, ae, ne);
            }
            addFilter(X) {
              if (!X)
                return "none";
              let ne = w(this, Q, Tt).get(X);
              if (ne)
                return ne;
              let te, ye, xe, Le;
              if (X.length === 1) {
                const Be = X[0], st = new Array(256);
                for (let nt = 0; nt < 256; nt++)
                  st[nt] = Be[nt] / 255;
                Le = te = ye = xe = st.join(",");
              } else {
                const [Be, st, nt] = X, ht = new Array(256), Ve = new Array(256), et = new Array(256);
                for (let lt = 0; lt < 256; lt++)
                  ht[lt] = Be[lt] / 255, Ve[lt] = st[lt] / 255, et[lt] = nt[lt] / 255;
                te = ht.join(","), ye = Ve.join(","), xe = et.join(","), Le = `${te}${ye}${xe}`;
              }
              if (ne = w(this, Q, Tt).get(Le), ne)
                return w(this, Q, Tt).set(X, ne), ne;
              const Ie = `g_${w(this, J)}_transfer_map_${Mt(this, G)._++}`, fe = `url(#${Ie})`;
              w(this, Q, Tt).set(X, fe), w(this, Q, Tt).set(Le, fe);
              const He = _e(this, Q, jt).call(this, Ie);
              return _e(this, Q, Ot).call(this, te, ye, xe, He), fe;
            }
            addHCMFilter(X, ne) {
              var st;
              const te = `${X}-${ne}`;
              if (w(this, z) === te)
                return w(this, A);
              if (Se(this, z, te), Se(this, A, "none"), (st = w(this, le)) == null || st.remove(), !X || !ne)
                return w(this, A);
              const ye = _e(this, Q, Ft).call(this, X);
              X = u.Util.makeHexColor(...ye);
              const xe = _e(this, Q, Ft).call(this, ne);
              if (ne = u.Util.makeHexColor(...xe), w(this, Q, kt).style.color = "", X === "#000000" && ne === "#ffffff" || X === ne)
                return w(this, A);
              const Le = new Array(256);
              for (let nt = 0; nt <= 255; nt++) {
                const ht = nt / 255;
                Le[nt] = ht <= 0.03928 ? ht / 12.92 : ((ht + 0.055) / 1.055) ** 2.4;
              }
              const Ie = Le.join(","), fe = `g_${w(this, J)}_hcm_filter`, He = Se(this, F, _e(this, Q, jt).call(this, fe));
              _e(this, Q, Ot).call(this, Ie, Ie, Ie, He), _e(this, Q, pn).call(this, He);
              const Be = (nt, ht) => {
                const Ve = ye[nt] / 255, et = xe[nt] / 255, lt = new Array(ht + 1);
                for (let dt = 0; dt <= ht; dt++)
                  lt[dt] = Ve + dt / ht * (et - Ve);
                return lt.join(",");
              };
              return _e(this, Q, Ot).call(this, Be(0, 5), Be(1, 5), Be(2, 5), He), Se(this, A, `url(#${fe})`), w(this, A);
            }
            addHighlightHCMFilter(X, ne, te, ye) {
              var et;
              const xe = `${X}-${ne}-${te}-${ye}`;
              if (w(this, U) === xe)
                return w(this, Z);
              if (Se(this, U, xe), Se(this, Z, "none"), (et = w(this, F)) == null || et.remove(), !X || !ne)
                return w(this, Z);
              const [Le, Ie] = [X, ne].map(_e(this, Q, Ft).bind(this));
              let fe = Math.round(0.2126 * Le[0] + 0.7152 * Le[1] + 0.0722 * Le[2]), He = Math.round(0.2126 * Ie[0] + 0.7152 * Ie[1] + 0.0722 * Ie[2]), [Be, st] = [te, ye].map(_e(this, Q, Ft).bind(this));
              He < fe && ([fe, He, Be, st] = [He, fe, st, Be]), w(this, Q, kt).style.color = "";
              const nt = (lt, dt, De) => {
                const $e = new Array(256), we = (He - fe) / De, ze = lt / 255, at = (dt - lt) / (255 * De);
                let ct = 0;
                for (let ie = 0; ie <= De; ie++) {
                  const Ce = Math.round(fe + ie * we), Ue = ze + ie * at;
                  for (let Ze = ct; Ze <= Ce; Ze++)
                    $e[Ze] = Ue;
                  ct = Ce + 1;
                }
                for (let ie = ct; ie < 256; ie++)
                  $e[ie] = $e[ct - 1];
                return $e.join(",");
              }, ht = `g_${w(this, J)}_hcm_highlight_filter`, Ve = Se(this, F, _e(this, Q, jt).call(this, ht));
              return _e(this, Q, pn).call(this, Ve), _e(this, Q, Ot).call(this, nt(Be[0], st[0], 5), nt(Be[1], st[1], 5), nt(Be[2], st[2], 5), Ve), Se(this, Z, `url(#${ht})`), w(this, Z);
            }
            destroy(X = !1) {
              X && (w(this, A) || w(this, Z)) || (w(this, ge) && (w(this, ge).parentNode.parentNode.remove(), Se(this, ge, null)), w(this, oe) && (w(this, oe).clear(), Se(this, oe, null)), Se(this, G, 0));
            }
          }
          oe = new WeakMap(), ge = new WeakMap(), J = new WeakMap(), ae = new WeakMap(), le = new WeakMap(), z = new WeakMap(), A = new WeakMap(), F = new WeakMap(), U = new WeakMap(), Z = new WeakMap(), G = new WeakMap(), Q = new WeakSet(), Tt = function() {
            return w(this, oe) || Se(this, oe, /* @__PURE__ */ new Map());
          }, kt = function() {
            if (!w(this, ge)) {
              const X = w(this, ae).createElement("div"), {
                style: ne
              } = X;
              ne.visibility = "hidden", ne.contain = "strict", ne.width = ne.height = 0, ne.position = "absolute", ne.top = ne.left = 0, ne.zIndex = -1;
              const te = w(this, ae).createElementNS(_, "svg");
              te.setAttribute("width", 0), te.setAttribute("height", 0), Se(this, ge, w(this, ae).createElementNS(_, "defs")), X.append(te), te.append(w(this, ge)), w(this, ae).body.append(X);
            }
            return w(this, ge);
          }, pn = function(X) {
            const ne = w(this, ae).createElementNS(_, "feColorMatrix");
            ne.setAttribute("type", "matrix"), ne.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), X.append(ne);
          }, jt = function(X) {
            const ne = w(this, ae).createElementNS(_, "filter");
            return ne.setAttribute("color-interpolation-filters", "sRGB"), ne.setAttribute("id", X), w(this, Q, kt).append(ne), ne;
          }, Wt = function(X, ne, te) {
            const ye = w(this, ae).createElementNS(_, ne);
            ye.setAttribute("type", "discrete"), ye.setAttribute("tableValues", te), X.append(ye);
          }, Ot = function(X, ne, te, ye) {
            const xe = w(this, ae).createElementNS(_, "feComponentTransfer");
            ye.append(xe), _e(this, Q, Wt).call(this, xe, "feFuncR", X), _e(this, Q, Wt).call(this, xe, "feFuncG", ne), _e(this, Q, Wt).call(this, xe, "feFuncB", te);
          }, Ft = function(X) {
            return w(this, Q, kt).style.color = X, N(getComputedStyle(w(this, Q, kt)).getPropertyValue("color"));
          }, a.DOMFilterFactory = $;
          class b extends d.BaseCanvasFactory {
            constructor({
              ownerDocument: be = globalThis.document
            } = {}) {
              super(), this._document = be;
            }
            _createCanvas(be, X) {
              const ne = this._document.createElement("canvas");
              return ne.width = be, ne.height = X, ne;
            }
          }
          a.DOMCanvasFactory = b;
          async function y(ve, be = !1) {
            if (B(ve, document.baseURI)) {
              const X = await fetch(ve);
              if (!X.ok)
                throw new Error(X.statusText);
              return be ? new Uint8Array(await X.arrayBuffer()) : (0, u.stringToBytes)(await X.text());
            }
            return new Promise((X, ne) => {
              const te = new XMLHttpRequest();
              te.open("GET", ve, !0), be && (te.responseType = "arraybuffer"), te.onreadystatechange = () => {
                if (te.readyState === XMLHttpRequest.DONE) {
                  if (te.status === 200 || te.status === 0) {
                    let ye;
                    if (be && te.response ? ye = new Uint8Array(te.response) : !be && te.responseText && (ye = (0, u.stringToBytes)(te.responseText)), ye) {
                      X(ye);
                      return;
                    }
                  }
                  ne(new Error(te.statusText));
                }
              }, te.send(null);
            });
          }
          class v extends d.BaseCMapReaderFactory {
            _fetchData(be, X) {
              return y(be, this.isCompressed).then((ne) => ({
                cMapData: ne,
                compressionType: X
              }));
            }
          }
          a.DOMCMapReaderFactory = v;
          class E extends d.BaseStandardFontDataFactory {
            _fetchData(be) {
              return y(be, !0);
            }
          }
          a.DOMStandardFontDataFactory = E;
          class S extends d.BaseSVGFactory {
            _createSVG(be) {
              return document.createElementNS(_, be);
            }
          }
          a.DOMSVGFactory = S;
          class R {
            constructor({
              viewBox: be,
              scale: X,
              rotation: ne,
              offsetX: te = 0,
              offsetY: ye = 0,
              dontFlip: xe = !1
            }) {
              this.viewBox = be, this.scale = X, this.rotation = ne, this.offsetX = te, this.offsetY = ye;
              const Le = (be[2] + be[0]) / 2, Ie = (be[3] + be[1]) / 2;
              let fe, He, Be, st;
              switch (ne %= 360, ne < 0 && (ne += 360), ne) {
                case 180:
                  fe = -1, He = 0, Be = 0, st = 1;
                  break;
                case 90:
                  fe = 0, He = 1, Be = 1, st = 0;
                  break;
                case 270:
                  fe = 0, He = -1, Be = -1, st = 0;
                  break;
                case 0:
                  fe = 1, He = 0, Be = 0, st = -1;
                  break;
                default:
                  throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
              }
              xe && (Be = -Be, st = -st);
              let nt, ht, Ve, et;
              fe === 0 ? (nt = Math.abs(Ie - be[1]) * X + te, ht = Math.abs(Le - be[0]) * X + ye, Ve = (be[3] - be[1]) * X, et = (be[2] - be[0]) * X) : (nt = Math.abs(Le - be[0]) * X + te, ht = Math.abs(Ie - be[1]) * X + ye, Ve = (be[2] - be[0]) * X, et = (be[3] - be[1]) * X), this.transform = [fe * X, He * X, Be * X, st * X, nt - fe * X * Le - Be * X * Ie, ht - He * X * Le - st * X * Ie], this.width = Ve, this.height = et;
            }
            get rawDims() {
              const {
                viewBox: be
              } = this;
              return (0, u.shadow)(this, "rawDims", {
                pageWidth: be[2] - be[0],
                pageHeight: be[3] - be[1],
                pageX: be[0],
                pageY: be[1]
              });
            }
            clone({
              scale: be = this.scale,
              rotation: X = this.rotation,
              offsetX: ne = this.offsetX,
              offsetY: te = this.offsetY,
              dontFlip: ye = !1
            } = {}) {
              return new R({
                viewBox: this.viewBox.slice(),
                scale: be,
                rotation: X,
                offsetX: ne,
                offsetY: te,
                dontFlip: ye
              });
            }
            convertToViewportPoint(be, X) {
              return u.Util.applyTransform([be, X], this.transform);
            }
            convertToViewportRectangle(be) {
              const X = u.Util.applyTransform([be[0], be[1]], this.transform), ne = u.Util.applyTransform([be[2], be[3]], this.transform);
              return [X[0], X[1], ne[0], ne[1]];
            }
            convertToPdfPoint(be, X) {
              return u.Util.applyInverseTransform([be, X], this.transform);
            }
          }
          a.PageViewport = R;
          class x extends u.BaseException {
            constructor(be, X = 0) {
              super(be, "RenderingCancelledException"), this.extraDelay = X;
            }
          }
          a.RenderingCancelledException = x;
          function H(ve) {
            const be = ve.length;
            let X = 0;
            for (; X < be && ve[X].trim() === ""; )
              X++;
            return ve.substring(X, X + 5).toLowerCase() === "data:";
          }
          function T(ve) {
            return typeof ve == "string" && /\.pdf$/i.test(ve);
          }
          function C(ve, be = !1) {
            return be || ([ve] = ve.split(/[#?]/, 1)), ve.substring(ve.lastIndexOf("/") + 1);
          }
          function O(ve, be = "document.pdf") {
            if (typeof ve != "string")
              return be;
            if (H(ve))
              return (0, u.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), be;
            const X = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, ne = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, te = X.exec(ve);
            let ye = ne.exec(te[1]) || ne.exec(te[2]) || ne.exec(te[3]);
            if (ye && (ye = ye[0], ye.includes("%")))
              try {
                ye = ne.exec(decodeURIComponent(ye))[0];
              } catch {
              }
            return ye || be;
          }
          class j {
            constructor() {
              _t(this, "started", /* @__PURE__ */ Object.create(null));
              _t(this, "times", []);
            }
            time(be) {
              be in this.started && (0, u.warn)(`Timer is already running for ${be}`), this.started[be] = Date.now();
            }
            timeEnd(be) {
              be in this.started || (0, u.warn)(`Timer has not been started for ${be}`), this.times.push({
                name: be,
                start: this.started[be],
                end: Date.now()
              }), delete this.started[be];
            }
            toString() {
              const be = [];
              let X = 0;
              for (const {
                name: ne
              } of this.times)
                X = Math.max(ne.length, X);
              for (const {
                name: ne,
                start: te,
                end: ye
              } of this.times)
                be.push(`${ne.padEnd(X)} ${ye - te}ms
`);
              return be.join("");
            }
          }
          a.StatTimer = j;
          function B(ve, be) {
            try {
              const {
                protocol: X
              } = be ? new URL(ve, be) : new URL(ve);
              return X === "http:" || X === "https:";
            } catch {
              return !1;
            }
          }
          function D(ve) {
            ve.preventDefault();
          }
          function M(ve, be = !1) {
            return new Promise((X, ne) => {
              const te = document.createElement("script");
              te.src = ve, te.onload = function(ye) {
                be && te.remove(), X(ye);
              }, te.onerror = function() {
                ne(new Error(`Cannot load script at: ${te.src}`));
              }, (document.head || document.documentElement).append(te);
            });
          }
          function I(ve) {
            console.log("Deprecated API usage: " + ve);
          }
          let P;
          class L {
            static toDateObject(be) {
              if (!be || typeof be != "string")
                return null;
              P || (P = new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"));
              const X = P.exec(be);
              if (!X)
                return null;
              const ne = parseInt(X[1], 10);
              let te = parseInt(X[2], 10);
              te = te >= 1 && te <= 12 ? te - 1 : 0;
              let ye = parseInt(X[3], 10);
              ye = ye >= 1 && ye <= 31 ? ye : 1;
              let xe = parseInt(X[4], 10);
              xe = xe >= 0 && xe <= 23 ? xe : 0;
              let Le = parseInt(X[5], 10);
              Le = Le >= 0 && Le <= 59 ? Le : 0;
              let Ie = parseInt(X[6], 10);
              Ie = Ie >= 0 && Ie <= 59 ? Ie : 0;
              const fe = X[7] || "Z";
              let He = parseInt(X[8], 10);
              He = He >= 0 && He <= 23 ? He : 0;
              let Be = parseInt(X[9], 10) || 0;
              return Be = Be >= 0 && Be <= 59 ? Be : 0, fe === "-" ? (xe += He, Le += Be) : fe === "+" && (xe -= He, Le -= Be), new Date(Date.UTC(ne, te, ye, xe, Le, Ie));
            }
          }
          a.PDFDateString = L;
          function Y(ve, {
            scale: be = 1,
            rotation: X = 0
          }) {
            const {
              width: ne,
              height: te
            } = ve.attributes.style, ye = [0, 0, parseInt(ne), parseInt(te)];
            return new R({
              viewBox: ye,
              scale: be,
              rotation: X
            });
          }
          function N(ve) {
            if (ve.startsWith("#")) {
              const be = parseInt(ve.slice(1), 16);
              return [(be & 16711680) >> 16, (be & 65280) >> 8, be & 255];
            }
            return ve.startsWith("rgb(") ? ve.slice(4, -1).split(",").map((be) => parseInt(be)) : ve.startsWith("rgba(") ? ve.slice(5, -1).split(",").map((be) => parseInt(be)).slice(0, 3) : ((0, u.warn)(`Not a valid color format: "${ve}"`), [0, 0, 0]);
          }
          function W(ve) {
            const be = document.createElement("span");
            be.style.visibility = "hidden", document.body.append(be);
            for (const X of ve.keys()) {
              be.style.color = X;
              const ne = window.getComputedStyle(be).color;
              ve.set(X, N(ne));
            }
            be.remove();
          }
          function V(ve) {
            const {
              a: be,
              b: X,
              c: ne,
              d: te,
              e: ye,
              f: xe
            } = ve.getTransform();
            return [be, X, ne, te, ye, xe];
          }
          function ue(ve) {
            const {
              a: be,
              b: X,
              c: ne,
              d: te,
              e: ye,
              f: xe
            } = ve.getTransform().invertSelf();
            return [be, X, ne, te, ye, xe];
          }
          function se(ve, be, X = !1, ne = !0) {
            if (be instanceof R) {
              const {
                pageWidth: te,
                pageHeight: ye
              } = be.rawDims, {
                style: xe
              } = ve, Le = u.FeatureTest.isCSSRoundSupported, Ie = `var(--scale-factor) * ${te}px`, fe = `var(--scale-factor) * ${ye}px`, He = Le ? `round(${Ie}, 1px)` : `calc(${Ie})`, Be = Le ? `round(${fe}, 1px)` : `calc(${fe})`;
              !X || be.rotation % 180 === 0 ? (xe.width = He, xe.height = Be) : (xe.width = Be, xe.height = He);
            }
            ne && ve.setAttribute("data-main-rotation", be.rotation);
          }
        },
        /* 7 */
        /***/
        (c, a, h) => {
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.BaseStandardFontDataFactory = a.BaseSVGFactory = a.BaseFilterFactory = a.BaseCanvasFactory = a.BaseCMapReaderFactory = void 0;
          var d = h(1);
          class u {
            constructor() {
              this.constructor === u && (0, d.unreachable)("Cannot initialize BaseFilterFactory.");
            }
            addFilter(v) {
              return "none";
            }
            addHCMFilter(v, E) {
              return "none";
            }
            addHighlightHCMFilter(v, E, S, R) {
              return "none";
            }
            destroy(v = !1) {
            }
          }
          a.BaseFilterFactory = u;
          class _ {
            constructor() {
              this.constructor === _ && (0, d.unreachable)("Cannot initialize BaseCanvasFactory.");
            }
            create(v, E) {
              if (v <= 0 || E <= 0)
                throw new Error("Invalid canvas size");
              const S = this._createCanvas(v, E);
              return {
                canvas: S,
                context: S.getContext("2d")
              };
            }
            reset(v, E, S) {
              if (!v.canvas)
                throw new Error("Canvas is not specified");
              if (E <= 0 || S <= 0)
                throw new Error("Invalid canvas size");
              v.canvas.width = E, v.canvas.height = S;
            }
            destroy(v) {
              if (!v.canvas)
                throw new Error("Canvas is not specified");
              v.canvas.width = 0, v.canvas.height = 0, v.canvas = null, v.context = null;
            }
            _createCanvas(v, E) {
              (0, d.unreachable)("Abstract method `_createCanvas` called.");
            }
          }
          a.BaseCanvasFactory = _;
          class g {
            constructor({
              baseUrl: v = null,
              isCompressed: E = !0
            }) {
              this.constructor === g && (0, d.unreachable)("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = v, this.isCompressed = E;
            }
            async fetch({
              name: v
            }) {
              if (!this.baseUrl)
                throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.');
              if (!v)
                throw new Error("CMap name must be specified.");
              const E = this.baseUrl + v + (this.isCompressed ? ".bcmap" : ""), S = this.isCompressed ? d.CMapCompressionType.BINARY : d.CMapCompressionType.NONE;
              return this._fetchData(E, S).catch((R) => {
                throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${E}`);
              });
            }
            _fetchData(v, E) {
              (0, d.unreachable)("Abstract method `_fetchData` called.");
            }
          }
          a.BaseCMapReaderFactory = g;
          class $ {
            constructor({
              baseUrl: v = null
            }) {
              this.constructor === $ && (0, d.unreachable)("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = v;
            }
            async fetch({
              filename: v
            }) {
              if (!this.baseUrl)
                throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.');
              if (!v)
                throw new Error("Font filename must be specified.");
              const E = `${this.baseUrl}${v}`;
              return this._fetchData(E).catch((S) => {
                throw new Error(`Unable to load font data at: ${E}`);
              });
            }
            _fetchData(v) {
              (0, d.unreachable)("Abstract method `_fetchData` called.");
            }
          }
          a.BaseStandardFontDataFactory = $;
          class b {
            constructor() {
              this.constructor === b && (0, d.unreachable)("Cannot initialize BaseSVGFactory.");
            }
            create(v, E, S = !1) {
              if (v <= 0 || E <= 0)
                throw new Error("Invalid SVG dimensions");
              const R = this._createSVG("svg:svg");
              return R.setAttribute("version", "1.1"), S || (R.setAttribute("width", `${v}px`), R.setAttribute("height", `${E}px`)), R.setAttribute("preserveAspectRatio", "none"), R.setAttribute("viewBox", `0 0 ${v} ${E}`), R;
            }
            createElement(v) {
              if (typeof v != "string")
                throw new Error("Invalid SVG element type");
              return this._createSVG(v);
            }
            _createSVG(v) {
              (0, d.unreachable)("Abstract method `_createSVG` called.");
            }
          }
          a.BaseSVGFactory = b;
        },
        /* 8 */
        /***/
        (c, a, h) => {
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.MurmurHash3_64 = void 0;
          var d = h(1);
          const u = 3285377520, _ = 4294901760, g = 65535;
          class $ {
            constructor(y) {
              this.h1 = y ? y & 4294967295 : u, this.h2 = y ? y & 4294967295 : u;
            }
            update(y) {
              let v, E;
              if (typeof y == "string") {
                v = new Uint8Array(y.length * 2), E = 0;
                for (let I = 0, P = y.length; I < P; I++) {
                  const L = y.charCodeAt(I);
                  L <= 255 ? v[E++] = L : (v[E++] = L >>> 8, v[E++] = L & 255);
                }
              } else if ((0, d.isArrayBuffer)(y))
                v = y.slice(), E = v.byteLength;
              else
                throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array.");
              const S = E >> 2, R = E - S * 4, x = new Uint32Array(v.buffer, 0, S);
              let H = 0, T = 0, C = this.h1, O = this.h2;
              const j = 3432918353, B = 461845907, D = j & g, M = B & g;
              for (let I = 0; I < S; I++)
                I & 1 ? (H = x[I], H = H * j & _ | H * D & g, H = H << 15 | H >>> 17, H = H * B & _ | H * M & g, C ^= H, C = C << 13 | C >>> 19, C = C * 5 + 3864292196) : (T = x[I], T = T * j & _ | T * D & g, T = T << 15 | T >>> 17, T = T * B & _ | T * M & g, O ^= T, O = O << 13 | O >>> 19, O = O * 5 + 3864292196);
              switch (H = 0, R) {
                case 3:
                  H ^= v[S * 4 + 2] << 16;
                case 2:
                  H ^= v[S * 4 + 1] << 8;
                case 1:
                  H ^= v[S * 4], H = H * j & _ | H * D & g, H = H << 15 | H >>> 17, H = H * B & _ | H * M & g, S & 1 ? C ^= H : O ^= H;
              }
              this.h1 = C, this.h2 = O;
            }
            hexdigest() {
              let y = this.h1, v = this.h2;
              return y ^= v >>> 1, y = y * 3981806797 & _ | y * 36045 & g, v = v * 4283543511 & _ | ((v << 16 | y >>> 16) * 2950163797 & _) >>> 16, y ^= v >>> 1, y = y * 444984403 & _ | y * 60499 & g, v = v * 3301882366 & _ | ((v << 16 | y >>> 16) * 3120437893 & _) >>> 16, y ^= v >>> 1, (y >>> 0).toString(16).padStart(8, "0") + (v >>> 0).toString(16).padStart(8, "0");
            }
          }
          a.MurmurHash3_64 = $;
        },
        /* 9 */
        /***/
        (c, a, h) => {
          var g;
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.FontLoader = a.FontFaceObject = void 0;
          var d = h(1);
          class u {
            constructor({
              ownerDocument: b = globalThis.document,
              styleElement: y = null
            }) {
              Ee(this, g, /* @__PURE__ */ new Set());
              this._document = b, this.nativeFontFaces = /* @__PURE__ */ new Set(), this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0;
            }
            addNativeFontFace(b) {
              this.nativeFontFaces.add(b), this._document.fonts.add(b);
            }
            removeNativeFontFace(b) {
              this.nativeFontFaces.delete(b), this._document.fonts.delete(b);
            }
            insertRule(b) {
              this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement));
              const y = this.styleElement.sheet;
              y.insertRule(b, y.cssRules.length);
            }
            clear() {
              for (const b of this.nativeFontFaces)
                this._document.fonts.delete(b);
              this.nativeFontFaces.clear(), w(this, g).clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null);
            }
            async loadSystemFont(b) {
              if (!(!b || w(this, g).has(b.loadedName))) {
                if ((0, d.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) {
                  const {
                    loadedName: y,
                    src: v,
                    style: E
                  } = b, S = new FontFace(y, v, E);
                  this.addNativeFontFace(S);
                  try {
                    await S.load(), w(this, g).add(y);
                  } catch {
                    (0, d.warn)(`Cannot load system font: ${b.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(S);
                  }
                  return;
                }
                (0, d.unreachable)("Not implemented: loadSystemFont without the Font Loading API.");
              }
            }
            async bind(b) {
              if (b.attached || b.missingFile && !b.systemFontInfo)
                return;
              if (b.attached = !0, b.systemFontInfo) {
                await this.loadSystemFont(b.systemFontInfo);
                return;
              }
              if (this.isFontLoadingAPISupported) {
                const v = b.createNativeFontFace();
                if (v) {
                  this.addNativeFontFace(v);
                  try {
                    await v.loaded;
                  } catch (E) {
                    throw (0, d.warn)(`Failed to load font '${v.family}': '${E}'.`), b.disableFontFace = !0, E;
                  }
                }
                return;
              }
              const y = b.createFontFaceRule();
              if (y) {
                if (this.insertRule(y), this.isSyncFontLoadingSupported)
                  return;
                await new Promise((v) => {
                  const E = this._queueLoadingCallback(v);
                  this._prepareFontLoadEvent(b, E);
                });
              }
            }
            get isFontLoadingAPISupported() {
              var y;
              const b = !!((y = this._document) != null && y.fonts);
              return (0, d.shadow)(this, "isFontLoadingAPISupported", b);
            }
            get isSyncFontLoadingSupported() {
              let b = !1;
              return (d.isNodeJS || typeof navigator < "u" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (b = !0), (0, d.shadow)(this, "isSyncFontLoadingSupported", b);
            }
            _queueLoadingCallback(b) {
              function y() {
                for ((0, d.assert)(!E.done, "completeRequest() cannot be called twice."), E.done = !0; v.length > 0 && v[0].done; ) {
                  const S = v.shift();
                  setTimeout(S.callback, 0);
                }
              }
              const {
                loadingRequests: v
              } = this, E = {
                done: !1,
                complete: y,
                callback: b
              };
              return v.push(E), E;
            }
            get _loadTestFont() {
              const b = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
              return (0, d.shadow)(this, "_loadTestFont", b);
            }
            _prepareFontLoadEvent(b, y) {
              function v(N, W) {
                return N.charCodeAt(W) << 24 | N.charCodeAt(W + 1) << 16 | N.charCodeAt(W + 2) << 8 | N.charCodeAt(W + 3) & 255;
              }
              function E(N, W, V, ue) {
                const se = N.substring(0, W), ce = N.substring(W + V);
                return se + ue + ce;
              }
              let S, R;
              const x = this._document.createElement("canvas");
              x.width = 1, x.height = 1;
              const H = x.getContext("2d");
              let T = 0;
              function C(N, W) {
                if (++T > 30) {
                  (0, d.warn)("Load test font never loaded."), W();
                  return;
                }
                if (H.font = "30px " + N, H.fillText(".", 0, 20), H.getImageData(0, 0, 1, 1).data[3] > 0) {
                  W();
                  return;
                }
                setTimeout(C.bind(null, N, W));
              }
              const O = `lt${Date.now()}${this.loadTestFontId++}`;
              let j = this._loadTestFont;
              j = E(j, 976, O.length, O);
              const D = 16, M = 1482184792;
              let I = v(j, D);
              for (S = 0, R = O.length - 3; S < R; S += 4)
                I = I - M + v(O, S) | 0;
              S < O.length && (I = I - M + v(O + "XXX", S) | 0), j = E(j, D, 4, (0, d.string32)(I));
              const P = `url(data:font/opentype;base64,${btoa(j)});`, L = `@font-face {font-family:"${O}";src:${P}}`;
              this.insertRule(L);
              const Y = this._document.createElement("div");
              Y.style.visibility = "hidden", Y.style.width = Y.style.height = "10px", Y.style.position = "absolute", Y.style.top = Y.style.left = "0px";
              for (const N of [b.loadedName, O]) {
                const W = this._document.createElement("span");
                W.textContent = "Hi", W.style.fontFamily = N, Y.append(W);
              }
              this._document.body.append(Y), C(O, () => {
                Y.remove(), y.complete();
              });
            }
          }
          g = new WeakMap(), a.FontLoader = u;
          class _ {
            constructor(b, {
              isEvalSupported: y = !0,
              disableFontFace: v = !1,
              ignoreErrors: E = !1,
              inspectFont: S = null
            }) {
              this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
              for (const R in b)
                this[R] = b[R];
              this.isEvalSupported = y !== !1, this.disableFontFace = v === !0, this.ignoreErrors = E === !0, this._inspectFont = S;
            }
            createNativeFontFace() {
              var y;
              if (!this.data || this.disableFontFace)
                return null;
              let b;
              if (!this.cssFontInfo)
                b = new FontFace(this.loadedName, this.data, {});
              else {
                const v = {
                  weight: this.cssFontInfo.fontWeight
                };
                this.cssFontInfo.italicAngle && (v.style = `oblique ${this.cssFontInfo.italicAngle}deg`), b = new FontFace(this.cssFontInfo.fontFamily, this.data, v);
              }
              return (y = this._inspectFont) == null || y.call(this, this), b;
            }
            createFontFaceRule() {
              var E;
              if (!this.data || this.disableFontFace)
                return null;
              const b = (0, d.bytesToString)(this.data), y = `url(data:${this.mimetype};base64,${btoa(b)});`;
              let v;
              if (!this.cssFontInfo)
                v = `@font-face {font-family:"${this.loadedName}";src:${y}}`;
              else {
                let S = `font-weight: ${this.cssFontInfo.fontWeight};`;
                this.cssFontInfo.italicAngle && (S += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), v = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${S}src:${y}}`;
              }
              return (E = this._inspectFont) == null || E.call(this, this, y), v;
            }
            getPathGenerator(b, y) {
              if (this.compiledGlyphs[y] !== void 0)
                return this.compiledGlyphs[y];
              let v;
              try {
                v = b.get(this.loadedName + "_path_" + y);
              } catch (E) {
                if (!this.ignoreErrors)
                  throw E;
                return (0, d.warn)(`getPathGenerator - ignoring character: "${E}".`), this.compiledGlyphs[y] = function(S, R) {
                };
              }
              if (this.isEvalSupported && d.FeatureTest.isEvalSupported) {
                const E = [];
                for (const S of v) {
                  const R = S.args !== void 0 ? S.args.join(",") : "";
                  E.push("c.", S.cmd, "(", R, `);
`);
                }
                return this.compiledGlyphs[y] = new Function("c", "size", E.join(""));
              }
              return this.compiledGlyphs[y] = function(E, S) {
                for (const R of v)
                  R.cmd === "scale" && (R.args = [S, -S]), E[R.cmd].apply(E, R.args);
              };
            }
          }
          a.FontFaceObject = _;
        },
        /* 10 */
        /***/
        (c, a, h) => {
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.NodeStandardFontDataFactory = a.NodeFilterFactory = a.NodeCanvasFactory = a.NodeCMapReaderFactory = void 0;
          var d = h(7);
          h(1);
          const u = function(y) {
            return new Promise((v, E) => {
              require$$5.readFile(y, (R, x) => {
                if (R || !x) {
                  E(new Error(R));
                  return;
                }
                v(new Uint8Array(x));
              });
            });
          };
          class _ extends d.BaseFilterFactory {
          }
          a.NodeFilterFactory = _;
          class g extends d.BaseCanvasFactory {
            _createCanvas(v, E) {
              return require$$5.createCanvas(v, E);
            }
          }
          a.NodeCanvasFactory = g;
          class $ extends d.BaseCMapReaderFactory {
            _fetchData(v, E) {
              return u(v).then((S) => ({
                cMapData: S,
                compressionType: E
              }));
            }
          }
          a.NodeCMapReaderFactory = $;
          class b extends d.BaseStandardFontDataFactory {
            _fetchData(v) {
              return u(v);
            }
          }
          a.NodeStandardFontDataFactory = b;
        },
        /* 11 */
        /***/
        (c, a, h) => {
          var ge, mn, gn;
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.CanvasGraphics = void 0;
          var d = h(1), u = h(6), _ = h(12), g = h(13);
          const $ = 16, b = 100, y = 4096, v = 15, E = 10, S = 1e3, R = 16;
          function x(z, A) {
            if (z._removeMirroring)
              throw new Error("Context is already forwarding operations.");
            z.__originalSave = z.save, z.__originalRestore = z.restore, z.__originalRotate = z.rotate, z.__originalScale = z.scale, z.__originalTranslate = z.translate, z.__originalTransform = z.transform, z.__originalSetTransform = z.setTransform, z.__originalResetTransform = z.resetTransform, z.__originalClip = z.clip, z.__originalMoveTo = z.moveTo, z.__originalLineTo = z.lineTo, z.__originalBezierCurveTo = z.bezierCurveTo, z.__originalRect = z.rect, z.__originalClosePath = z.closePath, z.__originalBeginPath = z.beginPath, z._removeMirroring = () => {
              z.save = z.__originalSave, z.restore = z.__originalRestore, z.rotate = z.__originalRotate, z.scale = z.__originalScale, z.translate = z.__originalTranslate, z.transform = z.__originalTransform, z.setTransform = z.__originalSetTransform, z.resetTransform = z.__originalResetTransform, z.clip = z.__originalClip, z.moveTo = z.__originalMoveTo, z.lineTo = z.__originalLineTo, z.bezierCurveTo = z.__originalBezierCurveTo, z.rect = z.__originalRect, z.closePath = z.__originalClosePath, z.beginPath = z.__originalBeginPath, delete z._removeMirroring;
            }, z.save = function() {
              A.save(), this.__originalSave();
            }, z.restore = function() {
              A.restore(), this.__originalRestore();
            }, z.translate = function(U, Z) {
              A.translate(U, Z), this.__originalTranslate(U, Z);
            }, z.scale = function(U, Z) {
              A.scale(U, Z), this.__originalScale(U, Z);
            }, z.transform = function(U, Z, G, Q, he, me) {
              A.transform(U, Z, G, Q, he, me), this.__originalTransform(U, Z, G, Q, he, me);
            }, z.setTransform = function(U, Z, G, Q, he, me) {
              A.setTransform(U, Z, G, Q, he, me), this.__originalSetTransform(U, Z, G, Q, he, me);
            }, z.resetTransform = function() {
              A.resetTransform(), this.__originalResetTransform();
            }, z.rotate = function(U) {
              A.rotate(U), this.__originalRotate(U);
            }, z.clip = function(U) {
              A.clip(U), this.__originalClip(U);
            }, z.moveTo = function(F, U) {
              A.moveTo(F, U), this.__originalMoveTo(F, U);
            }, z.lineTo = function(F, U) {
              A.lineTo(F, U), this.__originalLineTo(F, U);
            }, z.bezierCurveTo = function(F, U, Z, G, Q, he) {
              A.bezierCurveTo(F, U, Z, G, Q, he), this.__originalBezierCurveTo(F, U, Z, G, Q, he);
            }, z.rect = function(F, U, Z, G) {
              A.rect(F, U, Z, G), this.__originalRect(F, U, Z, G);
            }, z.closePath = function() {
              A.closePath(), this.__originalClosePath();
            }, z.beginPath = function() {
              A.beginPath(), this.__originalBeginPath();
            };
          }
          class H {
            constructor(A) {
              this.canvasFactory = A, this.cache = /* @__PURE__ */ Object.create(null);
            }
            getCanvas(A, F, U) {
              let Z;
              return this.cache[A] !== void 0 ? (Z = this.cache[A], this.canvasFactory.reset(Z, F, U)) : (Z = this.canvasFactory.create(F, U), this.cache[A] = Z), Z;
            }
            delete(A) {
              delete this.cache[A];
            }
            clear() {
              for (const A in this.cache) {
                const F = this.cache[A];
                this.canvasFactory.destroy(F), delete this.cache[A];
              }
            }
          }
          function T(z, A, F, U, Z, G, Q, he, me, Te) {
            const [Pe, Re, Me, Fe, ve, be] = (0, u.getCurrentTransform)(z);
            if (Re === 0 && Me === 0) {
              const te = Q * Pe + ve, ye = Math.round(te), xe = he * Fe + be, Le = Math.round(xe), Ie = (Q + me) * Pe + ve, fe = Math.abs(Math.round(Ie) - ye) || 1, He = (he + Te) * Fe + be, Be = Math.abs(Math.round(He) - Le) || 1;
              return z.setTransform(Math.sign(Pe), 0, 0, Math.sign(Fe), ye, Le), z.drawImage(A, F, U, Z, G, 0, 0, fe, Be), z.setTransform(Pe, Re, Me, Fe, ve, be), [fe, Be];
            }
            if (Pe === 0 && Fe === 0) {
              const te = he * Me + ve, ye = Math.round(te), xe = Q * Re + be, Le = Math.round(xe), Ie = (he + Te) * Me + ve, fe = Math.abs(Math.round(Ie) - ye) || 1, He = (Q + me) * Re + be, Be = Math.abs(Math.round(He) - Le) || 1;
              return z.setTransform(0, Math.sign(Re), Math.sign(Me), 0, ye, Le), z.drawImage(A, F, U, Z, G, 0, 0, Be, fe), z.setTransform(Pe, Re, Me, Fe, ve, be), [Be, fe];
            }
            z.drawImage(A, F, U, Z, G, Q, he, me, Te);
            const X = Math.hypot(Pe, Re), ne = Math.hypot(Me, Fe);
            return [X * me, ne * Te];
          }
          function C(z) {
            const {
              width: A,
              height: F
            } = z;
            if (A > S || F > S)
              return null;
            const U = 1e3, Z = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), G = A + 1;
            let Q = new Uint8Array(G * (F + 1)), he, me, Te;
            const Pe = A + 7 & -8;
            let Re = new Uint8Array(Pe * F), Me = 0;
            for (const ne of z.data) {
              let te = 128;
              for (; te > 0; )
                Re[Me++] = ne & te ? 0 : 255, te >>= 1;
            }
            let Fe = 0;
            for (Me = 0, Re[Me] !== 0 && (Q[0] = 1, ++Fe), me = 1; me < A; me++)
              Re[Me] !== Re[Me + 1] && (Q[me] = Re[Me] ? 2 : 1, ++Fe), Me++;
            for (Re[Me] !== 0 && (Q[me] = 2, ++Fe), he = 1; he < F; he++) {
              Me = he * Pe, Te = he * G, Re[Me - Pe] !== Re[Me] && (Q[Te] = Re[Me] ? 1 : 8, ++Fe);
              let ne = (Re[Me] ? 4 : 0) + (Re[Me - Pe] ? 8 : 0);
              for (me = 1; me < A; me++)
                ne = (ne >> 2) + (Re[Me + 1] ? 4 : 0) + (Re[Me - Pe + 1] ? 8 : 0), Z[ne] && (Q[Te + me] = Z[ne], ++Fe), Me++;
              if (Re[Me - Pe] !== Re[Me] && (Q[Te + me] = Re[Me] ? 2 : 4, ++Fe), Fe > U)
                return null;
            }
            for (Me = Pe * (F - 1), Te = he * G, Re[Me] !== 0 && (Q[Te] = 8, ++Fe), me = 1; me < A; me++)
              Re[Me] !== Re[Me + 1] && (Q[Te + me] = Re[Me] ? 4 : 8, ++Fe), Me++;
            if (Re[Me] !== 0 && (Q[Te + me] = 4, ++Fe), Fe > U)
              return null;
            const ve = new Int32Array([0, G, -1, 0, -G, 0, 0, 0, 1]), be = new Path2D();
            for (he = 0; Fe && he <= F; he++) {
              let ne = he * G;
              const te = ne + A;
              for (; ne < te && !Q[ne]; )
                ne++;
              if (ne === te)
                continue;
              be.moveTo(ne % G, he);
              const ye = ne;
              let xe = Q[ne];
              do {
                const Le = ve[xe];
                do
                  ne += Le;
                while (!Q[ne]);
                const Ie = Q[ne];
                Ie !== 5 && Ie !== 10 ? (xe = Ie, Q[ne] = 0) : (xe = Ie & 51 * xe >> 4, Q[ne] &= xe >> 2 | xe << 2), be.lineTo(ne % G, ne / G | 0), Q[ne] || --Fe;
              } while (ye !== ne);
              --he;
            }
            return Re = null, Q = null, function(ne) {
              ne.save(), ne.scale(1 / A, -1 / F), ne.translate(0, -F), ne.fill(be), ne.beginPath(), ne.restore();
            };
          }
          class O {
            constructor(A, F) {
              this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = d.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = d.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = d.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, A, F]);
            }
            clone() {
              const A = Object.create(this);
              return A.clipBox = this.clipBox.slice(), A;
            }
            setCurrentPoint(A, F) {
              this.x = A, this.y = F;
            }
            updatePathMinMax(A, F, U) {
              [F, U] = d.Util.applyTransform([F, U], A), this.minX = Math.min(this.minX, F), this.minY = Math.min(this.minY, U), this.maxX = Math.max(this.maxX, F), this.maxY = Math.max(this.maxY, U);
            }
            updateRectMinMax(A, F) {
              const U = d.Util.applyTransform(F, A), Z = d.Util.applyTransform(F.slice(2), A);
              this.minX = Math.min(this.minX, U[0], Z[0]), this.minY = Math.min(this.minY, U[1], Z[1]), this.maxX = Math.max(this.maxX, U[0], Z[0]), this.maxY = Math.max(this.maxY, U[1], Z[1]);
            }
            updateScalingPathMinMax(A, F) {
              d.Util.scaleMinMax(A, F), this.minX = Math.min(this.minX, F[0]), this.maxX = Math.max(this.maxX, F[1]), this.minY = Math.min(this.minY, F[2]), this.maxY = Math.max(this.maxY, F[3]);
            }
            updateCurvePathMinMax(A, F, U, Z, G, Q, he, me, Te, Pe) {
              const Re = d.Util.bezierBoundingBox(F, U, Z, G, Q, he, me, Te);
              if (Pe) {
                Pe[0] = Math.min(Pe[0], Re[0], Re[2]), Pe[1] = Math.max(Pe[1], Re[0], Re[2]), Pe[2] = Math.min(Pe[2], Re[1], Re[3]), Pe[3] = Math.max(Pe[3], Re[1], Re[3]);
                return;
              }
              this.updateRectMinMax(A, Re);
            }
            getPathBoundingBox(A = _.PathType.FILL, F = null) {
              const U = [this.minX, this.minY, this.maxX, this.maxY];
              if (A === _.PathType.STROKE) {
                F || (0, d.unreachable)("Stroke bounding box must include transform.");
                const Z = d.Util.singularValueDecompose2dScale(F), G = Z[0] * this.lineWidth / 2, Q = Z[1] * this.lineWidth / 2;
                U[0] -= G, U[1] -= Q, U[2] += G, U[3] += Q;
              }
              return U;
            }
            updateClipFromPath() {
              const A = d.Util.intersect(this.clipBox, this.getPathBoundingBox());
              this.startNewPathAndClipBox(A || [0, 0, 0, 0]);
            }
            isEmptyClip() {
              return this.minX === 1 / 0;
            }
            startNewPathAndClipBox(A) {
              this.clipBox = A, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0;
            }
            getClippedPathBoundingBox(A = _.PathType.FILL, F = null) {
              return d.Util.intersect(this.clipBox, this.getPathBoundingBox(A, F));
            }
          }
          function j(z, A) {
            if (typeof ImageData < "u" && A instanceof ImageData) {
              z.putImageData(A, 0, 0);
              return;
            }
            const F = A.height, U = A.width, Z = F % R, G = (F - Z) / R, Q = Z === 0 ? G : G + 1, he = z.createImageData(U, R);
            let me = 0, Te;
            const Pe = A.data, Re = he.data;
            let Me, Fe, ve, be;
            if (A.kind === d.ImageKind.GRAYSCALE_1BPP) {
              const X = Pe.byteLength, ne = new Uint32Array(Re.buffer, 0, Re.byteLength >> 2), te = ne.length, ye = U + 7 >> 3, xe = 4294967295, Le = d.FeatureTest.isLittleEndian ? 4278190080 : 255;
              for (Me = 0; Me < Q; Me++) {
                for (ve = Me < G ? R : Z, Te = 0, Fe = 0; Fe < ve; Fe++) {
                  const Ie = X - me;
                  let fe = 0;
                  const He = Ie > ye ? U : Ie * 8 - 7, Be = He & -8;
                  let st = 0, nt = 0;
                  for (; fe < Be; fe += 8)
                    nt = Pe[me++], ne[Te++] = nt & 128 ? xe : Le, ne[Te++] = nt & 64 ? xe : Le, ne[Te++] = nt & 32 ? xe : Le, ne[Te++] = nt & 16 ? xe : Le, ne[Te++] = nt & 8 ? xe : Le, ne[Te++] = nt & 4 ? xe : Le, ne[Te++] = nt & 2 ? xe : Le, ne[Te++] = nt & 1 ? xe : Le;
                  for (; fe < He; fe++)
                    st === 0 && (nt = Pe[me++], st = 128), ne[Te++] = nt & st ? xe : Le, st >>= 1;
                }
                for (; Te < te; )
                  ne[Te++] = 0;
                z.putImageData(he, 0, Me * R);
              }
            } else if (A.kind === d.ImageKind.RGBA_32BPP) {
              for (Fe = 0, be = U * R * 4, Me = 0; Me < G; Me++)
                Re.set(Pe.subarray(me, me + be)), me += be, z.putImageData(he, 0, Fe), Fe += R;
              Me < Q && (be = U * Z * 4, Re.set(Pe.subarray(me, me + be)), z.putImageData(he, 0, Fe));
            } else if (A.kind === d.ImageKind.RGB_24BPP)
              for (ve = R, be = U * ve, Me = 0; Me < Q; Me++) {
                for (Me >= G && (ve = Z, be = U * ve), Te = 0, Fe = be; Fe--; )
                  Re[Te++] = Pe[me++], Re[Te++] = Pe[me++], Re[Te++] = Pe[me++], Re[Te++] = 255;
                z.putImageData(he, 0, Me * R);
              }
            else
              throw new Error(`bad image kind: ${A.kind}`);
          }
          function B(z, A) {
            if (A.bitmap) {
              z.drawImage(A.bitmap, 0, 0);
              return;
            }
            const F = A.height, U = A.width, Z = F % R, G = (F - Z) / R, Q = Z === 0 ? G : G + 1, he = z.createImageData(U, R);
            let me = 0;
            const Te = A.data, Pe = he.data;
            for (let Re = 0; Re < Q; Re++) {
              const Me = Re < G ? R : Z;
              ({
                srcPos: me
              } = (0, g.convertBlackAndWhiteToRGBA)({
                src: Te,
                srcPos: me,
                dest: Pe,
                width: U,
                height: Me,
                nonBlackColor: 0
              })), z.putImageData(he, 0, Re * R);
            }
          }
          function D(z, A) {
            const F = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
            for (const U of F)
              z[U] !== void 0 && (A[U] = z[U]);
            z.setLineDash !== void 0 && (A.setLineDash(z.getLineDash()), A.lineDashOffset = z.lineDashOffset);
          }
          function M(z) {
            if (z.strokeStyle = z.fillStyle = "#000000", z.fillRule = "nonzero", z.globalAlpha = 1, z.lineWidth = 1, z.lineCap = "butt", z.lineJoin = "miter", z.miterLimit = 10, z.globalCompositeOperation = "source-over", z.font = "10px sans-serif", z.setLineDash !== void 0 && (z.setLineDash([]), z.lineDashOffset = 0), !d.isNodeJS) {
              const {
                filter: A
              } = z;
              A !== "none" && A !== "" && (z.filter = "none");
            }
          }
          function I(z, A, F, U) {
            const Z = z.length;
            for (let G = 3; G < Z; G += 4) {
              const Q = z[G];
              if (Q === 0)
                z[G - 3] = A, z[G - 2] = F, z[G - 1] = U;
              else if (Q < 255) {
                const he = 255 - Q;
                z[G - 3] = z[G - 3] * Q + A * he >> 8, z[G - 2] = z[G - 2] * Q + F * he >> 8, z[G - 1] = z[G - 1] * Q + U * he >> 8;
              }
            }
          }
          function P(z, A, F) {
            const U = z.length, Z = 1 / 255;
            for (let G = 3; G < U; G += 4) {
              const Q = F ? F[z[G]] : z[G];
              A[G] = A[G] * Q * Z | 0;
            }
          }
          function L(z, A, F) {
            const U = z.length;
            for (let Z = 3; Z < U; Z += 4) {
              const G = z[Z - 3] * 77 + z[Z - 2] * 152 + z[Z - 1] * 28;
              A[Z] = F ? A[Z] * F[G >> 8] >> 8 : A[Z] * G >> 16;
            }
          }
          function Y(z, A, F, U, Z, G, Q, he, me, Te, Pe) {
            const Re = !!G, Me = Re ? G[0] : 0, Fe = Re ? G[1] : 0, ve = Re ? G[2] : 0, be = Z === "Luminosity" ? L : P, ne = Math.min(U, Math.ceil(1048576 / F));
            for (let te = 0; te < U; te += ne) {
              const ye = Math.min(ne, U - te), xe = z.getImageData(he - Te, te + (me - Pe), F, ye), Le = A.getImageData(he, te + me, F, ye);
              Re && I(xe.data, Me, Fe, ve), be(xe.data, Le.data, Q), A.putImageData(Le, he, te + me);
            }
          }
          function N(z, A, F, U) {
            const Z = U[0], G = U[1], Q = U[2] - Z, he = U[3] - G;
            Q === 0 || he === 0 || (Y(A.context, F, Q, he, A.subtype, A.backdrop, A.transferMap, Z, G, A.offsetX, A.offsetY), z.save(), z.globalAlpha = 1, z.globalCompositeOperation = "source-over", z.setTransform(1, 0, 0, 1, 0, 0), z.drawImage(F.canvas, 0, 0), z.restore());
          }
          function W(z, A) {
            const F = d.Util.singularValueDecompose2dScale(z);
            F[0] = Math.fround(F[0]), F[1] = Math.fround(F[1]);
            const U = Math.fround((globalThis.devicePixelRatio || 1) * u.PixelsPerInch.PDF_TO_CSS_UNITS);
            return A !== void 0 ? A : F[0] <= U || F[1] <= U;
          }
          const V = ["butt", "round", "square"], ue = ["miter", "round", "bevel"], se = {}, ce = {}, le = class le {
            constructor(A, F, U, Z, G, {
              optionalContentConfig: Q,
              markedContentStack: he = null
            }, me, Te) {
              Ee(this, ge);
              this.ctx = A, this.current = new O(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = F, this.objs = U, this.canvasFactory = Z, this.filterFactory = G, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = he || [], this.optionalContentConfig = Q, this.cachedCanvases = new H(this.canvasFactory), this.cachedPatterns = /* @__PURE__ */ new Map(), this.annotationCanvasMap = me, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = Te, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = /* @__PURE__ */ new Map();
            }
            getObject(A, F = null) {
              return typeof A == "string" ? A.startsWith("g_") ? this.commonObjs.get(A) : this.objs.get(A) : F;
            }
            beginDrawing({
              transform: A,
              viewport: F,
              transparency: U = !1,
              background: Z = null
            }) {
              const G = this.ctx.canvas.width, Q = this.ctx.canvas.height, he = this.ctx.fillStyle;
              if (this.ctx.fillStyle = Z || "#ffffff", this.ctx.fillRect(0, 0, G, Q), this.ctx.fillStyle = he, U) {
                const me = this.cachedCanvases.getCanvas("transparent", G, Q);
                this.compositeCtx = this.ctx, this.transparentCanvas = me.canvas, this.ctx = me.context, this.ctx.save(), this.ctx.transform(...(0, u.getCurrentTransform)(this.compositeCtx));
              }
              this.ctx.save(), M(this.ctx), A && (this.ctx.transform(...A), this.outputScaleX = A[0], this.outputScaleY = A[0]), this.ctx.transform(...F.transform), this.viewportScale = F.scale, this.baseTransform = (0, u.getCurrentTransform)(this.ctx);
            }
            executeOperatorList(A, F, U, Z) {
              const G = A.argsArray, Q = A.fnArray;
              let he = F || 0;
              const me = G.length;
              if (me === he)
                return he;
              const Te = me - he > E && typeof U == "function", Pe = Te ? Date.now() + v : 0;
              let Re = 0;
              const Me = this.commonObjs, Fe = this.objs;
              let ve;
              for (; ; ) {
                if (Z !== void 0 && he === Z.nextBreakPoint)
                  return Z.breakIt(he, U), he;
                if (ve = Q[he], ve !== d.OPS.dependency)
                  this[ve].apply(this, G[he]);
                else
                  for (const be of G[he]) {
                    const X = be.startsWith("g_") ? Me : Fe;
                    if (!X.has(be))
                      return X.get(be, U), he;
                  }
                if (he++, he === me)
                  return he;
                if (Te && ++Re > E) {
                  if (Date.now() > Pe)
                    return U(), he;
                  Re = 0;
                }
              }
            }
            endDrawing() {
              _e(this, ge, mn).call(this), this.cachedCanvases.clear(), this.cachedPatterns.clear();
              for (const A of this._cachedBitmapsMap.values()) {
                for (const F of A.values())
                  typeof HTMLCanvasElement < "u" && F instanceof HTMLCanvasElement && (F.width = F.height = 0);
                A.clear();
              }
              this._cachedBitmapsMap.clear(), _e(this, ge, gn).call(this);
            }
            _scaleImage(A, F) {
              const U = A.width, Z = A.height;
              let G = Math.max(Math.hypot(F[0], F[1]), 1), Q = Math.max(Math.hypot(F[2], F[3]), 1), he = U, me = Z, Te = "prescale1", Pe, Re;
              for (; G > 2 && he > 1 || Q > 2 && me > 1; ) {
                let Me = he, Fe = me;
                G > 2 && he > 1 && (Me = he >= 16384 ? Math.floor(he / 2) - 1 || 1 : Math.ceil(he / 2), G /= he / Me), Q > 2 && me > 1 && (Fe = me >= 16384 ? Math.floor(me / 2) - 1 || 1 : Math.ceil(me) / 2, Q /= me / Fe), Pe = this.cachedCanvases.getCanvas(Te, Me, Fe), Re = Pe.context, Re.clearRect(0, 0, Me, Fe), Re.drawImage(A, 0, 0, he, me, 0, 0, Me, Fe), A = Pe.canvas, he = Me, me = Fe, Te = Te === "prescale1" ? "prescale2" : "prescale1";
              }
              return {
                img: A,
                paintWidth: he,
                paintHeight: me
              };
            }
            _createMaskCanvas(A) {
              const F = this.ctx, {
                width: U,
                height: Z
              } = A, G = this.current.fillColor, Q = this.current.patternFill, he = (0, u.getCurrentTransform)(F);
              let me, Te, Pe, Re;
              if ((A.bitmap || A.data) && A.count > 1) {
                const fe = A.bitmap || A.data.buffer;
                Te = JSON.stringify(Q ? he : [he.slice(0, 4), G]), me = this._cachedBitmapsMap.get(fe), me || (me = /* @__PURE__ */ new Map(), this._cachedBitmapsMap.set(fe, me));
                const He = me.get(Te);
                if (He && !Q) {
                  const Be = Math.round(Math.min(he[0], he[2]) + he[4]), st = Math.round(Math.min(he[1], he[3]) + he[5]);
                  return {
                    canvas: He,
                    offsetX: Be,
                    offsetY: st
                  };
                }
                Pe = He;
              }
              Pe || (Re = this.cachedCanvases.getCanvas("maskCanvas", U, Z), B(Re.context, A));
              let Me = d.Util.transform(he, [1 / U, 0, 0, -1 / Z, 0, 0]);
              Me = d.Util.transform(Me, [1, 0, 0, 1, 0, -Z]);
              const Fe = d.Util.applyTransform([0, 0], Me), ve = d.Util.applyTransform([U, Z], Me), be = d.Util.normalizeRect([Fe[0], Fe[1], ve[0], ve[1]]), X = Math.round(be[2] - be[0]) || 1, ne = Math.round(be[3] - be[1]) || 1, te = this.cachedCanvases.getCanvas("fillCanvas", X, ne), ye = te.context, xe = Math.min(Fe[0], ve[0]), Le = Math.min(Fe[1], ve[1]);
              ye.translate(-xe, -Le), ye.transform(...Me), Pe || (Pe = this._scaleImage(Re.canvas, (0, u.getCurrentTransformInverse)(ye)), Pe = Pe.img, me && Q && me.set(Te, Pe)), ye.imageSmoothingEnabled = W((0, u.getCurrentTransform)(ye), A.interpolate), T(ye, Pe, 0, 0, Pe.width, Pe.height, 0, 0, U, Z), ye.globalCompositeOperation = "source-in";
              const Ie = d.Util.transform((0, u.getCurrentTransformInverse)(ye), [1, 0, 0, 1, -xe, -Le]);
              return ye.fillStyle = Q ? G.getPattern(F, this, Ie, _.PathType.FILL) : G, ye.fillRect(0, 0, U, Z), me && !Q && (this.cachedCanvases.delete("fillCanvas"), me.set(Te, te.canvas)), {
                canvas: te.canvas,
                offsetX: Math.round(xe),
                offsetY: Math.round(Le)
              };
            }
            setLineWidth(A) {
              A !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = A, this.ctx.lineWidth = A;
            }
            setLineCap(A) {
              this.ctx.lineCap = V[A];
            }
            setLineJoin(A) {
              this.ctx.lineJoin = ue[A];
            }
            setMiterLimit(A) {
              this.ctx.miterLimit = A;
            }
            setDash(A, F) {
              const U = this.ctx;
              U.setLineDash !== void 0 && (U.setLineDash(A), U.lineDashOffset = F);
            }
            setRenderingIntent(A) {
            }
            setFlatness(A) {
            }
            setGState(A) {
              for (const [F, U] of A)
                switch (F) {
                  case "LW":
                    this.setLineWidth(U);
                    break;
                  case "LC":
                    this.setLineCap(U);
                    break;
                  case "LJ":
                    this.setLineJoin(U);
                    break;
                  case "ML":
                    this.setMiterLimit(U);
                    break;
                  case "D":
                    this.setDash(U[0], U[1]);
                    break;
                  case "RI":
                    this.setRenderingIntent(U);
                    break;
                  case "FL":
                    this.setFlatness(U);
                    break;
                  case "Font":
                    this.setFont(U[0], U[1]);
                    break;
                  case "CA":
                    this.current.strokeAlpha = U;
                    break;
                  case "ca":
                    this.current.fillAlpha = U, this.ctx.globalAlpha = U;
                    break;
                  case "BM":
                    this.ctx.globalCompositeOperation = U;
                    break;
                  case "SMask":
                    this.current.activeSMask = U ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState();
                    break;
                  case "TR":
                    this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(U);
                    break;
                }
            }
            get inSMaskMode() {
              return !!this.suspendedCtx;
            }
            checkSMaskState() {
              const A = this.inSMaskMode;
              this.current.activeSMask && !A ? this.beginSMaskMode() : !this.current.activeSMask && A && this.endSMaskMode();
            }
            beginSMaskMode() {
              if (this.inSMaskMode)
                throw new Error("beginSMaskMode called while already in smask mode");
              const A = this.ctx.canvas.width, F = this.ctx.canvas.height, U = "smaskGroupAt" + this.groupLevel, Z = this.cachedCanvases.getCanvas(U, A, F);
              this.suspendedCtx = this.ctx, this.ctx = Z.context;
              const G = this.ctx;
              G.setTransform(...(0, u.getCurrentTransform)(this.suspendedCtx)), D(this.suspendedCtx, G), x(G, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]);
            }
            endSMaskMode() {
              if (!this.inSMaskMode)
                throw new Error("endSMaskMode called while not in smask mode");
              this.ctx._removeMirroring(), D(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null;
            }
            compose(A) {
              if (!this.current.activeSMask)
                return;
              A ? (A[0] = Math.floor(A[0]), A[1] = Math.floor(A[1]), A[2] = Math.ceil(A[2]), A[3] = Math.ceil(A[3])) : A = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
              const F = this.current.activeSMask, U = this.suspendedCtx;
              N(U, F, this.ctx, A), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore();
            }
            save() {
              this.inSMaskMode ? (D(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save();
              const A = this.current;
              this.stateStack.push(A), this.current = A.clone();
            }
            restore() {
              this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), D(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null);
            }
            transform(A, F, U, Z, G, Q) {
              this.ctx.transform(A, F, U, Z, G, Q), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null;
            }
            constructPath(A, F, U) {
              const Z = this.ctx, G = this.current;
              let Q = G.x, he = G.y, me, Te;
              const Pe = (0, u.getCurrentTransform)(Z), Re = Pe[0] === 0 && Pe[3] === 0 || Pe[1] === 0 && Pe[2] === 0, Me = Re ? U.slice(0) : null;
              for (let Fe = 0, ve = 0, be = A.length; Fe < be; Fe++)
                switch (A[Fe] | 0) {
                  case d.OPS.rectangle:
                    Q = F[ve++], he = F[ve++];
                    const X = F[ve++], ne = F[ve++], te = Q + X, ye = he + ne;
                    Z.moveTo(Q, he), X === 0 || ne === 0 ? Z.lineTo(te, ye) : (Z.lineTo(te, he), Z.lineTo(te, ye), Z.lineTo(Q, ye)), Re || G.updateRectMinMax(Pe, [Q, he, te, ye]), Z.closePath();
                    break;
                  case d.OPS.moveTo:
                    Q = F[ve++], he = F[ve++], Z.moveTo(Q, he), Re || G.updatePathMinMax(Pe, Q, he);
                    break;
                  case d.OPS.lineTo:
                    Q = F[ve++], he = F[ve++], Z.lineTo(Q, he), Re || G.updatePathMinMax(Pe, Q, he);
                    break;
                  case d.OPS.curveTo:
                    me = Q, Te = he, Q = F[ve + 4], he = F[ve + 5], Z.bezierCurveTo(F[ve], F[ve + 1], F[ve + 2], F[ve + 3], Q, he), G.updateCurvePathMinMax(Pe, me, Te, F[ve], F[ve + 1], F[ve + 2], F[ve + 3], Q, he, Me), ve += 6;
                    break;
                  case d.OPS.curveTo2:
                    me = Q, Te = he, Z.bezierCurveTo(Q, he, F[ve], F[ve + 1], F[ve + 2], F[ve + 3]), G.updateCurvePathMinMax(Pe, me, Te, Q, he, F[ve], F[ve + 1], F[ve + 2], F[ve + 3], Me), Q = F[ve + 2], he = F[ve + 3], ve += 4;
                    break;
                  case d.OPS.curveTo3:
                    me = Q, Te = he, Q = F[ve + 2], he = F[ve + 3], Z.bezierCurveTo(F[ve], F[ve + 1], Q, he, Q, he), G.updateCurvePathMinMax(Pe, me, Te, F[ve], F[ve + 1], Q, he, Q, he, Me), ve += 4;
                    break;
                  case d.OPS.closePath:
                    Z.closePath();
                    break;
                }
              Re && G.updateScalingPathMinMax(Pe, Me), G.setCurrentPoint(Q, he);
            }
            closePath() {
              this.ctx.closePath();
            }
            stroke(A = !0) {
              const F = this.ctx, U = this.current.strokeColor;
              F.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof U == "object" && (U != null && U.getPattern) ? (F.save(), F.strokeStyle = U.getPattern(F, this, (0, u.getCurrentTransformInverse)(F), _.PathType.STROKE), this.rescaleAndStroke(!1), F.restore()) : this.rescaleAndStroke(!0)), A && this.consumePath(this.current.getClippedPathBoundingBox()), F.globalAlpha = this.current.fillAlpha;
            }
            closeStroke() {
              this.closePath(), this.stroke();
            }
            fill(A = !0) {
              const F = this.ctx, U = this.current.fillColor, Z = this.current.patternFill;
              let G = !1;
              Z && (F.save(), F.fillStyle = U.getPattern(F, this, (0, u.getCurrentTransformInverse)(F), _.PathType.FILL), G = !0);
              const Q = this.current.getClippedPathBoundingBox();
              this.contentVisible && Q !== null && (this.pendingEOFill ? (F.fill("evenodd"), this.pendingEOFill = !1) : F.fill()), G && F.restore(), A && this.consumePath(Q);
            }
            eoFill() {
              this.pendingEOFill = !0, this.fill();
            }
            fillStroke() {
              this.fill(!1), this.stroke(!1), this.consumePath();
            }
            eoFillStroke() {
              this.pendingEOFill = !0, this.fillStroke();
            }
            closeFillStroke() {
              this.closePath(), this.fillStroke();
            }
            closeEOFillStroke() {
              this.pendingEOFill = !0, this.closePath(), this.fillStroke();
            }
            endPath() {
              this.consumePath();
            }
            clip() {
              this.pendingClip = se;
            }
            eoClip() {
              this.pendingClip = ce;
            }
            beginText() {
              this.current.textMatrix = d.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
            }
            endText() {
              const A = this.pendingTextPaths, F = this.ctx;
              if (A === void 0) {
                F.beginPath();
                return;
              }
              F.save(), F.beginPath();
              for (const U of A)
                F.setTransform(...U.transform), F.translate(U.x, U.y), U.addToPath(F, U.fontSize);
              F.restore(), F.clip(), F.beginPath(), delete this.pendingTextPaths;
            }
            setCharSpacing(A) {
              this.current.charSpacing = A;
            }
            setWordSpacing(A) {
              this.current.wordSpacing = A;
            }
            setHScale(A) {
              this.current.textHScale = A / 100;
            }
            setLeading(A) {
              this.current.leading = -A;
            }
            setFont(A, F) {
              var Pe;
              const U = this.commonObjs.get(A), Z = this.current;
              if (!U)
                throw new Error(`Can't find font for ${A}`);
              if (Z.fontMatrix = U.fontMatrix || d.FONT_IDENTITY_MATRIX, (Z.fontMatrix[0] === 0 || Z.fontMatrix[3] === 0) && (0, d.warn)("Invalid font matrix for font " + A), F < 0 ? (F = -F, Z.fontDirection = -1) : Z.fontDirection = 1, this.current.font = U, this.current.fontSize = F, U.isType3Font)
                return;
              const G = U.loadedName || "sans-serif", Q = ((Pe = U.systemFontInfo) == null ? void 0 : Pe.css) || `"${G}", ${U.fallbackName}`;
              let he = "normal";
              U.black ? he = "900" : U.bold && (he = "bold");
              const me = U.italic ? "italic" : "normal";
              let Te = F;
              F < $ ? Te = $ : F > b && (Te = b), this.current.fontSizeScale = F / Te, this.ctx.font = `${me} ${he} ${Te}px ${Q}`;
            }
            setTextRenderingMode(A) {
              this.current.textRenderingMode = A;
            }
            setTextRise(A) {
              this.current.textRise = A;
            }
            moveText(A, F) {
              this.current.x = this.current.lineX += A, this.current.y = this.current.lineY += F;
            }
            setLeadingMoveText(A, F) {
              this.setLeading(-F), this.moveText(A, F);
            }
            setTextMatrix(A, F, U, Z, G, Q) {
              this.current.textMatrix = [A, F, U, Z, G, Q], this.current.textMatrixScale = Math.hypot(A, F), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0;
            }
            nextLine() {
              this.moveText(0, this.current.leading);
            }
            paintChar(A, F, U, Z) {
              const G = this.ctx, Q = this.current, he = Q.font, me = Q.textRenderingMode, Te = Q.fontSize / Q.fontSizeScale, Pe = me & d.TextRenderingMode.FILL_STROKE_MASK, Re = !!(me & d.TextRenderingMode.ADD_TO_PATH_FLAG), Me = Q.patternFill && !he.missingFile;
              let Fe;
              (he.disableFontFace || Re || Me) && (Fe = he.getPathGenerator(this.commonObjs, A)), he.disableFontFace || Me ? (G.save(), G.translate(F, U), G.beginPath(), Fe(G, Te), Z && G.setTransform(...Z), (Pe === d.TextRenderingMode.FILL || Pe === d.TextRenderingMode.FILL_STROKE) && G.fill(), (Pe === d.TextRenderingMode.STROKE || Pe === d.TextRenderingMode.FILL_STROKE) && G.stroke(), G.restore()) : ((Pe === d.TextRenderingMode.FILL || Pe === d.TextRenderingMode.FILL_STROKE) && G.fillText(A, F, U), (Pe === d.TextRenderingMode.STROKE || Pe === d.TextRenderingMode.FILL_STROKE) && G.strokeText(A, F, U)), Re && (this.pendingTextPaths || (this.pendingTextPaths = [])).push({
                transform: (0, u.getCurrentTransform)(G),
                x: F,
                y: U,
                fontSize: Te,
                addToPath: Fe
              });
            }
            get isFontSubpixelAAEnabled() {
              const {
                context: A
              } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
              A.scale(1.5, 1), A.fillText("I", 0, 10);
              const F = A.getImageData(0, 0, 10, 10).data;
              let U = !1;
              for (let Z = 3; Z < F.length; Z += 4)
                if (F[Z] > 0 && F[Z] < 255) {
                  U = !0;
                  break;
                }
              return (0, d.shadow)(this, "isFontSubpixelAAEnabled", U);
            }
            showText(A) {
              const F = this.current, U = F.font;
              if (U.isType3Font)
                return this.showType3Text(A);
              const Z = F.fontSize;
              if (Z === 0)
                return;
              const G = this.ctx, Q = F.fontSizeScale, he = F.charSpacing, me = F.wordSpacing, Te = F.fontDirection, Pe = F.textHScale * Te, Re = A.length, Me = U.vertical, Fe = Me ? 1 : -1, ve = U.defaultVMetrics, be = Z * F.fontMatrix[0], X = F.textRenderingMode === d.TextRenderingMode.FILL && !U.disableFontFace && !F.patternFill;
              G.save(), G.transform(...F.textMatrix), G.translate(F.x, F.y + F.textRise), Te > 0 ? G.scale(Pe, -1) : G.scale(Pe, 1);
              let ne;
              if (F.patternFill) {
                G.save();
                const Ie = F.fillColor.getPattern(G, this, (0, u.getCurrentTransformInverse)(G), _.PathType.FILL);
                ne = (0, u.getCurrentTransform)(G), G.restore(), G.fillStyle = Ie;
              }
              let te = F.lineWidth;
              const ye = F.textMatrixScale;
              if (ye === 0 || te === 0) {
                const Ie = F.textRenderingMode & d.TextRenderingMode.FILL_STROKE_MASK;
                (Ie === d.TextRenderingMode.STROKE || Ie === d.TextRenderingMode.FILL_STROKE) && (te = this.getSinglePixelWidth());
              } else
                te /= ye;
              if (Q !== 1 && (G.scale(Q, Q), te /= Q), G.lineWidth = te, U.isInvalidPDFjsFont) {
                const Ie = [];
                let fe = 0;
                for (const He of A)
                  Ie.push(He.unicode), fe += He.width;
                G.fillText(Ie.join(""), 0, 0), F.x += fe * be * Pe, G.restore(), this.compose();
                return;
              }
              let xe = 0, Le;
              for (Le = 0; Le < Re; ++Le) {
                const Ie = A[Le];
                if (typeof Ie == "number") {
                  xe += Fe * Ie * Z / 1e3;
                  continue;
                }
                let fe = !1;
                const He = (Ie.isSpace ? me : 0) + he, Be = Ie.fontChar, st = Ie.accent;
                let nt, ht, Ve = Ie.width;
                if (Me) {
                  const lt = Ie.vmetric || ve, dt = -(Ie.vmetric ? lt[1] : Ve * 0.5) * be, De = lt[2] * be;
                  Ve = lt ? -lt[0] : Ve, nt = dt / Q, ht = (xe + De) / Q;
                } else
                  nt = xe / Q, ht = 0;
                if (U.remeasure && Ve > 0) {
                  const lt = G.measureText(Be).width * 1e3 / Z * Q;
                  if (Ve < lt && this.isFontSubpixelAAEnabled) {
                    const dt = Ve / lt;
                    fe = !0, G.save(), G.scale(dt, 1), nt /= dt;
                  } else Ve !== lt && (nt += (Ve - lt) / 2e3 * Z / Q);
                }
                if (this.contentVisible && (Ie.isInFont || U.missingFile)) {
                  if (X && !st)
                    G.fillText(Be, nt, ht);
                  else if (this.paintChar(Be, nt, ht, ne), st) {
                    const lt = nt + Z * st.offset.x / Q, dt = ht - Z * st.offset.y / Q;
                    this.paintChar(st.fontChar, lt, dt, ne);
                  }
                }
                const et = Me ? Ve * be - He * Te : Ve * be + He * Te;
                xe += et, fe && G.restore();
              }
              Me ? F.y -= xe : F.x += xe * Pe, G.restore(), this.compose();
            }
            showType3Text(A) {
              const F = this.ctx, U = this.current, Z = U.font, G = U.fontSize, Q = U.fontDirection, he = Z.vertical ? 1 : -1, me = U.charSpacing, Te = U.wordSpacing, Pe = U.textHScale * Q, Re = U.fontMatrix || d.FONT_IDENTITY_MATRIX, Me = A.length, Fe = U.textRenderingMode === d.TextRenderingMode.INVISIBLE;
              let ve, be, X, ne;
              if (!(Fe || G === 0)) {
                for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, F.save(), F.transform(...U.textMatrix), F.translate(U.x, U.y), F.scale(Pe, Q), ve = 0; ve < Me; ++ve) {
                  if (be = A[ve], typeof be == "number") {
                    ne = he * be * G / 1e3, this.ctx.translate(ne, 0), U.x += ne * Pe;
                    continue;
                  }
                  const te = (be.isSpace ? Te : 0) + me, ye = Z.charProcOperatorList[be.operatorListId];
                  if (!ye) {
                    (0, d.warn)(`Type3 character "${be.operatorListId}" is not available.`);
                    continue;
                  }
                  this.contentVisible && (this.processingType3 = be, this.save(), F.scale(G, G), F.transform(...Re), this.executeOperatorList(ye), this.restore()), X = d.Util.applyTransform([be.width, 0], Re)[0] * G + te, F.translate(X, 0), U.x += X * Pe;
                }
                F.restore(), this.processingType3 = null;
              }
            }
            setCharWidth(A, F) {
            }
            setCharWidthAndBounds(A, F, U, Z, G, Q) {
              this.ctx.rect(U, Z, G - U, Q - Z), this.ctx.clip(), this.endPath();
            }
            getColorN_Pattern(A) {
              let F;
              if (A[0] === "TilingPattern") {
                const U = A[1], Z = this.baseTransform || (0, u.getCurrentTransform)(this.ctx), G = {
                  createCanvasGraphics: (Q) => new le(Q, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                    optionalContentConfig: this.optionalContentConfig,
                    markedContentStack: this.markedContentStack
                  })
                };
                F = new _.TilingPattern(A, U, this.ctx, G, Z);
              } else
                F = this._getPattern(A[1], A[2]);
              return F;
            }
            setStrokeColorN() {
              this.current.strokeColor = this.getColorN_Pattern(arguments);
            }
            setFillColorN() {
              this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0;
            }
            setStrokeRGBColor(A, F, U) {
              const Z = d.Util.makeHexColor(A, F, U);
              this.ctx.strokeStyle = Z, this.current.strokeColor = Z;
            }
            setFillRGBColor(A, F, U) {
              const Z = d.Util.makeHexColor(A, F, U);
              this.ctx.fillStyle = Z, this.current.fillColor = Z, this.current.patternFill = !1;
            }
            _getPattern(A, F = null) {
              let U;
              return this.cachedPatterns.has(A) ? U = this.cachedPatterns.get(A) : (U = (0, _.getShadingPattern)(this.getObject(A)), this.cachedPatterns.set(A, U)), F && (U.matrix = F), U;
            }
            shadingFill(A) {
              if (!this.contentVisible)
                return;
              const F = this.ctx;
              this.save();
              const U = this._getPattern(A);
              F.fillStyle = U.getPattern(F, this, (0, u.getCurrentTransformInverse)(F), _.PathType.SHADING);
              const Z = (0, u.getCurrentTransformInverse)(F);
              if (Z) {
                const {
                  width: G,
                  height: Q
                } = F.canvas, [he, me, Te, Pe] = d.Util.getAxialAlignedBoundingBox([0, 0, G, Q], Z);
                this.ctx.fillRect(he, me, Te - he, Pe - me);
              } else
                this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
              this.compose(this.current.getClippedPathBoundingBox()), this.restore();
            }
            beginInlineImage() {
              (0, d.unreachable)("Should not call beginInlineImage");
            }
            beginImageData() {
              (0, d.unreachable)("Should not call beginImageData");
            }
            paintFormXObjectBegin(A, F) {
              if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), Array.isArray(A) && A.length === 6 && this.transform(...A), this.baseTransform = (0, u.getCurrentTransform)(this.ctx), F)) {
                const U = F[2] - F[0], Z = F[3] - F[1];
                this.ctx.rect(F[0], F[1], U, Z), this.current.updateRectMinMax((0, u.getCurrentTransform)(this.ctx), F), this.clip(), this.endPath();
              }
            }
            paintFormXObjectEnd() {
              this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop());
            }
            beginGroup(A) {
              if (!this.contentVisible)
                return;
              this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null);
              const F = this.ctx;
              A.isolated || (0, d.info)("TODO: Support non-isolated groups."), A.knockout && (0, d.warn)("Knockout groups not supported.");
              const U = (0, u.getCurrentTransform)(F);
              if (A.matrix && F.transform(...A.matrix), !A.bbox)
                throw new Error("Bounding box is required.");
              let Z = d.Util.getAxialAlignedBoundingBox(A.bbox, (0, u.getCurrentTransform)(F));
              const G = [0, 0, F.canvas.width, F.canvas.height];
              Z = d.Util.intersect(Z, G) || [0, 0, 0, 0];
              const Q = Math.floor(Z[0]), he = Math.floor(Z[1]);
              let me = Math.max(Math.ceil(Z[2]) - Q, 1), Te = Math.max(Math.ceil(Z[3]) - he, 1), Pe = 1, Re = 1;
              me > y && (Pe = me / y, me = y), Te > y && (Re = Te / y, Te = y), this.current.startNewPathAndClipBox([0, 0, me, Te]);
              let Me = "groupAt" + this.groupLevel;
              A.smask && (Me += "_smask_" + this.smaskCounter++ % 2);
              const Fe = this.cachedCanvases.getCanvas(Me, me, Te), ve = Fe.context;
              ve.scale(1 / Pe, 1 / Re), ve.translate(-Q, -he), ve.transform(...U), A.smask ? this.smaskStack.push({
                canvas: Fe.canvas,
                context: ve,
                offsetX: Q,
                offsetY: he,
                scaleX: Pe,
                scaleY: Re,
                subtype: A.smask.subtype,
                backdrop: A.smask.backdrop,
                transferMap: A.smask.transferMap || null,
                startTransformInverse: null
              }) : (F.setTransform(1, 0, 0, 1, 0, 0), F.translate(Q, he), F.scale(Pe, Re), F.save()), D(F, ve), this.ctx = ve, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(F), this.groupLevel++;
            }
            endGroup(A) {
              if (!this.contentVisible)
                return;
              this.groupLevel--;
              const F = this.ctx, U = this.groupStack.pop();
              if (this.ctx = U, this.ctx.imageSmoothingEnabled = !1, A.smask)
                this.tempSMask = this.smaskStack.pop(), this.restore();
              else {
                this.ctx.restore();
                const Z = (0, u.getCurrentTransform)(this.ctx);
                this.restore(), this.ctx.save(), this.ctx.setTransform(...Z);
                const G = d.Util.getAxialAlignedBoundingBox([0, 0, F.canvas.width, F.canvas.height], Z);
                this.ctx.drawImage(F.canvas, 0, 0), this.ctx.restore(), this.compose(G);
              }
            }
            beginAnnotation(A, F, U, Z, G) {
              if (_e(this, ge, mn).call(this), M(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), Array.isArray(F) && F.length === 4) {
                const Q = F[2] - F[0], he = F[3] - F[1];
                if (G && this.annotationCanvasMap) {
                  U = U.slice(), U[4] -= F[0], U[5] -= F[1], F = F.slice(), F[0] = F[1] = 0, F[2] = Q, F[3] = he;
                  const [me, Te] = d.Util.singularValueDecompose2dScale((0, u.getCurrentTransform)(this.ctx)), {
                    viewportScale: Pe
                  } = this, Re = Math.ceil(Q * this.outputScaleX * Pe), Me = Math.ceil(he * this.outputScaleY * Pe);
                  this.annotationCanvas = this.canvasFactory.create(Re, Me);
                  const {
                    canvas: Fe,
                    context: ve
                  } = this.annotationCanvas;
                  this.annotationCanvasMap.set(A, Fe), this.annotationCanvas.savedCtx = this.ctx, this.ctx = ve, this.ctx.save(), this.ctx.setTransform(me, 0, 0, -Te, 0, he * Te), M(this.ctx);
                } else
                  M(this.ctx), this.ctx.rect(F[0], F[1], Q, he), this.ctx.clip(), this.endPath();
              }
              this.current = new O(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...U), this.transform(...Z);
            }
            endAnnotation() {
              this.annotationCanvas && (this.ctx.restore(), _e(this, ge, gn).call(this), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas);
            }
            paintImageMaskXObject(A) {
              if (!this.contentVisible)
                return;
              const F = A.count;
              A = this.getObject(A.data, A), A.count = F;
              const U = this.ctx, Z = this.processingType3;
              if (Z && (Z.compiled === void 0 && (Z.compiled = C(A)), Z.compiled)) {
                Z.compiled(U);
                return;
              }
              const G = this._createMaskCanvas(A), Q = G.canvas;
              U.save(), U.setTransform(1, 0, 0, 1, 0, 0), U.drawImage(Q, G.offsetX, G.offsetY), U.restore(), this.compose();
            }
            paintImageMaskXObjectRepeat(A, F, U = 0, Z = 0, G, Q) {
              if (!this.contentVisible)
                return;
              A = this.getObject(A.data, A);
              const he = this.ctx;
              he.save();
              const me = (0, u.getCurrentTransform)(he);
              he.transform(F, U, Z, G, 0, 0);
              const Te = this._createMaskCanvas(A);
              he.setTransform(1, 0, 0, 1, Te.offsetX - me[4], Te.offsetY - me[5]);
              for (let Pe = 0, Re = Q.length; Pe < Re; Pe += 2) {
                const Me = d.Util.transform(me, [F, U, Z, G, Q[Pe], Q[Pe + 1]]), [Fe, ve] = d.Util.applyTransform([0, 0], Me);
                he.drawImage(Te.canvas, Fe, ve);
              }
              he.restore(), this.compose();
            }
            paintImageMaskXObjectGroup(A) {
              if (!this.contentVisible)
                return;
              const F = this.ctx, U = this.current.fillColor, Z = this.current.patternFill;
              for (const G of A) {
                const {
                  data: Q,
                  width: he,
                  height: me,
                  transform: Te
                } = G, Pe = this.cachedCanvases.getCanvas("maskCanvas", he, me), Re = Pe.context;
                Re.save();
                const Me = this.getObject(Q, G);
                B(Re, Me), Re.globalCompositeOperation = "source-in", Re.fillStyle = Z ? U.getPattern(Re, this, (0, u.getCurrentTransformInverse)(F), _.PathType.FILL) : U, Re.fillRect(0, 0, he, me), Re.restore(), F.save(), F.transform(...Te), F.scale(1, -1), T(F, Pe.canvas, 0, 0, he, me, 0, -1, 1, 1), F.restore();
              }
              this.compose();
            }
            paintImageXObject(A) {
              if (!this.contentVisible)
                return;
              const F = this.getObject(A);
              if (!F) {
                (0, d.warn)("Dependent image isn't ready yet");
                return;
              }
              this.paintInlineImageXObject(F);
            }
            paintImageXObjectRepeat(A, F, U, Z) {
              if (!this.contentVisible)
                return;
              const G = this.getObject(A);
              if (!G) {
                (0, d.warn)("Dependent image isn't ready yet");
                return;
              }
              const Q = G.width, he = G.height, me = [];
              for (let Te = 0, Pe = Z.length; Te < Pe; Te += 2)
                me.push({
                  transform: [F, 0, 0, U, Z[Te], Z[Te + 1]],
                  x: 0,
                  y: 0,
                  w: Q,
                  h: he
                });
              this.paintInlineImageXObjectGroup(G, me);
            }
            applyTransferMapsToCanvas(A) {
              return this.current.transferMaps !== "none" && (A.filter = this.current.transferMaps, A.drawImage(A.canvas, 0, 0), A.filter = "none"), A.canvas;
            }
            applyTransferMapsToBitmap(A) {
              if (this.current.transferMaps === "none")
                return A.bitmap;
              const {
                bitmap: F,
                width: U,
                height: Z
              } = A, G = this.cachedCanvases.getCanvas("inlineImage", U, Z), Q = G.context;
              return Q.filter = this.current.transferMaps, Q.drawImage(F, 0, 0), Q.filter = "none", G.canvas;
            }
            paintInlineImageXObject(A) {
              if (!this.contentVisible)
                return;
              const F = A.width, U = A.height, Z = this.ctx;
              if (this.save(), !d.isNodeJS) {
                const {
                  filter: he
                } = Z;
                he !== "none" && he !== "" && (Z.filter = "none");
              }
              Z.scale(1 / F, -1 / U);
              let G;
              if (A.bitmap)
                G = this.applyTransferMapsToBitmap(A);
              else if (typeof HTMLElement == "function" && A instanceof HTMLElement || !A.data)
                G = A;
              else {
                const me = this.cachedCanvases.getCanvas("inlineImage", F, U).context;
                j(me, A), G = this.applyTransferMapsToCanvas(me);
              }
              const Q = this._scaleImage(G, (0, u.getCurrentTransformInverse)(Z));
              Z.imageSmoothingEnabled = W((0, u.getCurrentTransform)(Z), A.interpolate), T(Z, Q.img, 0, 0, Q.paintWidth, Q.paintHeight, 0, -U, F, U), this.compose(), this.restore();
            }
            paintInlineImageXObjectGroup(A, F) {
              if (!this.contentVisible)
                return;
              const U = this.ctx;
              let Z;
              if (A.bitmap)
                Z = A.bitmap;
              else {
                const G = A.width, Q = A.height, me = this.cachedCanvases.getCanvas("inlineImage", G, Q).context;
                j(me, A), Z = this.applyTransferMapsToCanvas(me);
              }
              for (const G of F)
                U.save(), U.transform(...G.transform), U.scale(1, -1), T(U, Z, G.x, G.y, G.w, G.h, 0, -1, 1, 1), U.restore();
              this.compose();
            }
            paintSolidColorImageMask() {
              this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose());
            }
            markPoint(A) {
            }
            markPointProps(A, F) {
            }
            beginMarkedContent(A) {
              this.markedContentStack.push({
                visible: !0
              });
            }
            beginMarkedContentProps(A, F) {
              A === "OC" ? this.markedContentStack.push({
                visible: this.optionalContentConfig.isVisible(F)
              }) : this.markedContentStack.push({
                visible: !0
              }), this.contentVisible = this.isContentVisible();
            }
            endMarkedContent() {
              this.markedContentStack.pop(), this.contentVisible = this.isContentVisible();
            }
            beginCompat() {
            }
            endCompat() {
            }
            consumePath(A) {
              const F = this.current.isEmptyClip();
              this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(A);
              const U = this.ctx;
              this.pendingClip && (F || (this.pendingClip === ce ? U.clip("evenodd") : U.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), U.beginPath();
            }
            getSinglePixelWidth() {
              if (!this._cachedGetSinglePixelWidth) {
                const A = (0, u.getCurrentTransform)(this.ctx);
                if (A[1] === 0 && A[2] === 0)
                  this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(A[0]), Math.abs(A[3]));
                else {
                  const F = Math.abs(A[0] * A[3] - A[2] * A[1]), U = Math.hypot(A[0], A[2]), Z = Math.hypot(A[1], A[3]);
                  this._cachedGetSinglePixelWidth = Math.max(U, Z) / F;
                }
              }
              return this._cachedGetSinglePixelWidth;
            }
            getScaleForStroking() {
              if (this._cachedScaleForStroking[0] === -1) {
                const {
                  lineWidth: A
                } = this.current, {
                  a: F,
                  b: U,
                  c: Z,
                  d: G
                } = this.ctx.getTransform();
                let Q, he;
                if (U === 0 && Z === 0) {
                  const me = Math.abs(F), Te = Math.abs(G);
                  if (me === Te)
                    if (A === 0)
                      Q = he = 1 / me;
                    else {
                      const Pe = me * A;
                      Q = he = Pe < 1 ? 1 / Pe : 1;
                    }
                  else if (A === 0)
                    Q = 1 / me, he = 1 / Te;
                  else {
                    const Pe = me * A, Re = Te * A;
                    Q = Pe < 1 ? 1 / Pe : 1, he = Re < 1 ? 1 / Re : 1;
                  }
                } else {
                  const me = Math.abs(F * G - U * Z), Te = Math.hypot(F, U), Pe = Math.hypot(Z, G);
                  if (A === 0)
                    Q = Pe / me, he = Te / me;
                  else {
                    const Re = A * me;
                    Q = Pe > Re ? Pe / Re : 1, he = Te > Re ? Te / Re : 1;
                  }
                }
                this._cachedScaleForStroking[0] = Q, this._cachedScaleForStroking[1] = he;
              }
              return this._cachedScaleForStroking;
            }
            rescaleAndStroke(A) {
              const {
                ctx: F
              } = this, {
                lineWidth: U
              } = this.current, [Z, G] = this.getScaleForStroking();
              if (F.lineWidth = U || 1, Z === 1 && G === 1) {
                F.stroke();
                return;
              }
              const Q = F.getLineDash();
              if (A && F.save(), F.scale(Z, G), Q.length > 0) {
                const he = Math.max(Z, G);
                F.setLineDash(Q.map((me) => me / he)), F.lineDashOffset /= he;
              }
              F.stroke(), A && F.restore();
            }
            isContentVisible() {
              for (let A = this.markedContentStack.length - 1; A >= 0; A--)
                if (!this.markedContentStack[A].visible)
                  return !1;
              return !0;
            }
          };
          ge = new WeakSet(), mn = function() {
            for (; this.stateStack.length || this.inSMaskMode; )
              this.restore();
            this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null);
          }, gn = function() {
            if (this.pageColors) {
              const A = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
              if (A !== "none") {
                const F = this.ctx.filter;
                this.ctx.filter = A, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = F;
              }
            }
          };
          let oe = le;
          a.CanvasGraphics = oe;
          for (const z in d.OPS)
            oe.prototype[z] !== void 0 && (oe.prototype[d.OPS[z]] = oe.prototype[z]);
        },
        /* 12 */
        /***/
        (c, a, h) => {
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.TilingPattern = a.PathType = void 0, a.getShadingPattern = R;
          var d = h(1), u = h(6);
          const _ = {
            FILL: "Fill",
            STROKE: "Stroke",
            SHADING: "Shading"
          };
          a.PathType = _;
          function g(C, O) {
            if (!O)
              return;
            const j = O[2] - O[0], B = O[3] - O[1], D = new Path2D();
            D.rect(O[0], O[1], j, B), C.clip(D);
          }
          class $ {
            constructor() {
              this.constructor === $ && (0, d.unreachable)("Cannot initialize BaseShadingPattern.");
            }
            getPattern() {
              (0, d.unreachable)("Abstract method `getPattern` called.");
            }
          }
          class b extends $ {
            constructor(O) {
              super(), this._type = O[1], this._bbox = O[2], this._colorStops = O[3], this._p0 = O[4], this._p1 = O[5], this._r0 = O[6], this._r1 = O[7], this.matrix = null;
            }
            _createGradient(O) {
              let j;
              this._type === "axial" ? j = O.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (j = O.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1));
              for (const B of this._colorStops)
                j.addColorStop(B[0], B[1]);
              return j;
            }
            getPattern(O, j, B, D) {
              let M;
              if (D === _.STROKE || D === _.FILL) {
                const I = j.current.getClippedPathBoundingBox(D, (0, u.getCurrentTransform)(O)) || [0, 0, 0, 0], P = Math.ceil(I[2] - I[0]) || 1, L = Math.ceil(I[3] - I[1]) || 1, Y = j.cachedCanvases.getCanvas("pattern", P, L, !0), N = Y.context;
                N.clearRect(0, 0, N.canvas.width, N.canvas.height), N.beginPath(), N.rect(0, 0, N.canvas.width, N.canvas.height), N.translate(-I[0], -I[1]), B = d.Util.transform(B, [1, 0, 0, 1, I[0], I[1]]), N.transform(...j.baseTransform), this.matrix && N.transform(...this.matrix), g(N, this._bbox), N.fillStyle = this._createGradient(N), N.fill(), M = O.createPattern(Y.canvas, "no-repeat");
                const W = new DOMMatrix(B);
                M.setTransform(W);
              } else
                g(O, this._bbox), M = this._createGradient(O);
              return M;
            }
          }
          function y(C, O, j, B, D, M, I, P) {
            const L = O.coords, Y = O.colors, N = C.data, W = C.width * 4;
            let V;
            L[j + 1] > L[B + 1] && (V = j, j = B, B = V, V = M, M = I, I = V), L[B + 1] > L[D + 1] && (V = B, B = D, D = V, V = I, I = P, P = V), L[j + 1] > L[B + 1] && (V = j, j = B, B = V, V = M, M = I, I = V);
            const ue = (L[j] + O.offsetX) * O.scaleX, se = (L[j + 1] + O.offsetY) * O.scaleY, ce = (L[B] + O.offsetX) * O.scaleX, oe = (L[B + 1] + O.offsetY) * O.scaleY, ge = (L[D] + O.offsetX) * O.scaleX, J = (L[D + 1] + O.offsetY) * O.scaleY;
            if (se >= J)
              return;
            const ae = Y[M], le = Y[M + 1], z = Y[M + 2], A = Y[I], F = Y[I + 1], U = Y[I + 2], Z = Y[P], G = Y[P + 1], Q = Y[P + 2], he = Math.round(se), me = Math.round(J);
            let Te, Pe, Re, Me, Fe, ve, be, X;
            for (let ne = he; ne <= me; ne++) {
              if (ne < oe) {
                const Ie = ne < se ? 0 : (se - ne) / (se - oe);
                Te = ue - (ue - ce) * Ie, Pe = ae - (ae - A) * Ie, Re = le - (le - F) * Ie, Me = z - (z - U) * Ie;
              } else {
                let Ie;
                ne > J ? Ie = 1 : oe === J ? Ie = 0 : Ie = (oe - ne) / (oe - J), Te = ce - (ce - ge) * Ie, Pe = A - (A - Z) * Ie, Re = F - (F - G) * Ie, Me = U - (U - Q) * Ie;
              }
              let te;
              ne < se ? te = 0 : ne > J ? te = 1 : te = (se - ne) / (se - J), Fe = ue - (ue - ge) * te, ve = ae - (ae - Z) * te, be = le - (le - G) * te, X = z - (z - Q) * te;
              const ye = Math.round(Math.min(Te, Fe)), xe = Math.round(Math.max(Te, Fe));
              let Le = W * ne + ye * 4;
              for (let Ie = ye; Ie <= xe; Ie++)
                te = (Te - Ie) / (Te - Fe), te < 0 ? te = 0 : te > 1 && (te = 1), N[Le++] = Pe - (Pe - ve) * te | 0, N[Le++] = Re - (Re - be) * te | 0, N[Le++] = Me - (Me - X) * te | 0, N[Le++] = 255;
            }
          }
          function v(C, O, j) {
            const B = O.coords, D = O.colors;
            let M, I;
            switch (O.type) {
              case "lattice":
                const P = O.verticesPerRow, L = Math.floor(B.length / P) - 1, Y = P - 1;
                for (M = 0; M < L; M++) {
                  let N = M * P;
                  for (let W = 0; W < Y; W++, N++)
                    y(C, j, B[N], B[N + 1], B[N + P], D[N], D[N + 1], D[N + P]), y(C, j, B[N + P + 1], B[N + 1], B[N + P], D[N + P + 1], D[N + 1], D[N + P]);
                }
                break;
              case "triangles":
                for (M = 0, I = B.length; M < I; M += 3)
                  y(C, j, B[M], B[M + 1], B[M + 2], D[M], D[M + 1], D[M + 2]);
                break;
              default:
                throw new Error("illegal figure");
            }
          }
          class E extends $ {
            constructor(O) {
              super(), this._coords = O[2], this._colors = O[3], this._figures = O[4], this._bounds = O[5], this._bbox = O[7], this._background = O[8], this.matrix = null;
            }
            _createMeshCanvas(O, j, B) {
              const P = Math.floor(this._bounds[0]), L = Math.floor(this._bounds[1]), Y = Math.ceil(this._bounds[2]) - P, N = Math.ceil(this._bounds[3]) - L, W = Math.min(Math.ceil(Math.abs(Y * O[0] * 1.1)), 3e3), V = Math.min(Math.ceil(Math.abs(N * O[1] * 1.1)), 3e3), ue = Y / W, se = N / V, ce = {
                coords: this._coords,
                colors: this._colors,
                offsetX: -P,
                offsetY: -L,
                scaleX: 1 / ue,
                scaleY: 1 / se
              }, oe = W + 2 * 2, ge = V + 2 * 2, J = B.getCanvas("mesh", oe, ge, !1), ae = J.context, le = ae.createImageData(W, V);
              if (j) {
                const A = le.data;
                for (let F = 0, U = A.length; F < U; F += 4)
                  A[F] = j[0], A[F + 1] = j[1], A[F + 2] = j[2], A[F + 3] = 255;
              }
              for (const A of this._figures)
                v(le, A, ce);
              return ae.putImageData(le, 2, 2), {
                canvas: J.canvas,
                offsetX: P - 2 * ue,
                offsetY: L - 2 * se,
                scaleX: ue,
                scaleY: se
              };
            }
            getPattern(O, j, B, D) {
              g(O, this._bbox);
              let M;
              if (D === _.SHADING)
                M = d.Util.singularValueDecompose2dScale((0, u.getCurrentTransform)(O));
              else if (M = d.Util.singularValueDecompose2dScale(j.baseTransform), this.matrix) {
                const P = d.Util.singularValueDecompose2dScale(this.matrix);
                M = [M[0] * P[0], M[1] * P[1]];
              }
              const I = this._createMeshCanvas(M, D === _.SHADING ? null : this._background, j.cachedCanvases);
              return D !== _.SHADING && (O.setTransform(...j.baseTransform), this.matrix && O.transform(...this.matrix)), O.translate(I.offsetX, I.offsetY), O.scale(I.scaleX, I.scaleY), O.createPattern(I.canvas, "no-repeat");
            }
          }
          class S extends $ {
            getPattern() {
              return "hotpink";
            }
          }
          function R(C) {
            switch (C[0]) {
              case "RadialAxial":
                return new b(C);
              case "Mesh":
                return new E(C);
              case "Dummy":
                return new S();
            }
            throw new Error(`Unknown IR type: ${C[0]}`);
          }
          const x = {
            COLORED: 1,
            UNCOLORED: 2
          }, T = class T {
            constructor(O, j, B, D, M) {
              this.operatorList = O[2], this.matrix = O[3] || [1, 0, 0, 1, 0, 0], this.bbox = O[4], this.xstep = O[5], this.ystep = O[6], this.paintType = O[7], this.tilingType = O[8], this.color = j, this.ctx = B, this.canvasGraphicsFactory = D, this.baseTransform = M;
            }
            createPatternCanvas(O) {
              const j = this.operatorList, B = this.bbox, D = this.xstep, M = this.ystep, I = this.paintType, P = this.tilingType, L = this.color, Y = this.canvasGraphicsFactory;
              (0, d.info)("TilingType: " + P);
              const N = B[0], W = B[1], V = B[2], ue = B[3], se = d.Util.singularValueDecompose2dScale(this.matrix), ce = d.Util.singularValueDecompose2dScale(this.baseTransform), oe = [se[0] * ce[0], se[1] * ce[1]], ge = this.getSizeAndScale(D, this.ctx.canvas.width, oe[0]), J = this.getSizeAndScale(M, this.ctx.canvas.height, oe[1]), ae = O.cachedCanvases.getCanvas("pattern", ge.size, J.size, !0), le = ae.context, z = Y.createCanvasGraphics(le);
              z.groupLevel = O.groupLevel, this.setFillAndStrokeStyleToContext(z, I, L);
              let A = N, F = W, U = V, Z = ue;
              return N < 0 && (A = 0, U += Math.abs(N)), W < 0 && (F = 0, Z += Math.abs(W)), le.translate(-(ge.scale * A), -(J.scale * F)), z.transform(ge.scale, 0, 0, J.scale, 0, 0), le.save(), this.clipBbox(z, A, F, U, Z), z.baseTransform = (0, u.getCurrentTransform)(z.ctx), z.executeOperatorList(j), z.endDrawing(), {
                canvas: ae.canvas,
                scaleX: ge.scale,
                scaleY: J.scale,
                offsetX: A,
                offsetY: F
              };
            }
            getSizeAndScale(O, j, B) {
              O = Math.abs(O);
              const D = Math.max(T.MAX_PATTERN_SIZE, j);
              let M = Math.ceil(O * B);
              return M >= D ? M = D : B = M / O, {
                scale: B,
                size: M
              };
            }
            clipBbox(O, j, B, D, M) {
              const I = D - j, P = M - B;
              O.ctx.rect(j, B, I, P), O.current.updateRectMinMax((0, u.getCurrentTransform)(O.ctx), [j, B, D, M]), O.clip(), O.endPath();
            }
            setFillAndStrokeStyleToContext(O, j, B) {
              const D = O.ctx, M = O.current;
              switch (j) {
                case x.COLORED:
                  const I = this.ctx;
                  D.fillStyle = I.fillStyle, D.strokeStyle = I.strokeStyle, M.fillColor = I.fillStyle, M.strokeColor = I.strokeStyle;
                  break;
                case x.UNCOLORED:
                  const P = d.Util.makeHexColor(B[0], B[1], B[2]);
                  D.fillStyle = P, D.strokeStyle = P, M.fillColor = P, M.strokeColor = P;
                  break;
                default:
                  throw new d.FormatError(`Unsupported paint type: ${j}`);
              }
            }
            getPattern(O, j, B, D) {
              let M = B;
              D !== _.SHADING && (M = d.Util.transform(M, j.baseTransform), this.matrix && (M = d.Util.transform(M, this.matrix)));
              const I = this.createPatternCanvas(j);
              let P = new DOMMatrix(M);
              P = P.translate(I.offsetX, I.offsetY), P = P.scale(1 / I.scaleX, 1 / I.scaleY);
              const L = O.createPattern(I.canvas, "repeat");
              return L.setTransform(P), L;
            }
          };
          _t(T, "MAX_PATTERN_SIZE", 3e3);
          let H = T;
          a.TilingPattern = H;
        },
        /* 13 */
        /***/
        (c, a, h) => {
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.convertBlackAndWhiteToRGBA = _, a.convertToRGBA = u, a.grayToRGBA = $;
          var d = h(1);
          function u(b) {
            switch (b.kind) {
              case d.ImageKind.GRAYSCALE_1BPP:
                return _(b);
              case d.ImageKind.RGB_24BPP:
                return g(b);
            }
            return null;
          }
          function _({
            src: b,
            srcPos: y = 0,
            dest: v,
            width: E,
            height: S,
            nonBlackColor: R = 4294967295,
            inverseDecode: x = !1
          }) {
            const H = d.FeatureTest.isLittleEndian ? 4278190080 : 255, [T, C] = x ? [R, H] : [H, R], O = E >> 3, j = E & 7, B = b.length;
            v = new Uint32Array(v.buffer);
            let D = 0;
            for (let M = 0; M < S; M++) {
              for (const P = y + O; y < P; y++) {
                const L = y < B ? b[y] : 255;
                v[D++] = L & 128 ? C : T, v[D++] = L & 64 ? C : T, v[D++] = L & 32 ? C : T, v[D++] = L & 16 ? C : T, v[D++] = L & 8 ? C : T, v[D++] = L & 4 ? C : T, v[D++] = L & 2 ? C : T, v[D++] = L & 1 ? C : T;
              }
              if (j === 0)
                continue;
              const I = y < B ? b[y++] : 255;
              for (let P = 0; P < j; P++)
                v[D++] = I & 1 << 7 - P ? C : T;
            }
            return {
              srcPos: y,
              destPos: D
            };
          }
          function g({
            src: b,
            srcPos: y = 0,
            dest: v,
            destPos: E = 0,
            width: S,
            height: R
          }) {
            let x = 0;
            const H = b.length >> 2, T = new Uint32Array(b.buffer, y, H);
            if (d.FeatureTest.isLittleEndian) {
              for (; x < H - 2; x += 3, E += 4) {
                const C = T[x], O = T[x + 1], j = T[x + 2];
                v[E] = C | 4278190080, v[E + 1] = C >>> 24 | O << 8 | 4278190080, v[E + 2] = O >>> 16 | j << 16 | 4278190080, v[E + 3] = j >>> 8 | 4278190080;
              }
              for (let C = x * 4, O = b.length; C < O; C += 3)
                v[E++] = b[C] | b[C + 1] << 8 | b[C + 2] << 16 | 4278190080;
            } else {
              for (; x < H - 2; x += 3, E += 4) {
                const C = T[x], O = T[x + 1], j = T[x + 2];
                v[E] = C | 255, v[E + 1] = C << 24 | O >>> 8 | 255, v[E + 2] = O << 16 | j >>> 16 | 255, v[E + 3] = j << 8 | 255;
              }
              for (let C = x * 4, O = b.length; C < O; C += 3)
                v[E++] = b[C] << 24 | b[C + 1] << 16 | b[C + 2] << 8 | 255;
            }
            return {
              srcPos: y,
              destPos: E
            };
          }
          function $(b, y) {
            if (d.FeatureTest.isLittleEndian)
              for (let v = 0, E = b.length; v < E; v++)
                y[v] = b[v] * 65793 | 4278190080;
            else
              for (let v = 0, E = b.length; v < E; v++)
                y[v] = b[v] * 16843008 | 255;
          }
        },
        /* 14 */
        /***/
        (c, a) => {
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.GlobalWorkerOptions = void 0;
          const h = /* @__PURE__ */ Object.create(null);
          a.GlobalWorkerOptions = h, h.workerPort = null, h.workerSrc = "";
        },
        /* 15 */
        /***/
        (c, a, h) => {
          var b, Xn, Yn, zt;
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.MessageHandler = void 0;
          var d = h(1);
          const u = {
            DATA: 1,
            ERROR: 2
          }, _ = {
            CANCEL: 1,
            CANCEL_COMPLETE: 2,
            CLOSE: 3,
            ENQUEUE: 4,
            ERROR: 5,
            PULL: 6,
            PULL_COMPLETE: 7,
            START_COMPLETE: 8
          };
          function g(S) {
            switch (S instanceof Error || typeof S == "object" && S !== null || (0, d.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), S.name) {
              case "AbortException":
                return new d.AbortException(S.message);
              case "MissingPDFException":
                return new d.MissingPDFException(S.message);
              case "PasswordException":
                return new d.PasswordException(S.message, S.code);
              case "UnexpectedResponseException":
                return new d.UnexpectedResponseException(S.message, S.status);
              case "UnknownErrorException":
                return new d.UnknownErrorException(S.message, S.details);
              default:
                return new d.UnknownErrorException(S.message, S.toString());
            }
          }
          class $ {
            constructor(R, x, H) {
              Ee(this, b);
              this.sourceName = R, this.targetName = x, this.comObj = H, this.callbackId = 1, this.streamId = 1, this.streamSinks = /* @__PURE__ */ Object.create(null), this.streamControllers = /* @__PURE__ */ Object.create(null), this.callbackCapabilities = /* @__PURE__ */ Object.create(null), this.actionHandler = /* @__PURE__ */ Object.create(null), this._onComObjOnMessage = (T) => {
                const C = T.data;
                if (C.targetName !== this.sourceName)
                  return;
                if (C.stream) {
                  _e(this, b, Yn).call(this, C);
                  return;
                }
                if (C.callback) {
                  const j = C.callbackId, B = this.callbackCapabilities[j];
                  if (!B)
                    throw new Error(`Cannot resolve callback ${j}`);
                  if (delete this.callbackCapabilities[j], C.callback === u.DATA)
                    B.resolve(C.data);
                  else if (C.callback === u.ERROR)
                    B.reject(g(C.reason));
                  else
                    throw new Error("Unexpected callback case");
                  return;
                }
                const O = this.actionHandler[C.action];
                if (!O)
                  throw new Error(`Unknown action from worker: ${C.action}`);
                if (C.callbackId) {
                  const j = this.sourceName, B = C.sourceName;
                  new Promise(function(D) {
                    D(O(C.data));
                  }).then(function(D) {
                    H.postMessage({
                      sourceName: j,
                      targetName: B,
                      callback: u.DATA,
                      callbackId: C.callbackId,
                      data: D
                    });
                  }, function(D) {
                    H.postMessage({
                      sourceName: j,
                      targetName: B,
                      callback: u.ERROR,
                      callbackId: C.callbackId,
                      reason: g(D)
                    });
                  });
                  return;
                }
                if (C.streamId) {
                  _e(this, b, Xn).call(this, C);
                  return;
                }
                O(C.data);
              }, H.addEventListener("message", this._onComObjOnMessage);
            }
            on(R, x) {
              const H = this.actionHandler;
              if (H[R])
                throw new Error(`There is already an actionName called "${R}"`);
              H[R] = x;
            }
            send(R, x, H) {
              this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: R,
                data: x
              }, H);
            }
            sendWithPromise(R, x, H) {
              const T = this.callbackId++, C = new d.PromiseCapability();
              this.callbackCapabilities[T] = C;
              try {
                this.comObj.postMessage({
                  sourceName: this.sourceName,
                  targetName: this.targetName,
                  action: R,
                  callbackId: T,
                  data: x
                }, H);
              } catch (O) {
                C.reject(O);
              }
              return C.promise;
            }
            sendWithStream(R, x, H, T) {
              const C = this.streamId++, O = this.sourceName, j = this.targetName, B = this.comObj;
              return new ReadableStream({
                start: (D) => {
                  const M = new d.PromiseCapability();
                  return this.streamControllers[C] = {
                    controller: D,
                    startCall: M,
                    pullCall: null,
                    cancelCall: null,
                    isClosed: !1
                  }, B.postMessage({
                    sourceName: O,
                    targetName: j,
                    action: R,
                    streamId: C,
                    data: x,
                    desiredSize: D.desiredSize
                  }, T), M.promise;
                },
                pull: (D) => {
                  const M = new d.PromiseCapability();
                  return this.streamControllers[C].pullCall = M, B.postMessage({
                    sourceName: O,
                    targetName: j,
                    stream: _.PULL,
                    streamId: C,
                    desiredSize: D.desiredSize
                  }), M.promise;
                },
                cancel: (D) => {
                  (0, d.assert)(D instanceof Error, "cancel must have a valid reason");
                  const M = new d.PromiseCapability();
                  return this.streamControllers[C].cancelCall = M, this.streamControllers[C].isClosed = !0, B.postMessage({
                    sourceName: O,
                    targetName: j,
                    stream: _.CANCEL,
                    streamId: C,
                    reason: g(D)
                  }), M.promise;
                }
              }, H);
            }
            destroy() {
              this.comObj.removeEventListener("message", this._onComObjOnMessage);
            }
          }
          b = new WeakSet(), Xn = function(R) {
            const x = R.streamId, H = this.sourceName, T = R.sourceName, C = this.comObj, O = this, j = this.actionHandler[R.action], B = {
              enqueue(D, M = 1, I) {
                if (this.isCancelled)
                  return;
                const P = this.desiredSize;
                this.desiredSize -= M, P > 0 && this.desiredSize <= 0 && (this.sinkCapability = new d.PromiseCapability(), this.ready = this.sinkCapability.promise), C.postMessage({
                  sourceName: H,
                  targetName: T,
                  stream: _.ENQUEUE,
                  streamId: x,
                  chunk: D
                }, I);
              },
              close() {
                this.isCancelled || (this.isCancelled = !0, C.postMessage({
                  sourceName: H,
                  targetName: T,
                  stream: _.CLOSE,
                  streamId: x
                }), delete O.streamSinks[x]);
              },
              error(D) {
                (0, d.assert)(D instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, C.postMessage({
                  sourceName: H,
                  targetName: T,
                  stream: _.ERROR,
                  streamId: x,
                  reason: g(D)
                }));
              },
              sinkCapability: new d.PromiseCapability(),
              onPull: null,
              onCancel: null,
              isCancelled: !1,
              desiredSize: R.desiredSize,
              ready: null
            };
            B.sinkCapability.resolve(), B.ready = B.sinkCapability.promise, this.streamSinks[x] = B, new Promise(function(D) {
              D(j(R.data, B));
            }).then(function() {
              C.postMessage({
                sourceName: H,
                targetName: T,
                stream: _.START_COMPLETE,
                streamId: x,
                success: !0
              });
            }, function(D) {
              C.postMessage({
                sourceName: H,
                targetName: T,
                stream: _.START_COMPLETE,
                streamId: x,
                reason: g(D)
              });
            });
          }, Yn = function(R) {
            const x = R.streamId, H = this.sourceName, T = R.sourceName, C = this.comObj, O = this.streamControllers[x], j = this.streamSinks[x];
            switch (R.stream) {
              case _.START_COMPLETE:
                R.success ? O.startCall.resolve() : O.startCall.reject(g(R.reason));
                break;
              case _.PULL_COMPLETE:
                R.success ? O.pullCall.resolve() : O.pullCall.reject(g(R.reason));
                break;
              case _.PULL:
                if (!j) {
                  C.postMessage({
                    sourceName: H,
                    targetName: T,
                    stream: _.PULL_COMPLETE,
                    streamId: x,
                    success: !0
                  });
                  break;
                }
                j.desiredSize <= 0 && R.desiredSize > 0 && j.sinkCapability.resolve(), j.desiredSize = R.desiredSize, new Promise(function(B) {
                  var D;
                  B((D = j.onPull) == null ? void 0 : D.call(j));
                }).then(function() {
                  C.postMessage({
                    sourceName: H,
                    targetName: T,
                    stream: _.PULL_COMPLETE,
                    streamId: x,
                    success: !0
                  });
                }, function(B) {
                  C.postMessage({
                    sourceName: H,
                    targetName: T,
                    stream: _.PULL_COMPLETE,
                    streamId: x,
                    reason: g(B)
                  });
                });
                break;
              case _.ENQUEUE:
                if ((0, d.assert)(O, "enqueue should have stream controller"), O.isClosed)
                  break;
                O.controller.enqueue(R.chunk);
                break;
              case _.CLOSE:
                if ((0, d.assert)(O, "close should have stream controller"), O.isClosed)
                  break;
                O.isClosed = !0, O.controller.close(), _e(this, b, zt).call(this, O, x);
                break;
              case _.ERROR:
                (0, d.assert)(O, "error should have stream controller"), O.controller.error(g(R.reason)), _e(this, b, zt).call(this, O, x);
                break;
              case _.CANCEL_COMPLETE:
                R.success ? O.cancelCall.resolve() : O.cancelCall.reject(g(R.reason)), _e(this, b, zt).call(this, O, x);
                break;
              case _.CANCEL:
                if (!j)
                  break;
                new Promise(function(B) {
                  var D;
                  B((D = j.onCancel) == null ? void 0 : D.call(j, g(R.reason)));
                }).then(function() {
                  C.postMessage({
                    sourceName: H,
                    targetName: T,
                    stream: _.CANCEL_COMPLETE,
                    streamId: x,
                    success: !0
                  });
                }, function(B) {
                  C.postMessage({
                    sourceName: H,
                    targetName: T,
                    stream: _.CANCEL_COMPLETE,
                    streamId: x,
                    reason: g(B)
                  });
                }), j.sinkCapability.reject(g(R.reason)), j.isCancelled = !0, delete this.streamSinks[x];
                break;
              default:
                throw new Error("Unexpected stream case");
            }
          }, zt = async function(R, x) {
            var H, T, C;
            await Promise.allSettled([(H = R.startCall) == null ? void 0 : H.promise, (T = R.pullCall) == null ? void 0 : T.promise, (C = R.cancelCall) == null ? void 0 : C.promise]), delete this.streamControllers[x];
          }, a.MessageHandler = $;
        },
        /* 16 */
        /***/
        (c, a, h) => {
          var _, g;
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.Metadata = void 0;
          var d = h(1);
          class u {
            constructor({
              parsedData: b,
              rawData: y
            }) {
              Ee(this, _);
              Ee(this, g);
              Se(this, _, b), Se(this, g, y);
            }
            getRaw() {
              return w(this, g);
            }
            get(b) {
              return w(this, _).get(b) ?? null;
            }
            getAll() {
              return (0, d.objectFromMap)(w(this, _));
            }
            has(b) {
              return w(this, _).has(b);
            }
          }
          _ = new WeakMap(), g = new WeakMap(), a.Metadata = u;
        },
        /* 17 */
        /***/
        (c, a, h) => {
          var b, y, v, E, S, R, vn;
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.OptionalContentConfig = void 0;
          var d = h(1), u = h(8);
          const _ = Symbol("INTERNAL");
          class g {
            constructor(T, C) {
              Ee(this, b, !0);
              this.name = T, this.intent = C;
            }
            get visible() {
              return w(this, b);
            }
            _setVisible(T, C) {
              T !== _ && (0, d.unreachable)("Internal method `_setVisible` called."), Se(this, b, C);
            }
          }
          b = new WeakMap();
          class $ {
            constructor(T) {
              Ee(this, R);
              Ee(this, y, null);
              Ee(this, v, /* @__PURE__ */ new Map());
              Ee(this, E, null);
              Ee(this, S, null);
              if (this.name = null, this.creator = null, T !== null) {
                this.name = T.name, this.creator = T.creator, Se(this, S, T.order);
                for (const C of T.groups)
                  w(this, v).set(C.id, new g(C.name, C.intent));
                if (T.baseState === "OFF")
                  for (const C of w(this, v).values())
                    C._setVisible(_, !1);
                for (const C of T.on)
                  w(this, v).get(C)._setVisible(_, !0);
                for (const C of T.off)
                  w(this, v).get(C)._setVisible(_, !1);
                Se(this, E, this.getHash());
              }
            }
            isVisible(T) {
              if (w(this, v).size === 0)
                return !0;
              if (!T)
                return (0, d.warn)("Optional content group not defined."), !0;
              if (T.type === "OCG")
                return w(this, v).has(T.id) ? w(this, v).get(T.id).visible : ((0, d.warn)(`Optional content group not found: ${T.id}`), !0);
              if (T.type === "OCMD") {
                if (T.expression)
                  return _e(this, R, vn).call(this, T.expression);
                if (!T.policy || T.policy === "AnyOn") {
                  for (const C of T.ids) {
                    if (!w(this, v).has(C))
                      return (0, d.warn)(`Optional content group not found: ${C}`), !0;
                    if (w(this, v).get(C).visible)
                      return !0;
                  }
                  return !1;
                } else if (T.policy === "AllOn") {
                  for (const C of T.ids) {
                    if (!w(this, v).has(C))
                      return (0, d.warn)(`Optional content group not found: ${C}`), !0;
                    if (!w(this, v).get(C).visible)
                      return !1;
                  }
                  return !0;
                } else if (T.policy === "AnyOff") {
                  for (const C of T.ids) {
                    if (!w(this, v).has(C))
                      return (0, d.warn)(`Optional content group not found: ${C}`), !0;
                    if (!w(this, v).get(C).visible)
                      return !0;
                  }
                  return !1;
                } else if (T.policy === "AllOff") {
                  for (const C of T.ids) {
                    if (!w(this, v).has(C))
                      return (0, d.warn)(`Optional content group not found: ${C}`), !0;
                    if (w(this, v).get(C).visible)
                      return !1;
                  }
                  return !0;
                }
                return (0, d.warn)(`Unknown optional content policy ${T.policy}.`), !0;
              }
              return (0, d.warn)(`Unknown group type ${T.type}.`), !0;
            }
            setVisibility(T, C = !0) {
              if (!w(this, v).has(T)) {
                (0, d.warn)(`Optional content group not found: ${T}`);
                return;
              }
              w(this, v).get(T)._setVisible(_, !!C), Se(this, y, null);
            }
            get hasInitialVisibility() {
              return w(this, E) === null || this.getHash() === w(this, E);
            }
            getOrder() {
              return w(this, v).size ? w(this, S) ? w(this, S).slice() : [...w(this, v).keys()] : null;
            }
            getGroups() {
              return w(this, v).size > 0 ? (0, d.objectFromMap)(w(this, v)) : null;
            }
            getGroup(T) {
              return w(this, v).get(T) || null;
            }
            getHash() {
              if (w(this, y) !== null)
                return w(this, y);
              const T = new u.MurmurHash3_64();
              for (const [C, O] of w(this, v))
                T.update(`${C}:${O.visible}`);
              return Se(this, y, T.hexdigest());
            }
          }
          y = new WeakMap(), v = new WeakMap(), E = new WeakMap(), S = new WeakMap(), R = new WeakSet(), vn = function(T) {
            const C = T.length;
            if (C < 2)
              return !0;
            const O = T[0];
            for (let j = 1; j < C; j++) {
              const B = T[j];
              let D;
              if (Array.isArray(B))
                D = _e(this, R, vn).call(this, B);
              else if (w(this, v).has(B))
                D = w(this, v).get(B).visible;
              else
                return (0, d.warn)(`Optional content group not found: ${B}`), !0;
              switch (O) {
                case "And":
                  if (!D)
                    return !1;
                  break;
                case "Or":
                  if (D)
                    return !0;
                  break;
                case "Not":
                  return !D;
                default:
                  return !0;
              }
            }
            return O === "And";
          }, a.OptionalContentConfig = $;
        },
        /* 18 */
        /***/
        (c, a, h) => {
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.PDFDataTransportStream = void 0;
          var d = h(1), u = h(6);
          class _ {
            constructor({
              length: y,
              initialData: v,
              progressiveDone: E = !1,
              contentDispositionFilename: S = null,
              disableRange: R = !1,
              disableStream: x = !1
            }, H) {
              if ((0, d.assert)(H, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'), this._queuedChunks = [], this._progressiveDone = E, this._contentDispositionFilename = S, (v == null ? void 0 : v.length) > 0) {
                const T = v instanceof Uint8Array && v.byteLength === v.buffer.byteLength ? v.buffer : new Uint8Array(v).buffer;
                this._queuedChunks.push(T);
              }
              this._pdfDataRangeTransport = H, this._isStreamingSupported = !x, this._isRangeSupported = !R, this._contentLength = y, this._fullRequestReader = null, this._rangeReaders = [], this._pdfDataRangeTransport.addRangeListener((T, C) => {
                this._onReceiveData({
                  begin: T,
                  chunk: C
                });
              }), this._pdfDataRangeTransport.addProgressListener((T, C) => {
                this._onProgress({
                  loaded: T,
                  total: C
                });
              }), this._pdfDataRangeTransport.addProgressiveReadListener((T) => {
                this._onReceiveData({
                  chunk: T
                });
              }), this._pdfDataRangeTransport.addProgressiveDoneListener(() => {
                this._onProgressiveDone();
              }), this._pdfDataRangeTransport.transportReady();
            }
            _onReceiveData({
              begin: y,
              chunk: v
            }) {
              const E = v instanceof Uint8Array && v.byteLength === v.buffer.byteLength ? v.buffer : new Uint8Array(v).buffer;
              if (y === void 0)
                this._fullRequestReader ? this._fullRequestReader._enqueue(E) : this._queuedChunks.push(E);
              else {
                const S = this._rangeReaders.some(function(R) {
                  return R._begin !== y ? !1 : (R._enqueue(E), !0);
                });
                (0, d.assert)(S, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
              }
            }
            get _progressiveDataLength() {
              var y;
              return ((y = this._fullRequestReader) == null ? void 0 : y._loaded) ?? 0;
            }
            _onProgress(y) {
              var v, E, S, R;
              y.total === void 0 ? (E = (v = this._rangeReaders[0]) == null ? void 0 : v.onProgress) == null || E.call(v, {
                loaded: y.loaded
              }) : (R = (S = this._fullRequestReader) == null ? void 0 : S.onProgress) == null || R.call(S, {
                loaded: y.loaded,
                total: y.total
              });
            }
            _onProgressiveDone() {
              var y;
              (y = this._fullRequestReader) == null || y.progressiveDone(), this._progressiveDone = !0;
            }
            _removeRangeReader(y) {
              const v = this._rangeReaders.indexOf(y);
              v >= 0 && this._rangeReaders.splice(v, 1);
            }
            getFullReader() {
              (0, d.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
              const y = this._queuedChunks;
              return this._queuedChunks = null, new g(this, y, this._progressiveDone, this._contentDispositionFilename);
            }
            getRangeReader(y, v) {
              if (v <= this._progressiveDataLength)
                return null;
              const E = new $(this, y, v);
              return this._pdfDataRangeTransport.requestDataRange(y, v), this._rangeReaders.push(E), E;
            }
            cancelAllRequests(y) {
              var v;
              (v = this._fullRequestReader) == null || v.cancel(y);
              for (const E of this._rangeReaders.slice(0))
                E.cancel(y);
              this._pdfDataRangeTransport.abort();
            }
          }
          a.PDFDataTransportStream = _;
          class g {
            constructor(y, v, E = !1, S = null) {
              this._stream = y, this._done = E || !1, this._filename = (0, u.isPdfFile)(S) ? S : null, this._queuedChunks = v || [], this._loaded = 0;
              for (const R of this._queuedChunks)
                this._loaded += R.byteLength;
              this._requests = [], this._headersReady = Promise.resolve(), y._fullRequestReader = this, this.onProgress = null;
            }
            _enqueue(y) {
              this._done || (this._requests.length > 0 ? this._requests.shift().resolve({
                value: y,
                done: !1
              }) : this._queuedChunks.push(y), this._loaded += y.byteLength);
            }
            get headersReady() {
              return this._headersReady;
            }
            get filename() {
              return this._filename;
            }
            get isRangeSupported() {
              return this._stream._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._stream._isStreamingSupported;
            }
            get contentLength() {
              return this._stream._contentLength;
            }
            async read() {
              if (this._queuedChunks.length > 0)
                return {
                  value: this._queuedChunks.shift(),
                  done: !1
                };
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const y = new d.PromiseCapability();
              return this._requests.push(y), y.promise;
            }
            cancel(y) {
              this._done = !0;
              for (const v of this._requests)
                v.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0;
            }
            progressiveDone() {
              this._done || (this._done = !0);
            }
          }
          class $ {
            constructor(y, v, E) {
              this._stream = y, this._begin = v, this._end = E, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null;
            }
            _enqueue(y) {
              if (!this._done) {
                if (this._requests.length === 0)
                  this._queuedChunk = y;
                else {
                  this._requests.shift().resolve({
                    value: y,
                    done: !1
                  });
                  for (const E of this._requests)
                    E.resolve({
                      value: void 0,
                      done: !0
                    });
                  this._requests.length = 0;
                }
                this._done = !0, this._stream._removeRangeReader(this);
              }
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              if (this._queuedChunk) {
                const v = this._queuedChunk;
                return this._queuedChunk = null, {
                  value: v,
                  done: !1
                };
              }
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const y = new d.PromiseCapability();
              return this._requests.push(y), y.promise;
            }
            cancel(y) {
              this._done = !0;
              for (const v of this._requests)
                v.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._stream._removeRangeReader(this);
            }
          }
        },
        /* 19 */
        /***/
        (c, a, h) => {
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.PDFFetchStream = void 0;
          var d = h(1), u = h(20);
          function _(E, S, R) {
            return {
              method: "GET",
              headers: E,
              signal: R.signal,
              mode: "cors",
              credentials: S ? "include" : "same-origin",
              redirect: "follow"
            };
          }
          function g(E) {
            const S = new Headers();
            for (const R in E) {
              const x = E[R];
              x !== void 0 && S.append(R, x);
            }
            return S;
          }
          function $(E) {
            return E instanceof Uint8Array ? E.buffer : E instanceof ArrayBuffer ? E : ((0, d.warn)(`getArrayBuffer - unexpected data format: ${E}`), new Uint8Array(E).buffer);
          }
          class b {
            constructor(S) {
              this.source = S, this.isHttp = /^https?:/i.test(S.url), this.httpHeaders = this.isHttp && S.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            get _progressiveDataLength() {
              var S;
              return ((S = this._fullRequestReader) == null ? void 0 : S._loaded) ?? 0;
            }
            getFullReader() {
              return (0, d.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new y(this), this._fullRequestReader;
            }
            getRangeReader(S, R) {
              if (R <= this._progressiveDataLength)
                return null;
              const x = new v(this, S, R);
              return this._rangeRequestReaders.push(x), x;
            }
            cancelAllRequests(S) {
              var R;
              (R = this._fullRequestReader) == null || R.cancel(S);
              for (const x of this._rangeRequestReaders.slice(0))
                x.cancel(S);
            }
          }
          a.PDFFetchStream = b;
          class y {
            constructor(S) {
              this._stream = S, this._reader = null, this._loaded = 0, this._filename = null;
              const R = S.source;
              this._withCredentials = R.withCredentials || !1, this._contentLength = R.length, this._headersCapability = new d.PromiseCapability(), this._disableRange = R.disableRange || !1, this._rangeChunkSize = R.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController(), this._isStreamingSupported = !R.disableStream, this._isRangeSupported = !R.disableRange, this._headers = g(this._stream.httpHeaders);
              const x = R.url;
              fetch(x, _(this._headers, this._withCredentials, this._abortController)).then((H) => {
                if (!(0, u.validateResponseStatus)(H.status))
                  throw (0, u.createResponseStatusError)(H.status, x);
                this._reader = H.body.getReader(), this._headersCapability.resolve();
                const T = (j) => H.headers.get(j), {
                  allowRangeRequests: C,
                  suggestedLength: O
                } = (0, u.validateRangeRequestCapabilities)({
                  getResponseHeader: T,
                  isHttp: this._stream.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                this._isRangeSupported = C, this._contentLength = O || this._contentLength, this._filename = (0, u.extractFilenameFromHeader)(T), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new d.AbortException("Streaming is disabled."));
              }).catch(this._headersCapability.reject), this.onProgress = null;
            }
            get headersReady() {
              return this._headersCapability.promise;
            }
            get filename() {
              return this._filename;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              var x;
              await this._headersCapability.promise;
              const {
                value: S,
                done: R
              } = await this._reader.read();
              return R ? {
                value: S,
                done: R
              } : (this._loaded += S.byteLength, (x = this.onProgress) == null || x.call(this, {
                loaded: this._loaded,
                total: this._contentLength
              }), {
                value: $(S),
                done: !1
              });
            }
            cancel(S) {
              var R;
              (R = this._reader) == null || R.cancel(S), this._abortController.abort();
            }
          }
          class v {
            constructor(S, R, x) {
              this._stream = S, this._reader = null, this._loaded = 0;
              const H = S.source;
              this._withCredentials = H.withCredentials || !1, this._readCapability = new d.PromiseCapability(), this._isStreamingSupported = !H.disableStream, this._abortController = new AbortController(), this._headers = g(this._stream.httpHeaders), this._headers.append("Range", `bytes=${R}-${x - 1}`);
              const T = H.url;
              fetch(T, _(this._headers, this._withCredentials, this._abortController)).then((C) => {
                if (!(0, u.validateResponseStatus)(C.status))
                  throw (0, u.createResponseStatusError)(C.status, T);
                this._readCapability.resolve(), this._reader = C.body.getReader();
              }).catch(this._readCapability.reject), this.onProgress = null;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              var x;
              await this._readCapability.promise;
              const {
                value: S,
                done: R
              } = await this._reader.read();
              return R ? {
                value: S,
                done: R
              } : (this._loaded += S.byteLength, (x = this.onProgress) == null || x.call(this, {
                loaded: this._loaded
              }), {
                value: $(S),
                done: !1
              });
            }
            cancel(S) {
              var R;
              (R = this._reader) == null || R.cancel(S), this._abortController.abort();
            }
          }
        },
        /* 20 */
        /***/
        (c, a, h) => {
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.createResponseStatusError = b, a.extractFilenameFromHeader = $, a.validateRangeRequestCapabilities = g, a.validateResponseStatus = y;
          var d = h(1), u = h(21), _ = h(6);
          function g({
            getResponseHeader: v,
            isHttp: E,
            rangeChunkSize: S,
            disableRange: R
          }) {
            const x = {
              allowRangeRequests: !1,
              suggestedLength: void 0
            }, H = parseInt(v("Content-Length"), 10);
            return !Number.isInteger(H) || (x.suggestedLength = H, H <= 2 * S) || R || !E || v("Accept-Ranges") !== "bytes" || (v("Content-Encoding") || "identity") !== "identity" || (x.allowRangeRequests = !0), x;
          }
          function $(v) {
            const E = v("Content-Disposition");
            if (E) {
              let S = (0, u.getFilenameFromContentDispositionHeader)(E);
              if (S.includes("%"))
                try {
                  S = decodeURIComponent(S);
                } catch {
                }
              if ((0, _.isPdfFile)(S))
                return S;
            }
            return null;
          }
          function b(v, E) {
            return v === 404 || v === 0 && E.startsWith("file:") ? new d.MissingPDFException('Missing PDF "' + E + '".') : new d.UnexpectedResponseException(`Unexpected server response (${v}) while retrieving PDF "${E}".`, v);
          }
          function y(v) {
            return v === 200 || v === 206;
          }
        },
        /* 21 */
        /***/
        (c, a, h) => {
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.getFilenameFromContentDispositionHeader = u;
          var d = h(1);
          function u(_) {
            let g = !0, $ = b("filename\\*", "i").exec(_);
            if ($) {
              $ = $[1];
              let H = S($);
              return H = unescape(H), H = R(H), H = x(H), v(H);
            }
            if ($ = E(_), $) {
              const H = x($);
              return v(H);
            }
            if ($ = b("filename", "i").exec(_), $) {
              $ = $[1];
              let H = S($);
              return H = x(H), v(H);
            }
            function b(H, T) {
              return new RegExp("(?:^|;)\\s*" + H + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', T);
            }
            function y(H, T) {
              if (H) {
                if (!/^[\x00-\xFF]+$/.test(T))
                  return T;
                try {
                  const C = new TextDecoder(H, {
                    fatal: !0
                  }), O = (0, d.stringToBytes)(T);
                  T = C.decode(O), g = !1;
                } catch {
                }
              }
              return T;
            }
            function v(H) {
              return g && /[\x80-\xff]/.test(H) && (H = y("utf-8", H), g && (H = y("iso-8859-1", H))), H;
            }
            function E(H) {
              const T = [];
              let C;
              const O = b("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
              for (; (C = O.exec(H)) !== null; ) {
                let [, B, D, M] = C;
                if (B = parseInt(B, 10), B in T) {
                  if (B === 0)
                    break;
                  continue;
                }
                T[B] = [D, M];
              }
              const j = [];
              for (let B = 0; B < T.length && B in T; ++B) {
                let [D, M] = T[B];
                M = S(M), D && (M = unescape(M), B === 0 && (M = R(M))), j.push(M);
              }
              return j.join("");
            }
            function S(H) {
              if (H.startsWith('"')) {
                const T = H.slice(1).split('\\"');
                for (let C = 0; C < T.length; ++C) {
                  const O = T[C].indexOf('"');
                  O !== -1 && (T[C] = T[C].slice(0, O), T.length = C + 1), T[C] = T[C].replaceAll(/\\(.)/g, "$1");
                }
                H = T.join('"');
              }
              return H;
            }
            function R(H) {
              const T = H.indexOf("'");
              if (T === -1)
                return H;
              const C = H.slice(0, T), j = H.slice(T + 1).replace(/^[^']*'/, "");
              return y(C, j);
            }
            function x(H) {
              return !H.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(H) ? H : H.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(T, C, O, j) {
                if (O === "q" || O === "Q")
                  return j = j.replaceAll("_", " "), j = j.replaceAll(/=([0-9a-fA-F]{2})/g, function(B, D) {
                    return String.fromCharCode(parseInt(D, 16));
                  }), y(C, j);
                try {
                  j = atob(j);
                } catch {
                }
                return y(C, j);
              });
            }
            return "";
          }
        },
        /* 22 */
        /***/
        (c, a, h) => {
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.PDFNetworkStream = void 0;
          var d = h(1), u = h(20);
          const _ = 200, g = 206;
          function $(S) {
            const R = S.response;
            return typeof R != "string" ? R : (0, d.stringToBytes)(R).buffer;
          }
          class b {
            constructor(R, x = {}) {
              this.url = R, this.isHttp = /^https?:/i.test(R), this.httpHeaders = this.isHttp && x.httpHeaders || /* @__PURE__ */ Object.create(null), this.withCredentials = x.withCredentials || !1, this.currXhrId = 0, this.pendingRequests = /* @__PURE__ */ Object.create(null);
            }
            requestRange(R, x, H) {
              const T = {
                begin: R,
                end: x
              };
              for (const C in H)
                T[C] = H[C];
              return this.request(T);
            }
            requestFull(R) {
              return this.request(R);
            }
            request(R) {
              const x = new XMLHttpRequest(), H = this.currXhrId++, T = this.pendingRequests[H] = {
                xhr: x
              };
              x.open("GET", this.url), x.withCredentials = this.withCredentials;
              for (const C in this.httpHeaders) {
                const O = this.httpHeaders[C];
                O !== void 0 && x.setRequestHeader(C, O);
              }
              return this.isHttp && "begin" in R && "end" in R ? (x.setRequestHeader("Range", `bytes=${R.begin}-${R.end - 1}`), T.expectedStatus = g) : T.expectedStatus = _, x.responseType = "arraybuffer", R.onError && (x.onerror = function(C) {
                R.onError(x.status);
              }), x.onreadystatechange = this.onStateChange.bind(this, H), x.onprogress = this.onProgress.bind(this, H), T.onHeadersReceived = R.onHeadersReceived, T.onDone = R.onDone, T.onError = R.onError, T.onProgress = R.onProgress, x.send(null), H;
            }
            onProgress(R, x) {
              var T;
              const H = this.pendingRequests[R];
              H && ((T = H.onProgress) == null || T.call(H, x));
            }
            onStateChange(R, x) {
              var B, D, M;
              const H = this.pendingRequests[R];
              if (!H)
                return;
              const T = H.xhr;
              if (T.readyState >= 2 && H.onHeadersReceived && (H.onHeadersReceived(), delete H.onHeadersReceived), T.readyState !== 4 || !(R in this.pendingRequests))
                return;
              if (delete this.pendingRequests[R], T.status === 0 && this.isHttp) {
                (B = H.onError) == null || B.call(H, T.status);
                return;
              }
              const C = T.status || _;
              if (!(C === _ && H.expectedStatus === g) && C !== H.expectedStatus) {
                (D = H.onError) == null || D.call(H, T.status);
                return;
              }
              const j = $(T);
              if (C === g) {
                const I = T.getResponseHeader("Content-Range"), P = /bytes (\d+)-(\d+)\/(\d+)/.exec(I);
                H.onDone({
                  begin: parseInt(P[1], 10),
                  chunk: j
                });
              } else j ? H.onDone({
                begin: 0,
                chunk: j
              }) : (M = H.onError) == null || M.call(H, T.status);
            }
            getRequestXhr(R) {
              return this.pendingRequests[R].xhr;
            }
            isPendingRequest(R) {
              return R in this.pendingRequests;
            }
            abortRequest(R) {
              const x = this.pendingRequests[R].xhr;
              delete this.pendingRequests[R], x.abort();
            }
          }
          class y {
            constructor(R) {
              this._source = R, this._manager = new b(R.url, {
                httpHeaders: R.httpHeaders,
                withCredentials: R.withCredentials
              }), this._rangeChunkSize = R.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            _onRangeRequestReaderClosed(R) {
              const x = this._rangeRequestReaders.indexOf(R);
              x >= 0 && this._rangeRequestReaders.splice(x, 1);
            }
            getFullReader() {
              return (0, d.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new v(this._manager, this._source), this._fullRequestReader;
            }
            getRangeReader(R, x) {
              const H = new E(this._manager, R, x);
              return H.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(H), H;
            }
            cancelAllRequests(R) {
              var x;
              (x = this._fullRequestReader) == null || x.cancel(R);
              for (const H of this._rangeRequestReaders.slice(0))
                H.cancel(R);
            }
          }
          a.PDFNetworkStream = y;
          class v {
            constructor(R, x) {
              this._manager = R;
              const H = {
                onHeadersReceived: this._onHeadersReceived.bind(this),
                onDone: this._onDone.bind(this),
                onError: this._onError.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._url = x.url, this._fullRequestId = R.requestFull(H), this._headersReceivedCapability = new d.PromiseCapability(), this._disableRange = x.disableRange || !1, this._contentLength = x.length, this._rangeChunkSize = x.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null;
            }
            _onHeadersReceived() {
              const R = this._fullRequestId, x = this._manager.getRequestXhr(R), H = (O) => x.getResponseHeader(O), {
                allowRangeRequests: T,
                suggestedLength: C
              } = (0, u.validateRangeRequestCapabilities)({
                getResponseHeader: H,
                isHttp: this._manager.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange
              });
              T && (this._isRangeSupported = !0), this._contentLength = C || this._contentLength, this._filename = (0, u.extractFilenameFromHeader)(H), this._isRangeSupported && this._manager.abortRequest(R), this._headersReceivedCapability.resolve();
            }
            _onDone(R) {
              if (R && (this._requests.length > 0 ? this._requests.shift().resolve({
                value: R.chunk,
                done: !1
              }) : this._cachedChunks.push(R.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) {
                for (const x of this._requests)
                  x.resolve({
                    value: void 0,
                    done: !0
                  });
                this._requests.length = 0;
              }
            }
            _onError(R) {
              this._storedError = (0, u.createResponseStatusError)(R, this._url), this._headersReceivedCapability.reject(this._storedError);
              for (const x of this._requests)
                x.reject(this._storedError);
              this._requests.length = 0, this._cachedChunks.length = 0;
            }
            _onProgress(R) {
              var x;
              (x = this.onProgress) == null || x.call(this, {
                loaded: R.loaded,
                total: R.lengthComputable ? R.total : this._contentLength
              });
            }
            get filename() {
              return this._filename;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            get contentLength() {
              return this._contentLength;
            }
            get headersReady() {
              return this._headersReceivedCapability.promise;
            }
            async read() {
              if (this._storedError)
                throw this._storedError;
              if (this._cachedChunks.length > 0)
                return {
                  value: this._cachedChunks.shift(),
                  done: !1
                };
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const R = new d.PromiseCapability();
              return this._requests.push(R), R.promise;
            }
            cancel(R) {
              this._done = !0, this._headersReceivedCapability.reject(R);
              for (const x of this._requests)
                x.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null;
            }
          }
          class E {
            constructor(R, x, H) {
              this._manager = R;
              const T = {
                onDone: this._onDone.bind(this),
                onError: this._onError.bind(this),
                onProgress: this._onProgress.bind(this)
              };
              this._url = R.url, this._requestId = R.requestRange(x, H, T), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null;
            }
            _close() {
              var R;
              (R = this.onClosed) == null || R.call(this, this);
            }
            _onDone(R) {
              const x = R.chunk;
              this._requests.length > 0 ? this._requests.shift().resolve({
                value: x,
                done: !1
              }) : this._queuedChunk = x, this._done = !0;
              for (const H of this._requests)
                H.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._close();
            }
            _onError(R) {
              this._storedError = (0, u.createResponseStatusError)(R, this._url);
              for (const x of this._requests)
                x.reject(this._storedError);
              this._requests.length = 0, this._queuedChunk = null;
            }
            _onProgress(R) {
              var x;
              this.isStreamingSupported || (x = this.onProgress) == null || x.call(this, {
                loaded: R.loaded
              });
            }
            get isStreamingSupported() {
              return !1;
            }
            async read() {
              if (this._storedError)
                throw this._storedError;
              if (this._queuedChunk !== null) {
                const x = this._queuedChunk;
                return this._queuedChunk = null, {
                  value: x,
                  done: !1
                };
              }
              if (this._done)
                return {
                  value: void 0,
                  done: !0
                };
              const R = new d.PromiseCapability();
              return this._requests.push(R), R.promise;
            }
            cancel(R) {
              this._done = !0;
              for (const x of this._requests)
                x.resolve({
                  value: void 0,
                  done: !0
                });
              this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close();
            }
          }
        },
        /* 23 */
        /***/
        (c, a, h) => {
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.PDFNodeStream = void 0;
          var d = h(1), u = h(20);
          const _ = /^file:\/\/\/[a-zA-Z]:\//;
          function g(H) {
            const T = require$$5, C = T.parse(H);
            return C.protocol === "file:" || C.host ? C : /^[a-z]:[/\\]/i.test(H) ? T.parse(`file:///${H}`) : (C.host || (C.protocol = "file:"), C);
          }
          class $ {
            constructor(T) {
              this.source = T, this.url = g(T.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && T.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [];
            }
            get _progressiveDataLength() {
              var T;
              return ((T = this._fullRequestReader) == null ? void 0 : T._loaded) ?? 0;
            }
            getFullReader() {
              return (0, d.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new R(this) : new E(this), this._fullRequestReader;
            }
            getRangeReader(T, C) {
              if (C <= this._progressiveDataLength)
                return null;
              const O = this.isFsUrl ? new x(this, T, C) : new S(this, T, C);
              return this._rangeRequestReaders.push(O), O;
            }
            cancelAllRequests(T) {
              var C;
              (C = this._fullRequestReader) == null || C.cancel(T);
              for (const O of this._rangeRequestReaders.slice(0))
                O.cancel(T);
            }
          }
          a.PDFNodeStream = $;
          class b {
            constructor(T) {
              this._url = T.url, this._done = !1, this._storedError = null, this.onProgress = null;
              const C = T.source;
              this._contentLength = C.length, this._loaded = 0, this._filename = null, this._disableRange = C.disableRange || !1, this._rangeChunkSize = C.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !C.disableStream, this._isRangeSupported = !C.disableRange, this._readableStream = null, this._readCapability = new d.PromiseCapability(), this._headersCapability = new d.PromiseCapability();
            }
            get headersReady() {
              return this._headersCapability.promise;
            }
            get filename() {
              return this._filename;
            }
            get contentLength() {
              return this._contentLength;
            }
            get isRangeSupported() {
              return this._isRangeSupported;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              var O;
              if (await this._readCapability.promise, this._done)
                return {
                  value: void 0,
                  done: !0
                };
              if (this._storedError)
                throw this._storedError;
              const T = this._readableStream.read();
              return T === null ? (this._readCapability = new d.PromiseCapability(), this.read()) : (this._loaded += T.length, (O = this.onProgress) == null || O.call(this, {
                loaded: this._loaded,
                total: this._contentLength
              }), {
                value: new Uint8Array(T).buffer,
                done: !1
              });
            }
            cancel(T) {
              if (!this._readableStream) {
                this._error(T);
                return;
              }
              this._readableStream.destroy(T);
            }
            _error(T) {
              this._storedError = T, this._readCapability.resolve();
            }
            _setReadableStream(T) {
              this._readableStream = T, T.on("readable", () => {
                this._readCapability.resolve();
              }), T.on("end", () => {
                T.destroy(), this._done = !0, this._readCapability.resolve();
              }), T.on("error", (C) => {
                this._error(C);
              }), !this._isStreamingSupported && this._isRangeSupported && this._error(new d.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError);
            }
          }
          class y {
            constructor(T) {
              this._url = T.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = new d.PromiseCapability();
              const C = T.source;
              this._isStreamingSupported = !C.disableStream;
            }
            get isStreamingSupported() {
              return this._isStreamingSupported;
            }
            async read() {
              var O;
              if (await this._readCapability.promise, this._done)
                return {
                  value: void 0,
                  done: !0
                };
              if (this._storedError)
                throw this._storedError;
              const T = this._readableStream.read();
              return T === null ? (this._readCapability = new d.PromiseCapability(), this.read()) : (this._loaded += T.length, (O = this.onProgress) == null || O.call(this, {
                loaded: this._loaded
              }), {
                value: new Uint8Array(T).buffer,
                done: !1
              });
            }
            cancel(T) {
              if (!this._readableStream) {
                this._error(T);
                return;
              }
              this._readableStream.destroy(T);
            }
            _error(T) {
              this._storedError = T, this._readCapability.resolve();
            }
            _setReadableStream(T) {
              this._readableStream = T, T.on("readable", () => {
                this._readCapability.resolve();
              }), T.on("end", () => {
                T.destroy(), this._done = !0, this._readCapability.resolve();
              }), T.on("error", (C) => {
                this._error(C);
              }), this._storedError && this._readableStream.destroy(this._storedError);
            }
          }
          function v(H, T) {
            return {
              protocol: H.protocol,
              auth: H.auth,
              host: H.hostname,
              port: H.port,
              path: H.path,
              method: "GET",
              headers: T
            };
          }
          class E extends b {
            constructor(T) {
              super(T);
              const C = (O) => {
                if (O.statusCode === 404) {
                  const M = new d.MissingPDFException(`Missing PDF "${this._url}".`);
                  this._storedError = M, this._headersCapability.reject(M);
                  return;
                }
                this._headersCapability.resolve(), this._setReadableStream(O);
                const j = (M) => this._readableStream.headers[M.toLowerCase()], {
                  allowRangeRequests: B,
                  suggestedLength: D
                } = (0, u.validateRangeRequestCapabilities)({
                  getResponseHeader: j,
                  isHttp: T.isHttp,
                  rangeChunkSize: this._rangeChunkSize,
                  disableRange: this._disableRange
                });
                this._isRangeSupported = B, this._contentLength = D || this._contentLength, this._filename = (0, u.extractFilenameFromHeader)(j);
              };
              if (this._request = null, this._url.protocol === "http:") {
                const O = require$$5;
                this._request = O.request(v(this._url, T.httpHeaders), C);
              } else {
                const O = require$$5;
                this._request = O.request(v(this._url, T.httpHeaders), C);
              }
              this._request.on("error", (O) => {
                this._storedError = O, this._headersCapability.reject(O);
              }), this._request.end();
            }
          }
          class S extends y {
            constructor(T, C, O) {
              super(T), this._httpHeaders = {};
              for (const B in T.httpHeaders) {
                const D = T.httpHeaders[B];
                D !== void 0 && (this._httpHeaders[B] = D);
              }
              this._httpHeaders.Range = `bytes=${C}-${O - 1}`;
              const j = (B) => {
                if (B.statusCode === 404) {
                  const D = new d.MissingPDFException(`Missing PDF "${this._url}".`);
                  this._storedError = D;
                  return;
                }
                this._setReadableStream(B);
              };
              if (this._request = null, this._url.protocol === "http:") {
                const B = require$$5;
                this._request = B.request(v(this._url, this._httpHeaders), j);
              } else {
                const B = require$$5;
                this._request = B.request(v(this._url, this._httpHeaders), j);
              }
              this._request.on("error", (B) => {
                this._storedError = B;
              }), this._request.end();
            }
          }
          class R extends b {
            constructor(T) {
              super(T);
              let C = decodeURIComponent(this._url.path);
              _.test(this._url.href) && (C = C.replace(/^\//, ""));
              const O = require$$5;
              O.lstat(C, (j, B) => {
                if (j) {
                  j.code === "ENOENT" && (j = new d.MissingPDFException(`Missing PDF "${C}".`)), this._storedError = j, this._headersCapability.reject(j);
                  return;
                }
                this._contentLength = B.size, this._setReadableStream(O.createReadStream(C)), this._headersCapability.resolve();
              });
            }
          }
          class x extends y {
            constructor(T, C, O) {
              super(T);
              let j = decodeURIComponent(this._url.path);
              _.test(this._url.href) && (j = j.replace(/^\//, ""));
              const B = require$$5;
              this._setReadableStream(B.createReadStream(j, {
                start: C,
                end: O - 1
              }));
            }
          }
        },
        /* 24 */
        /***/
        (c, a, h) => {
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.SVGGraphics = void 0;
          var d = h(6), u = h(1);
          const _ = {
            fontStyle: "normal",
            fontWeight: "normal",
            fillColor: "#000000"
          }, g = "http://www.w3.org/XML/1998/namespace", $ = "http://www.w3.org/1999/xlink", b = ["butt", "round", "square"], y = ["miter", "round", "bevel"], v = function(B, D = "", M = !1) {
            if (URL.createObjectURL && typeof Blob < "u" && !M)
              return URL.createObjectURL(new Blob([B], {
                type: D
              }));
            const I = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            let P = `data:${D};base64,`;
            for (let L = 0, Y = B.length; L < Y; L += 3) {
              const N = B[L] & 255, W = B[L + 1] & 255, V = B[L + 2] & 255, ue = N >> 2, se = (N & 3) << 4 | W >> 4, ce = L + 1 < Y ? (W & 15) << 2 | V >> 6 : 64, oe = L + 2 < Y ? V & 63 : 64;
              P += I[ue] + I[se] + I[ce] + I[oe];
            }
            return P;
          }, E = function() {
            const B = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]), D = 12, M = new Int32Array(256);
            for (let V = 0; V < 256; V++) {
              let ue = V;
              for (let se = 0; se < 8; se++)
                ue = ue & 1 ? 3988292384 ^ ue >> 1 & 2147483647 : ue >> 1 & 2147483647;
              M[V] = ue;
            }
            function I(V, ue, se) {
              let ce = -1;
              for (let oe = ue; oe < se; oe++) {
                const ge = (ce ^ V[oe]) & 255, J = M[ge];
                ce = ce >>> 8 ^ J;
              }
              return ce ^ -1;
            }
            function P(V, ue, se, ce) {
              let oe = ce;
              const ge = ue.length;
              se[oe] = ge >> 24 & 255, se[oe + 1] = ge >> 16 & 255, se[oe + 2] = ge >> 8 & 255, se[oe + 3] = ge & 255, oe += 4, se[oe] = V.charCodeAt(0) & 255, se[oe + 1] = V.charCodeAt(1) & 255, se[oe + 2] = V.charCodeAt(2) & 255, se[oe + 3] = V.charCodeAt(3) & 255, oe += 4, se.set(ue, oe), oe += ue.length;
              const J = I(se, ce + 4, oe);
              se[oe] = J >> 24 & 255, se[oe + 1] = J >> 16 & 255, se[oe + 2] = J >> 8 & 255, se[oe + 3] = J & 255;
            }
            function L(V, ue, se) {
              let ce = 1, oe = 0;
              for (let ge = ue; ge < se; ++ge)
                ce = (ce + (V[ge] & 255)) % 65521, oe = (oe + ce) % 65521;
              return oe << 16 | ce;
            }
            function Y(V) {
              if (!u.isNodeJS)
                return N(V);
              try {
                const ue = parseInt(process.versions.node) >= 8 ? V : Buffer.from(V), se = require$$5.deflateSync(ue, {
                  level: 9
                });
                return se instanceof Uint8Array ? se : new Uint8Array(se);
              } catch (ue) {
                (0, u.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + ue);
              }
              return N(V);
            }
            function N(V) {
              let ue = V.length;
              const se = 65535, ce = Math.ceil(ue / se), oe = new Uint8Array(2 + ue + ce * 5 + 4);
              let ge = 0;
              oe[ge++] = 120, oe[ge++] = 156;
              let J = 0;
              for (; ue > se; )
                oe[ge++] = 0, oe[ge++] = 255, oe[ge++] = 255, oe[ge++] = 0, oe[ge++] = 0, oe.set(V.subarray(J, J + se), ge), ge += se, J += se, ue -= se;
              oe[ge++] = 1, oe[ge++] = ue & 255, oe[ge++] = ue >> 8 & 255, oe[ge++] = ~ue & 65535 & 255, oe[ge++] = (~ue & 65535) >> 8 & 255, oe.set(V.subarray(J), ge), ge += V.length - J;
              const ae = L(V, 0, V.length);
              return oe[ge++] = ae >> 24 & 255, oe[ge++] = ae >> 16 & 255, oe[ge++] = ae >> 8 & 255, oe[ge++] = ae & 255, oe;
            }
            function W(V, ue, se, ce) {
              const oe = V.width, ge = V.height;
              let J, ae, le;
              const z = V.data;
              switch (ue) {
                case u.ImageKind.GRAYSCALE_1BPP:
                  ae = 0, J = 1, le = oe + 7 >> 3;
                  break;
                case u.ImageKind.RGB_24BPP:
                  ae = 2, J = 8, le = oe * 3;
                  break;
                case u.ImageKind.RGBA_32BPP:
                  ae = 6, J = 8, le = oe * 4;
                  break;
                default:
                  throw new Error("invalid format");
              }
              const A = new Uint8Array((1 + le) * ge);
              let F = 0, U = 0;
              for (let Te = 0; Te < ge; ++Te)
                A[F++] = 0, A.set(z.subarray(U, U + le), F), U += le, F += le;
              if (ue === u.ImageKind.GRAYSCALE_1BPP && ce) {
                F = 0;
                for (let Te = 0; Te < ge; Te++) {
                  F++;
                  for (let Pe = 0; Pe < le; Pe++)
                    A[F++] ^= 255;
                }
              }
              const Z = new Uint8Array([oe >> 24 & 255, oe >> 16 & 255, oe >> 8 & 255, oe & 255, ge >> 24 & 255, ge >> 16 & 255, ge >> 8 & 255, ge & 255, J, ae, 0, 0, 0]), G = Y(A), Q = B.length + D * 3 + Z.length + G.length, he = new Uint8Array(Q);
              let me = 0;
              return he.set(B, me), me += B.length, P("IHDR", Z, he, me), me += D + Z.length, P("IDATA", G, he, me), me += D + G.length, P("IEND", new Uint8Array(0), he, me), v(he, "image/png", se);
            }
            return function(ue, se, ce) {
              const oe = ue.kind === void 0 ? u.ImageKind.GRAYSCALE_1BPP : ue.kind;
              return W(ue, oe, se, ce);
            };
          }();
          class S {
            constructor() {
              this.fontSizeScale = 1, this.fontWeight = _.fontWeight, this.fontSize = 0, this.textMatrix = u.IDENTITY_MATRIX, this.fontMatrix = u.FONT_IDENTITY_MATRIX, this.leading = 0, this.textRenderingMode = u.TextRenderingMode.FILL, this.textMatrixScale = 1, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRise = 0, this.fillColor = _.fillColor, this.strokeColor = "#000000", this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.lineJoin = "", this.lineCap = "", this.miterLimit = 0, this.dashArray = [], this.dashPhase = 0, this.dependencies = [], this.activeClipUrl = null, this.clipGroup = null, this.maskId = "";
            }
            clone() {
              return Object.create(this);
            }
            setCurrentPoint(D, M) {
              this.x = D, this.y = M;
            }
          }
          function R(B) {
            let D = [];
            const M = [];
            for (const I of B) {
              if (I.fn === "save") {
                D.push({
                  fnId: 92,
                  fn: "group",
                  items: []
                }), M.push(D), D = D.at(-1).items;
                continue;
              }
              I.fn === "restore" ? D = M.pop() : D.push(I);
            }
            return D;
          }
          function x(B) {
            if (Number.isInteger(B))
              return B.toString();
            const D = B.toFixed(10);
            let M = D.length - 1;
            if (D[M] !== "0")
              return D;
            do
              M--;
            while (D[M] === "0");
            return D.substring(0, D[M] === "." ? M : M + 1);
          }
          function H(B) {
            if (B[4] === 0 && B[5] === 0) {
              if (B[1] === 0 && B[2] === 0)
                return B[0] === 1 && B[3] === 1 ? "" : `scale(${x(B[0])} ${x(B[3])})`;
              if (B[0] === B[3] && B[1] === -B[2]) {
                const D = Math.acos(B[0]) * 180 / Math.PI;
                return `rotate(${x(D)})`;
              }
            } else if (B[0] === 1 && B[1] === 0 && B[2] === 0 && B[3] === 1)
              return `translate(${x(B[4])} ${x(B[5])})`;
            return `matrix(${x(B[0])} ${x(B[1])} ${x(B[2])} ${x(B[3])} ${x(B[4])} ${x(B[5])})`;
          }
          let T = 0, C = 0, O = 0;
          class j {
            constructor(D, M, I = !1) {
              (0, d.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future."), this.svgFactory = new d.DOMSVGFactory(), this.current = new S(), this.transformMatrix = u.IDENTITY_MATRIX, this.transformStack = [], this.extraStack = [], this.commonObjs = D, this.objs = M, this.pendingClip = null, this.pendingEOFill = !1, this.embedFonts = !1, this.embeddedFonts = /* @__PURE__ */ Object.create(null), this.cssStyle = null, this.forceDataSchema = !!I, this._operatorIdMapping = [];
              for (const P in u.OPS)
                this._operatorIdMapping[u.OPS[P]] = P;
            }
            getObject(D, M = null) {
              return typeof D == "string" ? D.startsWith("g_") ? this.commonObjs.get(D) : this.objs.get(D) : M;
            }
            save() {
              this.transformStack.push(this.transformMatrix);
              const D = this.current;
              this.extraStack.push(D), this.current = D.clone();
            }
            restore() {
              this.transformMatrix = this.transformStack.pop(), this.current = this.extraStack.pop(), this.pendingClip = null, this.tgrp = null;
            }
            group(D) {
              this.save(), this.executeOpTree(D), this.restore();
            }
            loadDependencies(D) {
              const M = D.fnArray, I = D.argsArray;
              for (let P = 0, L = M.length; P < L; P++)
                if (M[P] === u.OPS.dependency)
                  for (const Y of I[P]) {
                    const N = Y.startsWith("g_") ? this.commonObjs : this.objs, W = new Promise((V) => {
                      N.get(Y, V);
                    });
                    this.current.dependencies.push(W);
                  }
              return Promise.all(this.current.dependencies);
            }
            transform(D, M, I, P, L, Y) {
              const N = [D, M, I, P, L, Y];
              this.transformMatrix = u.Util.transform(this.transformMatrix, N), this.tgrp = null;
            }
            getSVG(D, M) {
              this.viewport = M;
              const I = this._initialize(M);
              return this.loadDependencies(D).then(() => (this.transformMatrix = u.IDENTITY_MATRIX, this.executeOpTree(this.convertOpList(D)), I));
            }
            convertOpList(D) {
              const M = this._operatorIdMapping, I = D.argsArray, P = D.fnArray, L = [];
              for (let Y = 0, N = P.length; Y < N; Y++) {
                const W = P[Y];
                L.push({
                  fnId: W,
                  fn: M[W],
                  args: I[Y]
                });
              }
              return R(L);
            }
            executeOpTree(D) {
              for (const M of D) {
                const I = M.fn, P = M.fnId, L = M.args;
                switch (P | 0) {
                  case u.OPS.beginText:
                    this.beginText();
                    break;
                  case u.OPS.dependency:
                    break;
                  case u.OPS.setLeading:
                    this.setLeading(L);
                    break;
                  case u.OPS.setLeadingMoveText:
                    this.setLeadingMoveText(L[0], L[1]);
                    break;
                  case u.OPS.setFont:
                    this.setFont(L);
                    break;
                  case u.OPS.showText:
                    this.showText(L[0]);
                    break;
                  case u.OPS.showSpacedText:
                    this.showText(L[0]);
                    break;
                  case u.OPS.endText:
                    this.endText();
                    break;
                  case u.OPS.moveText:
                    this.moveText(L[0], L[1]);
                    break;
                  case u.OPS.setCharSpacing:
                    this.setCharSpacing(L[0]);
                    break;
                  case u.OPS.setWordSpacing:
                    this.setWordSpacing(L[0]);
                    break;
                  case u.OPS.setHScale:
                    this.setHScale(L[0]);
                    break;
                  case u.OPS.setTextMatrix:
                    this.setTextMatrix(L[0], L[1], L[2], L[3], L[4], L[5]);
                    break;
                  case u.OPS.setTextRise:
                    this.setTextRise(L[0]);
                    break;
                  case u.OPS.setTextRenderingMode:
                    this.setTextRenderingMode(L[0]);
                    break;
                  case u.OPS.setLineWidth:
                    this.setLineWidth(L[0]);
                    break;
                  case u.OPS.setLineJoin:
                    this.setLineJoin(L[0]);
                    break;
                  case u.OPS.setLineCap:
                    this.setLineCap(L[0]);
                    break;
                  case u.OPS.setMiterLimit:
                    this.setMiterLimit(L[0]);
                    break;
                  case u.OPS.setFillRGBColor:
                    this.setFillRGBColor(L[0], L[1], L[2]);
                    break;
                  case u.OPS.setStrokeRGBColor:
                    this.setStrokeRGBColor(L[0], L[1], L[2]);
                    break;
                  case u.OPS.setStrokeColorN:
                    this.setStrokeColorN(L);
                    break;
                  case u.OPS.setFillColorN:
                    this.setFillColorN(L);
                    break;
                  case u.OPS.shadingFill:
                    this.shadingFill(L[0]);
                    break;
                  case u.OPS.setDash:
                    this.setDash(L[0], L[1]);
                    break;
                  case u.OPS.setRenderingIntent:
                    this.setRenderingIntent(L[0]);
                    break;
                  case u.OPS.setFlatness:
                    this.setFlatness(L[0]);
                    break;
                  case u.OPS.setGState:
                    this.setGState(L[0]);
                    break;
                  case u.OPS.fill:
                    this.fill();
                    break;
                  case u.OPS.eoFill:
                    this.eoFill();
                    break;
                  case u.OPS.stroke:
                    this.stroke();
                    break;
                  case u.OPS.fillStroke:
                    this.fillStroke();
                    break;
                  case u.OPS.eoFillStroke:
                    this.eoFillStroke();
                    break;
                  case u.OPS.clip:
                    this.clip("nonzero");
                    break;
                  case u.OPS.eoClip:
                    this.clip("evenodd");
                    break;
                  case u.OPS.paintSolidColorImageMask:
                    this.paintSolidColorImageMask();
                    break;
                  case u.OPS.paintImageXObject:
                    this.paintImageXObject(L[0]);
                    break;
                  case u.OPS.paintInlineImageXObject:
                    this.paintInlineImageXObject(L[0]);
                    break;
                  case u.OPS.paintImageMaskXObject:
                    this.paintImageMaskXObject(L[0]);
                    break;
                  case u.OPS.paintFormXObjectBegin:
                    this.paintFormXObjectBegin(L[0], L[1]);
                    break;
                  case u.OPS.paintFormXObjectEnd:
                    this.paintFormXObjectEnd();
                    break;
                  case u.OPS.closePath:
                    this.closePath();
                    break;
                  case u.OPS.closeStroke:
                    this.closeStroke();
                    break;
                  case u.OPS.closeFillStroke:
                    this.closeFillStroke();
                    break;
                  case u.OPS.closeEOFillStroke:
                    this.closeEOFillStroke();
                    break;
                  case u.OPS.nextLine:
                    this.nextLine();
                    break;
                  case u.OPS.transform:
                    this.transform(L[0], L[1], L[2], L[3], L[4], L[5]);
                    break;
                  case u.OPS.constructPath:
                    this.constructPath(L[0], L[1]);
                    break;
                  case u.OPS.endPath:
                    this.endPath();
                    break;
                  case 92:
                    this.group(M.items);
                    break;
                  default:
                    (0, u.warn)(`Unimplemented operator ${I}`);
                    break;
                }
              }
            }
            setWordSpacing(D) {
              this.current.wordSpacing = D;
            }
            setCharSpacing(D) {
              this.current.charSpacing = D;
            }
            nextLine() {
              this.moveText(0, this.current.leading);
            }
            setTextMatrix(D, M, I, P, L, Y) {
              const N = this.current;
              N.textMatrix = N.lineMatrix = [D, M, I, P, L, Y], N.textMatrixScale = Math.hypot(D, M), N.x = N.lineX = 0, N.y = N.lineY = 0, N.xcoords = [], N.ycoords = [], N.tspan = this.svgFactory.createElement("svg:tspan"), N.tspan.setAttributeNS(null, "font-family", N.fontFamily), N.tspan.setAttributeNS(null, "font-size", `${x(N.fontSize)}px`), N.tspan.setAttributeNS(null, "y", x(-N.y)), N.txtElement = this.svgFactory.createElement("svg:text"), N.txtElement.append(N.tspan);
            }
            beginText() {
              const D = this.current;
              D.x = D.lineX = 0, D.y = D.lineY = 0, D.textMatrix = u.IDENTITY_MATRIX, D.lineMatrix = u.IDENTITY_MATRIX, D.textMatrixScale = 1, D.tspan = this.svgFactory.createElement("svg:tspan"), D.txtElement = this.svgFactory.createElement("svg:text"), D.txtgrp = this.svgFactory.createElement("svg:g"), D.xcoords = [], D.ycoords = [];
            }
            moveText(D, M) {
              const I = this.current;
              I.x = I.lineX += D, I.y = I.lineY += M, I.xcoords = [], I.ycoords = [], I.tspan = this.svgFactory.createElement("svg:tspan"), I.tspan.setAttributeNS(null, "font-family", I.fontFamily), I.tspan.setAttributeNS(null, "font-size", `${x(I.fontSize)}px`), I.tspan.setAttributeNS(null, "y", x(-I.y));
            }
            showText(D) {
              const M = this.current, I = M.font, P = M.fontSize;
              if (P === 0)
                return;
              const L = M.fontSizeScale, Y = M.charSpacing, N = M.wordSpacing, W = M.fontDirection, V = M.textHScale * W, ue = I.vertical, se = ue ? 1 : -1, ce = I.defaultVMetrics, oe = P * M.fontMatrix[0];
              let ge = 0;
              for (const le of D) {
                if (le === null) {
                  ge += W * N;
                  continue;
                } else if (typeof le == "number") {
                  ge += se * le * P / 1e3;
                  continue;
                }
                const z = (le.isSpace ? N : 0) + Y, A = le.fontChar;
                let F, U, Z = le.width;
                if (ue) {
                  let Q;
                  const he = le.vmetric || ce;
                  Q = le.vmetric ? he[1] : Z * 0.5, Q = -Q * oe;
                  const me = he[2] * oe;
                  Z = he ? -he[0] : Z, F = Q / L, U = (ge + me) / L;
                } else
                  F = ge / L, U = 0;
                (le.isInFont || I.missingFile) && (M.xcoords.push(M.x + F), ue && M.ycoords.push(-M.y + U), M.tspan.textContent += A);
                const G = ue ? Z * oe - z * W : Z * oe + z * W;
                ge += G;
              }
              M.tspan.setAttributeNS(null, "x", M.xcoords.map(x).join(" ")), ue ? M.tspan.setAttributeNS(null, "y", M.ycoords.map(x).join(" ")) : M.tspan.setAttributeNS(null, "y", x(-M.y)), ue ? M.y -= ge : M.x += ge * V, M.tspan.setAttributeNS(null, "font-family", M.fontFamily), M.tspan.setAttributeNS(null, "font-size", `${x(M.fontSize)}px`), M.fontStyle !== _.fontStyle && M.tspan.setAttributeNS(null, "font-style", M.fontStyle), M.fontWeight !== _.fontWeight && M.tspan.setAttributeNS(null, "font-weight", M.fontWeight);
              const J = M.textRenderingMode & u.TextRenderingMode.FILL_STROKE_MASK;
              if (J === u.TextRenderingMode.FILL || J === u.TextRenderingMode.FILL_STROKE ? (M.fillColor !== _.fillColor && M.tspan.setAttributeNS(null, "fill", M.fillColor), M.fillAlpha < 1 && M.tspan.setAttributeNS(null, "fill-opacity", M.fillAlpha)) : M.textRenderingMode === u.TextRenderingMode.ADD_TO_PATH ? M.tspan.setAttributeNS(null, "fill", "transparent") : M.tspan.setAttributeNS(null, "fill", "none"), J === u.TextRenderingMode.STROKE || J === u.TextRenderingMode.FILL_STROKE) {
                const le = 1 / (M.textMatrixScale || 1);
                this._setStrokeAttributes(M.tspan, le);
              }
              let ae = M.textMatrix;
              M.textRise !== 0 && (ae = ae.slice(), ae[5] += M.textRise), M.txtElement.setAttributeNS(null, "transform", `${H(ae)} scale(${x(V)}, -1)`), M.txtElement.setAttributeNS(g, "xml:space", "preserve"), M.txtElement.append(M.tspan), M.txtgrp.append(M.txtElement), this._ensureTransformGroup().append(M.txtElement);
            }
            setLeadingMoveText(D, M) {
              this.setLeading(-M), this.moveText(D, M);
            }
            addFontStyle(D) {
              if (!D.data)
                throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.');
              this.cssStyle || (this.cssStyle = this.svgFactory.createElement("svg:style"), this.cssStyle.setAttributeNS(null, "type", "text/css"), this.defs.append(this.cssStyle));
              const M = v(D.data, D.mimetype, this.forceDataSchema);
              this.cssStyle.textContent += `@font-face { font-family: "${D.loadedName}"; src: url(${M}); }
`;
            }
            setFont(D) {
              const M = this.current, I = this.commonObjs.get(D[0]);
              let P = D[1];
              M.font = I, this.embedFonts && !I.missingFile && !this.embeddedFonts[I.loadedName] && (this.addFontStyle(I), this.embeddedFonts[I.loadedName] = I), M.fontMatrix = I.fontMatrix || u.FONT_IDENTITY_MATRIX;
              let L = "normal";
              I.black ? L = "900" : I.bold && (L = "bold");
              const Y = I.italic ? "italic" : "normal";
              P < 0 ? (P = -P, M.fontDirection = -1) : M.fontDirection = 1, M.fontSize = P, M.fontFamily = I.loadedName, M.fontWeight = L, M.fontStyle = Y, M.tspan = this.svgFactory.createElement("svg:tspan"), M.tspan.setAttributeNS(null, "y", x(-M.y)), M.xcoords = [], M.ycoords = [];
            }
            endText() {
              var M;
              const D = this.current;
              D.textRenderingMode & u.TextRenderingMode.ADD_TO_PATH_FLAG && ((M = D.txtElement) != null && M.hasChildNodes()) && (D.element = D.txtElement, this.clip("nonzero"), this.endPath());
            }
            setLineWidth(D) {
              D > 0 && (this.current.lineWidth = D);
            }
            setLineCap(D) {
              this.current.lineCap = b[D];
            }
            setLineJoin(D) {
              this.current.lineJoin = y[D];
            }
            setMiterLimit(D) {
              this.current.miterLimit = D;
            }
            setStrokeAlpha(D) {
              this.current.strokeAlpha = D;
            }
            setStrokeRGBColor(D, M, I) {
              this.current.strokeColor = u.Util.makeHexColor(D, M, I);
            }
            setFillAlpha(D) {
              this.current.fillAlpha = D;
            }
            setFillRGBColor(D, M, I) {
              this.current.fillColor = u.Util.makeHexColor(D, M, I), this.current.tspan = this.svgFactory.createElement("svg:tspan"), this.current.xcoords = [], this.current.ycoords = [];
            }
            setStrokeColorN(D) {
              this.current.strokeColor = this._makeColorN_Pattern(D);
            }
            setFillColorN(D) {
              this.current.fillColor = this._makeColorN_Pattern(D);
            }
            shadingFill(D) {
              const {
                width: M,
                height: I
              } = this.viewport, P = u.Util.inverseTransform(this.transformMatrix), [L, Y, N, W] = u.Util.getAxialAlignedBoundingBox([0, 0, M, I], P), V = this.svgFactory.createElement("svg:rect");
              V.setAttributeNS(null, "x", L), V.setAttributeNS(null, "y", Y), V.setAttributeNS(null, "width", N - L), V.setAttributeNS(null, "height", W - Y), V.setAttributeNS(null, "fill", this._makeShadingPattern(D)), this.current.fillAlpha < 1 && V.setAttributeNS(null, "fill-opacity", this.current.fillAlpha), this._ensureTransformGroup().append(V);
            }
            _makeColorN_Pattern(D) {
              return D[0] === "TilingPattern" ? this._makeTilingPattern(D) : this._makeShadingPattern(D);
            }
            _makeTilingPattern(D) {
              const M = D[1], I = D[2], P = D[3] || u.IDENTITY_MATRIX, [L, Y, N, W] = D[4], V = D[5], ue = D[6], se = D[7], ce = `shading${O++}`, [oe, ge, J, ae] = u.Util.normalizeRect([...u.Util.applyTransform([L, Y], P), ...u.Util.applyTransform([N, W], P)]), [le, z] = u.Util.singularValueDecompose2dScale(P), A = V * le, F = ue * z, U = this.svgFactory.createElement("svg:pattern");
              U.setAttributeNS(null, "id", ce), U.setAttributeNS(null, "patternUnits", "userSpaceOnUse"), U.setAttributeNS(null, "width", A), U.setAttributeNS(null, "height", F), U.setAttributeNS(null, "x", `${oe}`), U.setAttributeNS(null, "y", `${ge}`);
              const Z = this.svg, G = this.transformMatrix, Q = this.current.fillColor, he = this.current.strokeColor, me = this.svgFactory.create(J - oe, ae - ge);
              if (this.svg = me, this.transformMatrix = P, se === 2) {
                const Te = u.Util.makeHexColor(...M);
                this.current.fillColor = Te, this.current.strokeColor = Te;
              }
              return this.executeOpTree(this.convertOpList(I)), this.svg = Z, this.transformMatrix = G, this.current.fillColor = Q, this.current.strokeColor = he, U.append(me.childNodes[0]), this.defs.append(U), `url(#${ce})`;
            }
            _makeShadingPattern(D) {
              switch (typeof D == "string" && (D = this.objs.get(D)), D[0]) {
                case "RadialAxial":
                  const M = `shading${O++}`, I = D[3];
                  let P;
                  switch (D[1]) {
                    case "axial":
                      const L = D[4], Y = D[5];
                      P = this.svgFactory.createElement("svg:linearGradient"), P.setAttributeNS(null, "id", M), P.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), P.setAttributeNS(null, "x1", L[0]), P.setAttributeNS(null, "y1", L[1]), P.setAttributeNS(null, "x2", Y[0]), P.setAttributeNS(null, "y2", Y[1]);
                      break;
                    case "radial":
                      const N = D[4], W = D[5], V = D[6], ue = D[7];
                      P = this.svgFactory.createElement("svg:radialGradient"), P.setAttributeNS(null, "id", M), P.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), P.setAttributeNS(null, "cx", W[0]), P.setAttributeNS(null, "cy", W[1]), P.setAttributeNS(null, "r", ue), P.setAttributeNS(null, "fx", N[0]), P.setAttributeNS(null, "fy", N[1]), P.setAttributeNS(null, "fr", V);
                      break;
                    default:
                      throw new Error(`Unknown RadialAxial type: ${D[1]}`);
                  }
                  for (const L of I) {
                    const Y = this.svgFactory.createElement("svg:stop");
                    Y.setAttributeNS(null, "offset", L[0]), Y.setAttributeNS(null, "stop-color", L[1]), P.append(Y);
                  }
                  return this.defs.append(P), `url(#${M})`;
                case "Mesh":
                  return (0, u.warn)("Unimplemented pattern Mesh"), null;
                case "Dummy":
                  return "hotpink";
                default:
                  throw new Error(`Unknown IR type: ${D[0]}`);
              }
            }
            setDash(D, M) {
              this.current.dashArray = D, this.current.dashPhase = M;
            }
            constructPath(D, M) {
              const I = this.current;
              let P = I.x, L = I.y, Y = [], N = 0;
              for (const W of D)
                switch (W | 0) {
                  case u.OPS.rectangle:
                    P = M[N++], L = M[N++];
                    const V = M[N++], ue = M[N++], se = P + V, ce = L + ue;
                    Y.push("M", x(P), x(L), "L", x(se), x(L), "L", x(se), x(ce), "L", x(P), x(ce), "Z");
                    break;
                  case u.OPS.moveTo:
                    P = M[N++], L = M[N++], Y.push("M", x(P), x(L));
                    break;
                  case u.OPS.lineTo:
                    P = M[N++], L = M[N++], Y.push("L", x(P), x(L));
                    break;
                  case u.OPS.curveTo:
                    P = M[N + 4], L = M[N + 5], Y.push("C", x(M[N]), x(M[N + 1]), x(M[N + 2]), x(M[N + 3]), x(P), x(L)), N += 6;
                    break;
                  case u.OPS.curveTo2:
                    Y.push("C", x(P), x(L), x(M[N]), x(M[N + 1]), x(M[N + 2]), x(M[N + 3])), P = M[N + 2], L = M[N + 3], N += 4;
                    break;
                  case u.OPS.curveTo3:
                    P = M[N + 2], L = M[N + 3], Y.push("C", x(M[N]), x(M[N + 1]), x(P), x(L), x(P), x(L)), N += 4;
                    break;
                  case u.OPS.closePath:
                    Y.push("Z");
                    break;
                }
              Y = Y.join(" "), I.path && D.length > 0 && D[0] !== u.OPS.rectangle && D[0] !== u.OPS.moveTo ? Y = I.path.getAttributeNS(null, "d") + Y : (I.path = this.svgFactory.createElement("svg:path"), this._ensureTransformGroup().append(I.path)), I.path.setAttributeNS(null, "d", Y), I.path.setAttributeNS(null, "fill", "none"), I.element = I.path, I.setCurrentPoint(P, L);
            }
            endPath() {
              const D = this.current;
              if (D.path = null, !this.pendingClip)
                return;
              if (!D.element) {
                this.pendingClip = null;
                return;
              }
              const M = `clippath${T++}`, I = this.svgFactory.createElement("svg:clipPath");
              I.setAttributeNS(null, "id", M), I.setAttributeNS(null, "transform", H(this.transformMatrix));
              const P = D.element.cloneNode(!0);
              if (this.pendingClip === "evenodd" ? P.setAttributeNS(null, "clip-rule", "evenodd") : P.setAttributeNS(null, "clip-rule", "nonzero"), this.pendingClip = null, I.append(P), this.defs.append(I), D.activeClipUrl) {
                D.clipGroup = null;
                for (const L of this.extraStack)
                  L.clipGroup = null;
                I.setAttributeNS(null, "clip-path", D.activeClipUrl);
              }
              D.activeClipUrl = `url(#${M})`, this.tgrp = null;
            }
            clip(D) {
              this.pendingClip = D;
            }
            closePath() {
              const D = this.current;
              if (D.path) {
                const M = `${D.path.getAttributeNS(null, "d")}Z`;
                D.path.setAttributeNS(null, "d", M);
              }
            }
            setLeading(D) {
              this.current.leading = -D;
            }
            setTextRise(D) {
              this.current.textRise = D;
            }
            setTextRenderingMode(D) {
              this.current.textRenderingMode = D;
            }
            setHScale(D) {
              this.current.textHScale = D / 100;
            }
            setRenderingIntent(D) {
            }
            setFlatness(D) {
            }
            setGState(D) {
              for (const [M, I] of D)
                switch (M) {
                  case "LW":
                    this.setLineWidth(I);
                    break;
                  case "LC":
                    this.setLineCap(I);
                    break;
                  case "LJ":
                    this.setLineJoin(I);
                    break;
                  case "ML":
                    this.setMiterLimit(I);
                    break;
                  case "D":
                    this.setDash(I[0], I[1]);
                    break;
                  case "RI":
                    this.setRenderingIntent(I);
                    break;
                  case "FL":
                    this.setFlatness(I);
                    break;
                  case "Font":
                    this.setFont(I);
                    break;
                  case "CA":
                    this.setStrokeAlpha(I);
                    break;
                  case "ca":
                    this.setFillAlpha(I);
                    break;
                  default:
                    (0, u.warn)(`Unimplemented graphic state operator ${M}`);
                    break;
                }
            }
            fill() {
              const D = this.current;
              D.element && (D.element.setAttributeNS(null, "fill", D.fillColor), D.element.setAttributeNS(null, "fill-opacity", D.fillAlpha), this.endPath());
            }
            stroke() {
              const D = this.current;
              D.element && (this._setStrokeAttributes(D.element), D.element.setAttributeNS(null, "fill", "none"), this.endPath());
            }
            _setStrokeAttributes(D, M = 1) {
              const I = this.current;
              let P = I.dashArray;
              M !== 1 && P.length > 0 && (P = P.map(function(L) {
                return M * L;
              })), D.setAttributeNS(null, "stroke", I.strokeColor), D.setAttributeNS(null, "stroke-opacity", I.strokeAlpha), D.setAttributeNS(null, "stroke-miterlimit", x(I.miterLimit)), D.setAttributeNS(null, "stroke-linecap", I.lineCap), D.setAttributeNS(null, "stroke-linejoin", I.lineJoin), D.setAttributeNS(null, "stroke-width", x(M * I.lineWidth) + "px"), D.setAttributeNS(null, "stroke-dasharray", P.map(x).join(" ")), D.setAttributeNS(null, "stroke-dashoffset", x(M * I.dashPhase) + "px");
            }
            eoFill() {
              var D;
              (D = this.current.element) == null || D.setAttributeNS(null, "fill-rule", "evenodd"), this.fill();
            }
            fillStroke() {
              this.stroke(), this.fill();
            }
            eoFillStroke() {
              var D;
              (D = this.current.element) == null || D.setAttributeNS(null, "fill-rule", "evenodd"), this.fillStroke();
            }
            closeStroke() {
              this.closePath(), this.stroke();
            }
            closeFillStroke() {
              this.closePath(), this.fillStroke();
            }
            closeEOFillStroke() {
              this.closePath(), this.eoFillStroke();
            }
            paintSolidColorImageMask() {
              const D = this.svgFactory.createElement("svg:rect");
              D.setAttributeNS(null, "x", "0"), D.setAttributeNS(null, "y", "0"), D.setAttributeNS(null, "width", "1px"), D.setAttributeNS(null, "height", "1px"), D.setAttributeNS(null, "fill", this.current.fillColor), this._ensureTransformGroup().append(D);
            }
            paintImageXObject(D) {
              const M = this.getObject(D);
              if (!M) {
                (0, u.warn)(`Dependent image with object ID ${D} is not ready yet`);
                return;
              }
              this.paintInlineImageXObject(M);
            }
            paintInlineImageXObject(D, M) {
              const I = D.width, P = D.height, L = E(D, this.forceDataSchema, !!M), Y = this.svgFactory.createElement("svg:rect");
              Y.setAttributeNS(null, "x", "0"), Y.setAttributeNS(null, "y", "0"), Y.setAttributeNS(null, "width", x(I)), Y.setAttributeNS(null, "height", x(P)), this.current.element = Y, this.clip("nonzero");
              const N = this.svgFactory.createElement("svg:image");
              N.setAttributeNS($, "xlink:href", L), N.setAttributeNS(null, "x", "0"), N.setAttributeNS(null, "y", x(-P)), N.setAttributeNS(null, "width", x(I) + "px"), N.setAttributeNS(null, "height", x(P) + "px"), N.setAttributeNS(null, "transform", `scale(${x(1 / I)} ${x(-1 / P)})`), M ? M.append(N) : this._ensureTransformGroup().append(N);
            }
            paintImageMaskXObject(D) {
              const M = this.getObject(D.data, D);
              if (M.bitmap) {
                (0, u.warn)("paintImageMaskXObject: ImageBitmap support is not implemented, ensure that the `isOffscreenCanvasSupported` API parameter is disabled.");
                return;
              }
              const I = this.current, P = M.width, L = M.height, Y = I.fillColor;
              I.maskId = `mask${C++}`;
              const N = this.svgFactory.createElement("svg:mask");
              N.setAttributeNS(null, "id", I.maskId);
              const W = this.svgFactory.createElement("svg:rect");
              W.setAttributeNS(null, "x", "0"), W.setAttributeNS(null, "y", "0"), W.setAttributeNS(null, "width", x(P)), W.setAttributeNS(null, "height", x(L)), W.setAttributeNS(null, "fill", Y), W.setAttributeNS(null, "mask", `url(#${I.maskId})`), this.defs.append(N), this._ensureTransformGroup().append(W), this.paintInlineImageXObject(M, N);
            }
            paintFormXObjectBegin(D, M) {
              if (Array.isArray(D) && D.length === 6 && this.transform(D[0], D[1], D[2], D[3], D[4], D[5]), M) {
                const I = M[2] - M[0], P = M[3] - M[1], L = this.svgFactory.createElement("svg:rect");
                L.setAttributeNS(null, "x", M[0]), L.setAttributeNS(null, "y", M[1]), L.setAttributeNS(null, "width", x(I)), L.setAttributeNS(null, "height", x(P)), this.current.element = L, this.clip("nonzero"), this.endPath();
              }
            }
            paintFormXObjectEnd() {
            }
            _initialize(D) {
              const M = this.svgFactory.create(D.width, D.height), I = this.svgFactory.createElement("svg:defs");
              M.append(I), this.defs = I;
              const P = this.svgFactory.createElement("svg:g");
              return P.setAttributeNS(null, "transform", H(D.transform)), M.append(P), this.svg = P, M;
            }
            _ensureClipGroup() {
              if (!this.current.clipGroup) {
                const D = this.svgFactory.createElement("svg:g");
                D.setAttributeNS(null, "clip-path", this.current.activeClipUrl), this.svg.append(D), this.current.clipGroup = D;
              }
              return this.current.clipGroup;
            }
            _ensureTransformGroup() {
              return this.tgrp || (this.tgrp = this.svgFactory.createElement("svg:g"), this.tgrp.setAttributeNS(null, "transform", H(this.transformMatrix)), this.current.activeClipUrl ? this._ensureClipGroup().append(this.tgrp) : this.svg.append(this.tgrp)), this.tgrp;
            }
          }
          a.SVGGraphics = j;
        },
        /* 25 */
        /***/
        (c, a) => {
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.XfaText = void 0;
          class h {
            static textContent(u) {
              const _ = [], g = {
                items: _,
                styles: /* @__PURE__ */ Object.create(null)
              };
              function $(b) {
                var E;
                if (!b)
                  return;
                let y = null;
                const v = b.name;
                if (v === "#text")
                  y = b.value;
                else if (h.shouldBuildText(v))
                  (E = b == null ? void 0 : b.attributes) != null && E.textContent ? y = b.attributes.textContent : b.value && (y = b.value);
                else return;
                if (y !== null && _.push({
                  str: y
                }), !!b.children)
                  for (const S of b.children)
                    $(S);
              }
              return $(u), g;
            }
            static shouldBuildText(u) {
              return !(u === "textarea" || u === "input" || u === "option" || u === "select");
            }
          }
          a.XfaText = h;
        },
        /* 26 */
        /***/
        (c, a, h) => {
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.TextLayerRenderTask = void 0, a.renderTextLayer = H, a.updateTextLayer = T;
          var d = h(1), u = h(6);
          const _ = 1e5, g = 30, $ = 0.8, b = /* @__PURE__ */ new Map();
          function y(C, O) {
            let j;
            if (O && d.FeatureTest.isOffscreenCanvasSupported)
              j = new OffscreenCanvas(C, C).getContext("2d", {
                alpha: !1
              });
            else {
              const B = document.createElement("canvas");
              B.width = B.height = C, j = B.getContext("2d", {
                alpha: !1
              });
            }
            return j;
          }
          function v(C, O) {
            const j = b.get(C);
            if (j)
              return j;
            const B = y(g, O);
            B.font = `${g}px ${C}`;
            const D = B.measureText("");
            let M = D.fontBoundingBoxAscent, I = Math.abs(D.fontBoundingBoxDescent);
            if (M) {
              const L = M / (M + I);
              return b.set(C, L), B.canvas.width = B.canvas.height = 0, L;
            }
            B.strokeStyle = "red", B.clearRect(0, 0, g, g), B.strokeText("g", 0, 0);
            let P = B.getImageData(0, 0, g, g).data;
            I = 0;
            for (let L = P.length - 1 - 3; L >= 0; L -= 4)
              if (P[L] > 0) {
                I = Math.ceil(L / 4 / g);
                break;
              }
            B.clearRect(0, 0, g, g), B.strokeText("A", 0, g), P = B.getImageData(0, 0, g, g).data, M = 0;
            for (let L = 0, Y = P.length; L < Y; L += 4)
              if (P[L] > 0) {
                M = g - Math.floor(L / 4 / g);
                break;
              }
            if (B.canvas.width = B.canvas.height = 0, M) {
              const L = M / (M + I);
              return b.set(C, L), L;
            }
            return b.set(C, $), $;
          }
          function E(C, O, j) {
            const B = document.createElement("span"), D = {
              angle: 0,
              canvasWidth: 0,
              hasText: O.str !== "",
              hasEOL: O.hasEOL,
              fontSize: 0
            };
            C._textDivs.push(B);
            const M = d.Util.transform(C._transform, O.transform);
            let I = Math.atan2(M[1], M[0]);
            const P = j[O.fontName];
            P.vertical && (I += Math.PI / 2);
            const L = Math.hypot(M[2], M[3]), Y = L * v(P.fontFamily, C._isOffscreenCanvasSupported);
            let N, W;
            I === 0 ? (N = M[4], W = M[5] - Y) : (N = M[4] + Y * Math.sin(I), W = M[5] - Y * Math.cos(I));
            const V = "calc(var(--scale-factor)*", ue = B.style;
            C._container === C._rootContainer ? (ue.left = `${(100 * N / C._pageWidth).toFixed(2)}%`, ue.top = `${(100 * W / C._pageHeight).toFixed(2)}%`) : (ue.left = `${V}${N.toFixed(2)}px)`, ue.top = `${V}${W.toFixed(2)}px)`), ue.fontSize = `${V}${L.toFixed(2)}px)`, ue.fontFamily = P.fontFamily, D.fontSize = L, B.setAttribute("role", "presentation"), B.textContent = O.str, B.dir = O.dir, C._fontInspectorEnabled && (B.dataset.fontName = O.fontName), I !== 0 && (D.angle = I * (180 / Math.PI));
            let se = !1;
            if (O.str.length > 1)
              se = !0;
            else if (O.str !== " " && O.transform[0] !== O.transform[3]) {
              const ce = Math.abs(O.transform[0]), oe = Math.abs(O.transform[3]);
              ce !== oe && Math.max(ce, oe) / Math.min(ce, oe) > 1.5 && (se = !0);
            }
            se && (D.canvasWidth = P.vertical ? O.height : O.width), C._textDivProperties.set(B, D), C._isReadableStream && C._layoutText(B);
          }
          function S(C) {
            const {
              div: O,
              scale: j,
              properties: B,
              ctx: D,
              prevFontSize: M,
              prevFontFamily: I
            } = C, {
              style: P
            } = O;
            let L = "";
            if (B.canvasWidth !== 0 && B.hasText) {
              const {
                fontFamily: Y
              } = P, {
                canvasWidth: N,
                fontSize: W
              } = B;
              (M !== W || I !== Y) && (D.font = `${W * j}px ${Y}`, C.prevFontSize = W, C.prevFontFamily = Y);
              const {
                width: V
              } = D.measureText(O.textContent);
              V > 0 && (L = `scaleX(${N * j / V})`);
            }
            B.angle !== 0 && (L = `rotate(${B.angle}deg) ${L}`), L.length > 0 && (P.transform = L);
          }
          function R(C) {
            if (C._canceled)
              return;
            const O = C._textDivs, j = C._capability;
            if (O.length > _) {
              j.resolve();
              return;
            }
            if (!C._isReadableStream)
              for (const D of O)
                C._layoutText(D);
            j.resolve();
          }
          class x {
            constructor({
              textContentSource: O,
              container: j,
              viewport: B,
              textDivs: D,
              textDivProperties: M,
              textContentItemsStr: I,
              isOffscreenCanvasSupported: P
            }) {
              var V;
              this._textContentSource = O, this._isReadableStream = O instanceof ReadableStream, this._container = this._rootContainer = j, this._textDivs = D || [], this._textContentItemsStr = I || [], this._isOffscreenCanvasSupported = P, this._fontInspectorEnabled = !!((V = globalThis.FontInspector) != null && V.enabled), this._reader = null, this._textDivProperties = M || /* @__PURE__ */ new WeakMap(), this._canceled = !1, this._capability = new d.PromiseCapability(), this._layoutTextParams = {
                prevFontSize: null,
                prevFontFamily: null,
                div: null,
                scale: B.scale * (globalThis.devicePixelRatio || 1),
                properties: null,
                ctx: y(0, P)
              };
              const {
                pageWidth: L,
                pageHeight: Y,
                pageX: N,
                pageY: W
              } = B.rawDims;
              this._transform = [1, 0, 0, -1, -N, W + Y], this._pageWidth = L, this._pageHeight = Y, (0, u.setLayerDimensions)(j, B), this._capability.promise.finally(() => {
                this._layoutTextParams = null;
              }).catch(() => {
              });
            }
            get promise() {
              return this._capability.promise;
            }
            cancel() {
              this._canceled = !0, this._reader && (this._reader.cancel(new d.AbortException("TextLayer task cancelled.")).catch(() => {
              }), this._reader = null), this._capability.reject(new d.AbortException("TextLayer task cancelled."));
            }
            _processItems(O, j) {
              for (const B of O) {
                if (B.str === void 0) {
                  if (B.type === "beginMarkedContentProps" || B.type === "beginMarkedContent") {
                    const D = this._container;
                    this._container = document.createElement("span"), this._container.classList.add("markedContent"), B.id !== null && this._container.setAttribute("id", `${B.id}`), D.append(this._container);
                  } else B.type === "endMarkedContent" && (this._container = this._container.parentNode);
                  continue;
                }
                this._textContentItemsStr.push(B.str), E(this, B, j);
              }
            }
            _layoutText(O) {
              const j = this._layoutTextParams.properties = this._textDivProperties.get(O);
              if (this._layoutTextParams.div = O, S(this._layoutTextParams), j.hasText && this._container.append(O), j.hasEOL) {
                const B = document.createElement("br");
                B.setAttribute("role", "presentation"), this._container.append(B);
              }
            }
            _render() {
              const O = new d.PromiseCapability();
              let j = /* @__PURE__ */ Object.create(null);
              if (this._isReadableStream) {
                const B = () => {
                  this._reader.read().then(({
                    value: D,
                    done: M
                  }) => {
                    if (M) {
                      O.resolve();
                      return;
                    }
                    Object.assign(j, D.styles), this._processItems(D.items, j), B();
                  }, O.reject);
                };
                this._reader = this._textContentSource.getReader(), B();
              } else if (this._textContentSource) {
                const {
                  items: B,
                  styles: D
                } = this._textContentSource;
                this._processItems(B, D), O.resolve();
              } else
                throw new Error('No "textContentSource" parameter specified.');
              O.promise.then(() => {
                j = null, R(this);
              }, this._capability.reject);
            }
          }
          a.TextLayerRenderTask = x;
          function H(C) {
            !C.textContentSource && (C.textContent || C.textContentStream) && ((0, u.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead."), C.textContentSource = C.textContent || C.textContentStream);
            const {
              container: O,
              viewport: j
            } = C, B = getComputedStyle(O), D = B.getPropertyValue("visibility"), M = parseFloat(B.getPropertyValue("--scale-factor"));
            D === "visible" && (!M || Math.abs(M - j.scale) > 1e-5) && console.error("The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM.");
            const I = new x(C);
            return I._render(), I;
          }
          function T({
            container: C,
            viewport: O,
            textDivs: j,
            textDivProperties: B,
            isOffscreenCanvasSupported: D,
            mustRotate: M = !0,
            mustRescale: I = !0
          }) {
            if (M && (0, u.setLayerDimensions)(C, {
              rotation: O.rotation
            }), I) {
              const P = y(0, D), Y = {
                prevFontSize: null,
                prevFontFamily: null,
                div: null,
                scale: O.scale * (globalThis.devicePixelRatio || 1),
                properties: null,
                ctx: P
              };
              for (const N of j)
                Y.properties = B.get(N), Y.div = N, S(Y);
            }
          }
        },
        /* 27 */
        /***/
        (c, a, h) => {
          var v, E, S, R, x, H, T, C, O, j, B, bn, Gt, yn, $n;
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.AnnotationEditorLayer = void 0;
          var d = h(1), u = h(4), _ = h(28), g = h(33), $ = h(6), b = h(34);
          const L = class L {
            constructor({
              uiManager: N,
              pageIndex: W,
              div: V,
              accessibilityManager: ue,
              annotationLayer: se,
              viewport: ce,
              l10n: oe
            }) {
              Ee(this, B);
              Ee(this, v);
              Ee(this, E, !1);
              Ee(this, S, null);
              Ee(this, R, this.pointerup.bind(this));
              Ee(this, x, this.pointerdown.bind(this));
              Ee(this, H, /* @__PURE__ */ new Map());
              Ee(this, T, !1);
              Ee(this, C, !1);
              Ee(this, O, !1);
              Ee(this, j);
              const ge = [_.FreeTextEditor, g.InkEditor, b.StampEditor];
              if (!L._initialized) {
                L._initialized = !0;
                for (const J of ge)
                  J.initialize(oe);
              }
              N.registerEditorTypes(ge), Se(this, j, N), this.pageIndex = W, this.div = V, Se(this, v, ue), Se(this, S, se), this.viewport = ce, w(this, j).addLayer(this);
            }
            get isEmpty() {
              return w(this, H).size === 0;
            }
            updateToolbar(N) {
              w(this, j).updateToolbar(N);
            }
            updateMode(N = w(this, j).getMode()) {
              _e(this, B, $n).call(this), N === d.AnnotationEditorType.INK ? (this.addInkEditorIfNeeded(!1), this.disableClick()) : this.enableClick(), N !== d.AnnotationEditorType.NONE && (this.div.classList.toggle("freeTextEditing", N === d.AnnotationEditorType.FREETEXT), this.div.classList.toggle("inkEditing", N === d.AnnotationEditorType.INK), this.div.classList.toggle("stampEditing", N === d.AnnotationEditorType.STAMP), this.div.hidden = !1);
            }
            addInkEditorIfNeeded(N) {
              if (!N && w(this, j).getMode() !== d.AnnotationEditorType.INK)
                return;
              if (!N) {
                for (const V of w(this, H).values())
                  if (V.isEmpty()) {
                    V.setInBackground();
                    return;
                  }
              }
              _e(this, B, Gt).call(this, {
                offsetX: 0,
                offsetY: 0
              }, !1).setInBackground();
            }
            setEditingState(N) {
              w(this, j).setEditingState(N);
            }
            addCommands(N) {
              w(this, j).addCommands(N);
            }
            enable() {
              this.div.style.pointerEvents = "auto";
              const N = /* @__PURE__ */ new Set();
              for (const V of w(this, H).values())
                V.enableEditing(), V.annotationElementId && N.add(V.annotationElementId);
              if (!w(this, S))
                return;
              const W = w(this, S).getEditableAnnotations();
              for (const V of W) {
                if (V.hide(), w(this, j).isDeletedAnnotationElement(V.data.id) || N.has(V.data.id))
                  continue;
                const ue = this.deserialize(V);
                ue && (this.addOrRebuild(ue), ue.enableEditing());
              }
            }
            disable() {
              var W;
              Se(this, O, !0), this.div.style.pointerEvents = "none";
              const N = /* @__PURE__ */ new Set();
              for (const V of w(this, H).values()) {
                if (V.disableEditing(), !V.annotationElementId || V.serialize() !== null) {
                  N.add(V.annotationElementId);
                  continue;
                }
                (W = this.getEditableAnnotation(V.annotationElementId)) == null || W.show(), V.remove();
              }
              if (w(this, S)) {
                const V = w(this, S).getEditableAnnotations();
                for (const ue of V) {
                  const {
                    id: se
                  } = ue.data;
                  N.has(se) || w(this, j).isDeletedAnnotationElement(se) || ue.show();
                }
              }
              _e(this, B, $n).call(this), this.isEmpty && (this.div.hidden = !0), Se(this, O, !1);
            }
            getEditableAnnotation(N) {
              var W;
              return ((W = w(this, S)) == null ? void 0 : W.getEditableAnnotation(N)) || null;
            }
            setActiveEditor(N) {
              w(this, j).getActive() !== N && w(this, j).setActiveEditor(N);
            }
            enableClick() {
              this.div.addEventListener("pointerdown", w(this, x)), this.div.addEventListener("pointerup", w(this, R));
            }
            disableClick() {
              this.div.removeEventListener("pointerdown", w(this, x)), this.div.removeEventListener("pointerup", w(this, R));
            }
            attach(N) {
              w(this, H).set(N.id, N);
              const {
                annotationElementId: W
              } = N;
              W && w(this, j).isDeletedAnnotationElement(W) && w(this, j).removeDeletedAnnotationElement(N);
            }
            detach(N) {
              var W;
              w(this, H).delete(N.id), (W = w(this, v)) == null || W.removePointerInTextLayer(N.contentDiv), !w(this, O) && N.annotationElementId && w(this, j).addDeletedAnnotationElement(N);
            }
            remove(N) {
              this.detach(N), w(this, j).removeEditor(N), N.div.contains(document.activeElement) && setTimeout(() => {
                w(this, j).focusMainContainer();
              }, 0), N.div.remove(), N.isAttachedToDOM = !1, w(this, C) || this.addInkEditorIfNeeded(!1);
            }
            changeParent(N) {
              var W;
              N.parent !== this && (N.annotationElementId && (w(this, j).addDeletedAnnotationElement(N.annotationElementId), u.AnnotationEditor.deleteAnnotationElement(N), N.annotationElementId = null), this.attach(N), (W = N.parent) == null || W.detach(N), N.setParent(this), N.div && N.isAttachedToDOM && (N.div.remove(), this.div.append(N.div)));
            }
            add(N) {
              if (this.changeParent(N), w(this, j).addEditor(N), this.attach(N), !N.isAttachedToDOM) {
                const W = N.render();
                this.div.append(W), N.isAttachedToDOM = !0;
              }
              N.fixAndSetPosition(), N.onceAdded(), w(this, j).addToAnnotationStorage(N);
            }
            moveEditorInDOM(N) {
              var V;
              if (!N.isAttachedToDOM)
                return;
              const {
                activeElement: W
              } = document;
              N.div.contains(W) && (N._focusEventsAllowed = !1, setTimeout(() => {
                N.div.contains(document.activeElement) ? N._focusEventsAllowed = !0 : (N.div.addEventListener("focusin", () => {
                  N._focusEventsAllowed = !0;
                }, {
                  once: !0
                }), W.focus());
              }, 0)), N._structTreeParentId = (V = w(this, v)) == null ? void 0 : V.moveElementInDOM(this.div, N.div, N.contentDiv, !0);
            }
            addOrRebuild(N) {
              N.needsToBeRebuilt() ? N.rebuild() : this.add(N);
            }
            addUndoableEditor(N) {
              const W = () => N._uiManager.rebuild(N), V = () => {
                N.remove();
              };
              this.addCommands({
                cmd: W,
                undo: V,
                mustExec: !1
              });
            }
            getNextId() {
              return w(this, j).getId();
            }
            pasteEditor(N, W) {
              w(this, j).updateToolbar(N), w(this, j).updateMode(N);
              const {
                offsetX: V,
                offsetY: ue
              } = _e(this, B, yn).call(this), se = this.getNextId(), ce = _e(this, B, bn).call(this, {
                parent: this,
                id: se,
                x: V,
                y: ue,
                uiManager: w(this, j),
                isCentered: !0,
                ...W
              });
              ce && this.add(ce);
            }
            deserialize(N) {
              switch (N.annotationType ?? N.annotationEditorType) {
                case d.AnnotationEditorType.FREETEXT:
                  return _.FreeTextEditor.deserialize(N, this, w(this, j));
                case d.AnnotationEditorType.INK:
                  return g.InkEditor.deserialize(N, this, w(this, j));
                case d.AnnotationEditorType.STAMP:
                  return b.StampEditor.deserialize(N, this, w(this, j));
              }
              return null;
            }
            addNewEditor() {
              _e(this, B, Gt).call(this, _e(this, B, yn).call(this), !0);
            }
            setSelected(N) {
              w(this, j).setSelected(N);
            }
            toggleSelected(N) {
              w(this, j).toggleSelected(N);
            }
            isSelected(N) {
              return w(this, j).isSelected(N);
            }
            unselect(N) {
              w(this, j).unselect(N);
            }
            pointerup(N) {
              const {
                isMac: W
              } = d.FeatureTest.platform;
              if (!(N.button !== 0 || N.ctrlKey && W) && N.target === this.div && w(this, T)) {
                if (Se(this, T, !1), !w(this, E)) {
                  Se(this, E, !0);
                  return;
                }
                if (w(this, j).getMode() === d.AnnotationEditorType.STAMP) {
                  w(this, j).unselectAll();
                  return;
                }
                _e(this, B, Gt).call(this, N, !1);
              }
            }
            pointerdown(N) {
              if (w(this, T)) {
                Se(this, T, !1);
                return;
              }
              const {
                isMac: W
              } = d.FeatureTest.platform;
              if (N.button !== 0 || N.ctrlKey && W || N.target !== this.div)
                return;
              Se(this, T, !0);
              const V = w(this, j).getActive();
              Se(this, E, !V || V.isEmpty());
            }
            findNewParent(N, W, V) {
              const ue = w(this, j).findParent(W, V);
              return ue === null || ue === this ? !1 : (ue.changeParent(N), !0);
            }
            destroy() {
              var N, W;
              ((N = w(this, j).getActive()) == null ? void 0 : N.parent) === this && (w(this, j).commitOrRemove(), w(this, j).setActiveEditor(null));
              for (const V of w(this, H).values())
                (W = w(this, v)) == null || W.removePointerInTextLayer(V.contentDiv), V.setParent(null), V.isAttachedToDOM = !1, V.div.remove();
              this.div = null, w(this, H).clear(), w(this, j).removeLayer(this);
            }
            render({
              viewport: N
            }) {
              this.viewport = N, (0, $.setLayerDimensions)(this.div, N);
              for (const W of w(this, j).getEditors(this.pageIndex))
                this.add(W);
              this.updateMode();
            }
            update({
              viewport: N
            }) {
              w(this, j).commitOrRemove(), this.viewport = N, (0, $.setLayerDimensions)(this.div, {
                rotation: N.rotation
              }), this.updateMode();
            }
            get pageDimensions() {
              const {
                pageWidth: N,
                pageHeight: W
              } = this.viewport.rawDims;
              return [N, W];
            }
          };
          v = new WeakMap(), E = new WeakMap(), S = new WeakMap(), R = new WeakMap(), x = new WeakMap(), H = new WeakMap(), T = new WeakMap(), C = new WeakMap(), O = new WeakMap(), j = new WeakMap(), B = new WeakSet(), bn = function(N) {
            switch (w(this, j).getMode()) {
              case d.AnnotationEditorType.FREETEXT:
                return new _.FreeTextEditor(N);
              case d.AnnotationEditorType.INK:
                return new g.InkEditor(N);
              case d.AnnotationEditorType.STAMP:
                return new b.StampEditor(N);
            }
            return null;
          }, Gt = function(N, W) {
            const V = this.getNextId(), ue = _e(this, B, bn).call(this, {
              parent: this,
              id: V,
              x: N.offsetX,
              y: N.offsetY,
              uiManager: w(this, j),
              isCentered: W
            });
            return ue && this.add(ue), ue;
          }, yn = function() {
            const {
              x: N,
              y: W,
              width: V,
              height: ue
            } = this.div.getBoundingClientRect(), se = Math.max(0, N), ce = Math.max(0, W), oe = Math.min(window.innerWidth, N + V), ge = Math.min(window.innerHeight, W + ue), J = (se + oe) / 2 - N, ae = (ce + ge) / 2 - W, [le, z] = this.viewport.rotation % 180 === 0 ? [J, ae] : [ae, J];
            return {
              offsetX: le,
              offsetY: z
            };
          }, $n = function() {
            Se(this, C, !0);
            for (const N of w(this, H).values())
              N.isEmpty() && N.remove();
            Se(this, C, !1);
          }, _t(L, "_initialized", !1);
          let y = L;
          a.AnnotationEditorLayer = y;
        },
        /* 28 */
        /***/
        (c, a, h) => {
          var b, y, v, E, S, R, x, H, T, C, Kn, Jn, Zn, Lt, En, Qn, wn;
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.FreeTextEditor = void 0;
          var d = h(1), u = h(5), _ = h(4), g = h(29);
          const L = class L extends _.AnnotationEditor {
            constructor(W) {
              super({
                ...W,
                name: "freeTextEditor"
              });
              Ee(this, C);
              Ee(this, b, this.editorDivBlur.bind(this));
              Ee(this, y, this.editorDivFocus.bind(this));
              Ee(this, v, this.editorDivInput.bind(this));
              Ee(this, E, this.editorDivKeydown.bind(this));
              Ee(this, S);
              Ee(this, R, "");
              Ee(this, x, `${this.id}-editor`);
              Ee(this, H);
              Ee(this, T, null);
              Se(this, S, W.color || L._defaultColor || _.AnnotationEditor._defaultLineColor), Se(this, H, W.fontSize || L._defaultFontSize);
            }
            static get _keyboardManager() {
              const W = L.prototype, V = (ce) => ce.isEmpty(), ue = u.AnnotationEditorUIManager.TRANSLATE_SMALL, se = u.AnnotationEditorUIManager.TRANSLATE_BIG;
              return (0, d.shadow)(this, "_keyboardManager", new u.KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], W.commitOrRemove, {
                bubbles: !0
              }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], W.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], W._translateEmpty, {
                args: [-ue, 0],
                checker: V
              }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], W._translateEmpty, {
                args: [-se, 0],
                checker: V
              }], [["ArrowRight", "mac+ArrowRight"], W._translateEmpty, {
                args: [ue, 0],
                checker: V
              }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], W._translateEmpty, {
                args: [se, 0],
                checker: V
              }], [["ArrowUp", "mac+ArrowUp"], W._translateEmpty, {
                args: [0, -ue],
                checker: V
              }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], W._translateEmpty, {
                args: [0, -se],
                checker: V
              }], [["ArrowDown", "mac+ArrowDown"], W._translateEmpty, {
                args: [0, ue],
                checker: V
              }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], W._translateEmpty, {
                args: [0, se],
                checker: V
              }]]));
            }
            static initialize(W) {
              _.AnnotationEditor.initialize(W, {
                strings: ["free_text2_default_content", "editor_free_text2_aria_label"]
              });
              const V = getComputedStyle(document.documentElement);
              this._internalPadding = parseFloat(V.getPropertyValue("--freetext-padding"));
            }
            static updateDefaultParams(W, V) {
              switch (W) {
                case d.AnnotationEditorParamsType.FREETEXT_SIZE:
                  L._defaultFontSize = V;
                  break;
                case d.AnnotationEditorParamsType.FREETEXT_COLOR:
                  L._defaultColor = V;
                  break;
              }
            }
            updateParams(W, V) {
              switch (W) {
                case d.AnnotationEditorParamsType.FREETEXT_SIZE:
                  _e(this, C, Kn).call(this, V);
                  break;
                case d.AnnotationEditorParamsType.FREETEXT_COLOR:
                  _e(this, C, Jn).call(this, V);
                  break;
              }
            }
            static get defaultPropertiesToUpdate() {
              return [[d.AnnotationEditorParamsType.FREETEXT_SIZE, L._defaultFontSize], [d.AnnotationEditorParamsType.FREETEXT_COLOR, L._defaultColor || _.AnnotationEditor._defaultLineColor]];
            }
            get propertiesToUpdate() {
              return [[d.AnnotationEditorParamsType.FREETEXT_SIZE, w(this, H)], [d.AnnotationEditorParamsType.FREETEXT_COLOR, w(this, S)]];
            }
            _translateEmpty(W, V) {
              this._uiManager.translateSelectedEditors(W, V, !0);
            }
            getInitialTranslation() {
              const W = this.parentScale;
              return [-L._internalPadding * W, -(L._internalPadding + w(this, H)) * W];
            }
            rebuild() {
              this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this)));
            }
            enableEditMode() {
              this.isInEditMode() || (this.parent.setEditingState(!1), this.parent.updateToolbar(d.AnnotationEditorType.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), this.editorDiv.addEventListener("keydown", w(this, E)), this.editorDiv.addEventListener("focus", w(this, y)), this.editorDiv.addEventListener("blur", w(this, b)), this.editorDiv.addEventListener("input", w(this, v)));
            }
            disableEditMode() {
              this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", w(this, x)), this._isDraggable = !0, this.editorDiv.removeEventListener("keydown", w(this, E)), this.editorDiv.removeEventListener("focus", w(this, y)), this.editorDiv.removeEventListener("blur", w(this, b)), this.editorDiv.removeEventListener("input", w(this, v)), this.div.focus({
                preventScroll: !0
              }), this.isEditing = !1, this.parent.div.classList.add("freeTextEditing"));
            }
            focusin(W) {
              this._focusEventsAllowed && (super.focusin(W), W.target !== this.editorDiv && this.editorDiv.focus());
            }
            onceAdded() {
              var W;
              if (this.width) {
                _e(this, C, wn).call(this);
                return;
              }
              this.enableEditMode(), this.editorDiv.focus(), (W = this._initialOptions) != null && W.isCentered && this.center(), this._initialOptions = null;
            }
            isEmpty() {
              return !this.editorDiv || this.editorDiv.innerText.trim() === "";
            }
            remove() {
              this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freeTextEditing")), super.remove();
            }
            commit() {
              if (!this.isInEditMode())
                return;
              super.commit(), this.disableEditMode();
              const W = w(this, R), V = Se(this, R, _e(this, C, Zn).call(this).trimEnd());
              if (W === V)
                return;
              const ue = (se) => {
                if (Se(this, R, se), !se) {
                  this.remove();
                  return;
                }
                _e(this, C, En).call(this), this._uiManager.rebuild(this), _e(this, C, Lt).call(this);
              };
              this.addCommands({
                cmd: () => {
                  ue(V);
                },
                undo: () => {
                  ue(W);
                },
                mustExec: !1
              }), _e(this, C, Lt).call(this);
            }
            shouldGetKeyboardEvents() {
              return this.isInEditMode();
            }
            enterInEditMode() {
              this.enableEditMode(), this.editorDiv.focus();
            }
            dblclick(W) {
              this.enterInEditMode();
            }
            keydown(W) {
              W.target === this.div && W.key === "Enter" && (this.enterInEditMode(), W.preventDefault());
            }
            editorDivKeydown(W) {
              L._keyboardManager.exec(this, W);
            }
            editorDivFocus(W) {
              this.isEditing = !0;
            }
            editorDivBlur(W) {
              this.isEditing = !1;
            }
            editorDivInput(W) {
              this.parent.div.classList.toggle("freeTextEditing", this.isEmpty());
            }
            disableEditing() {
              this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline");
            }
            enableEditing() {
              this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0);
            }
            render() {
              if (this.div)
                return this.div;
              let W, V;
              this.width && (W = this.x, V = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", w(this, x)), this.enableEditing(), _.AnnotationEditor._l10nPromise.get("editor_free_text2_aria_label").then((se) => {
                var ce;
                return (ce = this.editorDiv) == null ? void 0 : ce.setAttribute("aria-label", se);
              }), _.AnnotationEditor._l10nPromise.get("free_text2_default_content").then((se) => {
                var ce;
                return (ce = this.editorDiv) == null ? void 0 : ce.setAttribute("default-content", se);
              }), this.editorDiv.contentEditable = !0;
              const {
                style: ue
              } = this.editorDiv;
              if (ue.fontSize = `calc(${w(this, H)}px * var(--scale-factor))`, ue.color = w(this, S), this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), (0, u.bindEvents)(this, this.div, ["dblclick", "keydown"]), this.width) {
                const [se, ce] = this.parentDimensions;
                if (this.annotationElementId) {
                  const {
                    position: oe
                  } = w(this, T);
                  let [ge, J] = this.getInitialTranslation();
                  [ge, J] = this.pageTranslationToScreen(ge, J);
                  const [ae, le] = this.pageDimensions, [z, A] = this.pageTranslation;
                  let F, U;
                  switch (this.rotation) {
                    case 0:
                      F = W + (oe[0] - z) / ae, U = V + this.height - (oe[1] - A) / le;
                      break;
                    case 90:
                      F = W + (oe[0] - z) / ae, U = V - (oe[1] - A) / le, [ge, J] = [J, -ge];
                      break;
                    case 180:
                      F = W - this.width + (oe[0] - z) / ae, U = V - (oe[1] - A) / le, [ge, J] = [-ge, -J];
                      break;
                    case 270:
                      F = W + (oe[0] - z - this.height * le) / ae, U = V + (oe[1] - A - this.width * ae) / le, [ge, J] = [-J, ge];
                      break;
                  }
                  this.setAt(F * se, U * ce, ge, J);
                } else
                  this.setAt(W * se, V * ce, this.width * se, this.height * ce);
                _e(this, C, En).call(this), this._isDraggable = !0, this.editorDiv.contentEditable = !1;
              } else
                this._isDraggable = !1, this.editorDiv.contentEditable = !0;
              return this.div;
            }
            get contentDiv() {
              return this.editorDiv;
            }
            static deserialize(W, V, ue) {
              let se = null;
              if (W instanceof g.FreeTextAnnotationElement) {
                const {
                  data: {
                    defaultAppearanceData: {
                      fontSize: oe,
                      fontColor: ge
                    },
                    rect: J,
                    rotation: ae,
                    id: le
                  },
                  textContent: z,
                  textPosition: A,
                  parent: {
                    page: {
                      pageNumber: F
                    }
                  }
                } = W;
                if (!z || z.length === 0)
                  return null;
                se = W = {
                  annotationType: d.AnnotationEditorType.FREETEXT,
                  color: Array.from(ge),
                  fontSize: oe,
                  value: z.join(`
`),
                  position: A,
                  pageIndex: F - 1,
                  rect: J,
                  rotation: ae,
                  id: le,
                  deleted: !1
                };
              }
              const ce = super.deserialize(W, V, ue);
              return Se(ce, H, W.fontSize), Se(ce, S, d.Util.makeHexColor(...W.color)), Se(ce, R, W.value), ce.annotationElementId = W.id || null, Se(ce, T, se), ce;
            }
            serialize(W = !1) {
              if (this.isEmpty())
                return null;
              if (this.deleted)
                return {
                  pageIndex: this.pageIndex,
                  id: this.annotationElementId,
                  deleted: !0
                };
              const V = L._internalPadding * this.parentScale, ue = this.getRect(V, V), se = _.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : w(this, S)), ce = {
                annotationType: d.AnnotationEditorType.FREETEXT,
                color: se,
                fontSize: w(this, H),
                value: w(this, R),
                pageIndex: this.pageIndex,
                rect: ue,
                rotation: this.rotation,
                structTreeParentId: this._structTreeParentId
              };
              return W ? ce : this.annotationElementId && !_e(this, C, Qn).call(this, ce) ? null : (ce.id = this.annotationElementId, ce);
            }
          };
          b = new WeakMap(), y = new WeakMap(), v = new WeakMap(), E = new WeakMap(), S = new WeakMap(), R = new WeakMap(), x = new WeakMap(), H = new WeakMap(), T = new WeakMap(), C = new WeakSet(), Kn = function(W) {
            const V = (se) => {
              this.editorDiv.style.fontSize = `calc(${se}px * var(--scale-factor))`, this.translate(0, -(se - w(this, H)) * this.parentScale), Se(this, H, se), _e(this, C, Lt).call(this);
            }, ue = w(this, H);
            this.addCommands({
              cmd: () => {
                V(W);
              },
              undo: () => {
                V(ue);
              },
              mustExec: !0,
              type: d.AnnotationEditorParamsType.FREETEXT_SIZE,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, Jn = function(W) {
            const V = w(this, S);
            this.addCommands({
              cmd: () => {
                Se(this, S, this.editorDiv.style.color = W);
              },
              undo: () => {
                Se(this, S, this.editorDiv.style.color = V);
              },
              mustExec: !0,
              type: d.AnnotationEditorParamsType.FREETEXT_COLOR,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, Zn = function() {
            const W = this.editorDiv.getElementsByTagName("div");
            if (W.length === 0)
              return this.editorDiv.innerText;
            const V = [];
            for (const ue of W)
              V.push(ue.innerText.replace(/\r\n?|\n/, ""));
            return V.join(`
`);
          }, Lt = function() {
            const [W, V] = this.parentDimensions;
            let ue;
            if (this.isAttachedToDOM)
              ue = this.div.getBoundingClientRect();
            else {
              const {
                currentLayer: se,
                div: ce
              } = this, oe = ce.style.display;
              ce.style.display = "hidden", se.div.append(this.div), ue = ce.getBoundingClientRect(), ce.remove(), ce.style.display = oe;
            }
            this.rotation % 180 === this.parentRotation % 180 ? (this.width = ue.width / W, this.height = ue.height / V) : (this.width = ue.height / W, this.height = ue.width / V), this.fixAndSetPosition();
          }, En = function() {
            if (this.editorDiv.replaceChildren(), !!w(this, R))
              for (const W of w(this, R).split(`
`)) {
                const V = document.createElement("div");
                V.append(W ? document.createTextNode(W) : document.createElement("br")), this.editorDiv.append(V);
              }
          }, Qn = function(W) {
            const {
              value: V,
              fontSize: ue,
              color: se,
              rect: ce,
              pageIndex: oe
            } = w(this, T);
            return W.value !== V || W.fontSize !== ue || W.rect.some((ge, J) => Math.abs(ge - ce[J]) >= 1) || W.color.some((ge, J) => ge !== se[J]) || W.pageIndex !== oe;
          }, wn = function(W = !1) {
            if (!this.annotationElementId)
              return;
            if (_e(this, C, Lt).call(this), !W && (this.width === 0 || this.height === 0)) {
              setTimeout(() => _e(this, C, wn).call(this, !0), 0);
              return;
            }
            const V = L._internalPadding * this.parentScale;
            w(this, T).rect = this.getRect(V, V);
          }, _t(L, "_freeTextDefaultContent", ""), _t(L, "_internalPadding", 0), _t(L, "_defaultColor", null), _t(L, "_defaultFontSize", 10), _t(L, "_type", "freetext");
          let $ = L;
          a.FreeTextEditor = $;
        },
        /* 29 */
        /***/
        (c, a, h) => {
          var U, G, At, ei, me, Te, Pe, Re, Me, Fe, ve, be, X, ne, te, ye, xe, Le, Ie, fe, He, Be, ti, Vt, Sn, An, et, lt, dt, De, $e, we, ze, Cn, ct, ie, Ce, Ue, ni, Tn;
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.StampAnnotationElement = a.InkAnnotationElement = a.FreeTextAnnotationElement = a.AnnotationLayer = void 0;
          var d = h(1), u = h(6), _ = h(3), g = h(30), $ = h(31), b = h(32);
          const y = 1e3, v = 9, E = /* @__PURE__ */ new WeakSet();
          function S(We) {
            return {
              width: We[2] - We[0],
              height: We[3] - We[1]
            };
          }
          class R {
            static create(ee) {
              switch (ee.data.annotationType) {
                case d.AnnotationType.LINK:
                  return new H(ee);
                case d.AnnotationType.TEXT:
                  return new T(ee);
                case d.AnnotationType.WIDGET:
                  switch (ee.data.fieldType) {
                    case "Tx":
                      return new O(ee);
                    case "Btn":
                      return ee.data.radioButton ? new D(ee) : ee.data.checkBox ? new B(ee) : new M(ee);
                    case "Ch":
                      return new I(ee);
                    case "Sig":
                      return new j(ee);
                  }
                  return new C(ee);
                case d.AnnotationType.POPUP:
                  return new P(ee);
                case d.AnnotationType.FREETEXT:
                  return new Y(ee);
                case d.AnnotationType.LINE:
                  return new N(ee);
                case d.AnnotationType.SQUARE:
                  return new W(ee);
                case d.AnnotationType.CIRCLE:
                  return new V(ee);
                case d.AnnotationType.POLYLINE:
                  return new ue(ee);
                case d.AnnotationType.CARET:
                  return new ce(ee);
                case d.AnnotationType.INK:
                  return new oe(ee);
                case d.AnnotationType.POLYGON:
                  return new se(ee);
                case d.AnnotationType.HIGHLIGHT:
                  return new ge(ee);
                case d.AnnotationType.UNDERLINE:
                  return new J(ee);
                case d.AnnotationType.SQUIGGLY:
                  return new ae(ee);
                case d.AnnotationType.STRIKEOUT:
                  return new le(ee);
                case d.AnnotationType.STAMP:
                  return new z(ee);
                case d.AnnotationType.FILEATTACHMENT:
                  return new A(ee);
                default:
                  return new x(ee);
              }
            }
          }
          const Z = class Z {
            constructor(ee, {
              isRenderable: K = !1,
              ignoreBorder: de = !1,
              createQuadrilaterals: Ae = !1
            } = {}) {
              Ee(this, U, !1);
              this.isRenderable = K, this.data = ee.data, this.layer = ee.layer, this.linkService = ee.linkService, this.downloadManager = ee.downloadManager, this.imageResourcesPath = ee.imageResourcesPath, this.renderForms = ee.renderForms, this.svgFactory = ee.svgFactory, this.annotationStorage = ee.annotationStorage, this.enableScripting = ee.enableScripting, this.hasJSActions = ee.hasJSActions, this._fieldObjects = ee.fieldObjects, this.parent = ee.parent, K && (this.container = this._createContainer(de)), Ae && this._createQuadrilaterals();
            }
            static _hasPopupData({
              titleObj: ee,
              contentsObj: K,
              richText: de
            }) {
              return !!(ee != null && ee.str || K != null && K.str || de != null && de.str);
            }
            get hasPopupData() {
              return Z._hasPopupData(this.data);
            }
            _createContainer(ee) {
              const {
                data: K,
                parent: {
                  page: de,
                  viewport: Ae
                }
              } = this, ke = document.createElement("section");
              ke.setAttribute("data-annotation-id", K.id), this instanceof C || (ke.tabIndex = y), ke.style.zIndex = this.parent.zIndex++, this.data.popupRef && ke.setAttribute("aria-haspopup", "dialog"), K.noRotate && ke.classList.add("norotate");
              const {
                pageWidth: Oe,
                pageHeight: Ne,
                pageX: Xe,
                pageY: Ye
              } = Ae.rawDims;
              if (!K.rect || this instanceof P) {
                const {
                  rotation: it
                } = K;
                return !K.hasOwnCanvas && it !== 0 && this.setRotation(it, ke), ke;
              }
              const {
                width: qe,
                height: rt
              } = S(K.rect), Ke = d.Util.normalizeRect([K.rect[0], de.view[3] - K.rect[1] + de.view[1], K.rect[2], de.view[3] - K.rect[3] + de.view[1]]);
              if (!ee && K.borderStyle.width > 0) {
                ke.style.borderWidth = `${K.borderStyle.width}px`;
                const it = K.borderStyle.horizontalCornerRadius, ot = K.borderStyle.verticalCornerRadius;
                if (it > 0 || ot > 0) {
                  const ft = `calc(${it}px * var(--scale-factor)) / calc(${ot}px * var(--scale-factor))`;
                  ke.style.borderRadius = ft;
                } else if (this instanceof D) {
                  const ft = `calc(${qe}px * var(--scale-factor)) / calc(${rt}px * var(--scale-factor))`;
                  ke.style.borderRadius = ft;
                }
                switch (K.borderStyle.style) {
                  case d.AnnotationBorderStyleType.SOLID:
                    ke.style.borderStyle = "solid";
                    break;
                  case d.AnnotationBorderStyleType.DASHED:
                    ke.style.borderStyle = "dashed";
                    break;
                  case d.AnnotationBorderStyleType.BEVELED:
                    (0, d.warn)("Unimplemented border style: beveled");
                    break;
                  case d.AnnotationBorderStyleType.INSET:
                    (0, d.warn)("Unimplemented border style: inset");
                    break;
                  case d.AnnotationBorderStyleType.UNDERLINE:
                    ke.style.borderBottomStyle = "solid";
                    break;
                }
                const ut = K.borderColor || null;
                ut ? (Se(this, U, !0), ke.style.borderColor = d.Util.makeHexColor(ut[0] | 0, ut[1] | 0, ut[2] | 0)) : ke.style.borderWidth = 0;
              }
              ke.style.left = `${100 * (Ke[0] - Xe) / Oe}%`, ke.style.top = `${100 * (Ke[1] - Ye) / Ne}%`;
              const {
                rotation: Ge
              } = K;
              return K.hasOwnCanvas || Ge === 0 ? (ke.style.width = `${100 * qe / Oe}%`, ke.style.height = `${100 * rt / Ne}%`) : this.setRotation(Ge, ke), ke;
            }
            setRotation(ee, K = this.container) {
              if (!this.data.rect)
                return;
              const {
                pageWidth: de,
                pageHeight: Ae
              } = this.parent.viewport.rawDims, {
                width: ke,
                height: Oe
              } = S(this.data.rect);
              let Ne, Xe;
              ee % 180 === 0 ? (Ne = 100 * ke / de, Xe = 100 * Oe / Ae) : (Ne = 100 * Oe / de, Xe = 100 * ke / Ae), K.style.width = `${Ne}%`, K.style.height = `${Xe}%`, K.setAttribute("data-main-rotation", (360 - ee) % 360);
            }
            get _commonActions() {
              const ee = (K, de, Ae) => {
                const ke = Ae.detail[K], Oe = ke[0], Ne = ke.slice(1);
                Ae.target.style[de] = g.ColorConverters[`${Oe}_HTML`](Ne), this.annotationStorage.setValue(this.data.id, {
                  [de]: g.ColorConverters[`${Oe}_rgb`](Ne)
                });
              };
              return (0, d.shadow)(this, "_commonActions", {
                display: (K) => {
                  const {
                    display: de
                  } = K.detail, Ae = de % 2 === 1;
                  this.container.style.visibility = Ae ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                    noView: Ae,
                    noPrint: de === 1 || de === 2
                  });
                },
                print: (K) => {
                  this.annotationStorage.setValue(this.data.id, {
                    noPrint: !K.detail.print
                  });
                },
                hidden: (K) => {
                  const {
                    hidden: de
                  } = K.detail;
                  this.container.style.visibility = de ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, {
                    noPrint: de,
                    noView: de
                  });
                },
                focus: (K) => {
                  setTimeout(() => K.target.focus({
                    preventScroll: !1
                  }), 0);
                },
                userName: (K) => {
                  K.target.title = K.detail.userName;
                },
                readonly: (K) => {
                  K.target.disabled = K.detail.readonly;
                },
                required: (K) => {
                  this._setRequired(K.target, K.detail.required);
                },
                bgColor: (K) => {
                  ee("bgColor", "backgroundColor", K);
                },
                fillColor: (K) => {
                  ee("fillColor", "backgroundColor", K);
                },
                fgColor: (K) => {
                  ee("fgColor", "color", K);
                },
                textColor: (K) => {
                  ee("textColor", "color", K);
                },
                borderColor: (K) => {
                  ee("borderColor", "borderColor", K);
                },
                strokeColor: (K) => {
                  ee("strokeColor", "borderColor", K);
                },
                rotation: (K) => {
                  const de = K.detail.rotation;
                  this.setRotation(de), this.annotationStorage.setValue(this.data.id, {
                    rotation: de
                  });
                }
              });
            }
            _dispatchEventFromSandbox(ee, K) {
              const de = this._commonActions;
              for (const Ae of Object.keys(K.detail)) {
                const ke = ee[Ae] || de[Ae];
                ke == null || ke(K);
              }
            }
            _setDefaultPropertiesFromJS(ee) {
              if (!this.enableScripting)
                return;
              const K = this.annotationStorage.getRawValue(this.data.id);
              if (!K)
                return;
              const de = this._commonActions;
              for (const [Ae, ke] of Object.entries(K)) {
                const Oe = de[Ae];
                if (Oe) {
                  const Ne = {
                    detail: {
                      [Ae]: ke
                    },
                    target: ee
                  };
                  Oe(Ne), delete K[Ae];
                }
              }
            }
            _createQuadrilaterals() {
              if (!this.container)
                return;
              const {
                quadPoints: ee
              } = this.data;
              if (!ee)
                return;
              const [K, de, Ae, ke] = this.data.rect;
              if (ee.length === 1) {
                const [, {
                  x: ot,
                  y: ut
                }, {
                  x: ft,
                  y: mt
                }] = ee[0];
                if (Ae === ot && ke === ut && K === ft && de === mt)
                  return;
              }
              const {
                style: Oe
              } = this.container;
              let Ne;
              if (w(this, U)) {
                const {
                  borderColor: ot,
                  borderWidth: ut
                } = Oe;
                Oe.borderWidth = 0, Ne = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${ot}" stroke-width="${ut}">`], this.container.classList.add("hasBorder");
              }
              const Xe = Ae - K, Ye = ke - de, {
                svgFactory: qe
              } = this, rt = qe.createElement("svg");
              rt.classList.add("quadrilateralsContainer"), rt.setAttribute("width", 0), rt.setAttribute("height", 0);
              const Ke = qe.createElement("defs");
              rt.append(Ke);
              const Ge = qe.createElement("clipPath"), it = `clippath_${this.data.id}`;
              Ge.setAttribute("id", it), Ge.setAttribute("clipPathUnits", "objectBoundingBox"), Ke.append(Ge);
              for (const [, {
                x: ot,
                y: ut
              }, {
                x: ft,
                y: mt
              }] of ee) {
                const Je = qe.createElement("rect"), pe = (ft - K) / Xe, je = (ke - ut) / Ye, tt = (ot - ft) / Xe, pt = (ut - mt) / Ye;
                Je.setAttribute("x", pe), Je.setAttribute("y", je), Je.setAttribute("width", tt), Je.setAttribute("height", pt), Ge.append(Je), Ne == null || Ne.push(`<rect vector-effect="non-scaling-stroke" x="${pe}" y="${je}" width="${tt}" height="${pt}"/>`);
              }
              w(this, U) && (Ne.push("</g></svg>')"), Oe.backgroundImage = Ne.join("")), this.container.append(rt), this.container.style.clipPath = `url(#${it})`;
            }
            _createPopup() {
              const {
                container: ee,
                data: K
              } = this;
              ee.setAttribute("aria-haspopup", "dialog");
              const de = new P({
                data: {
                  color: K.color,
                  titleObj: K.titleObj,
                  modificationDate: K.modificationDate,
                  contentsObj: K.contentsObj,
                  richText: K.richText,
                  parentRect: K.rect,
                  borderStyle: 0,
                  id: `popup_${K.id}`,
                  rotation: K.rotation
                },
                parent: this.parent,
                elements: [this]
              });
              this.parent.div.append(de.render());
            }
            render() {
              (0, d.unreachable)("Abstract method `AnnotationElement.render` called");
            }
            _getElementsByName(ee, K = null) {
              const de = [];
              if (this._fieldObjects) {
                const Ae = this._fieldObjects[ee];
                if (Ae)
                  for (const {
                    page: ke,
                    id: Oe,
                    exportValues: Ne
                  } of Ae) {
                    if (ke === -1 || Oe === K)
                      continue;
                    const Xe = typeof Ne == "string" ? Ne : null, Ye = document.querySelector(`[data-element-id="${Oe}"]`);
                    if (Ye && !E.has(Ye)) {
                      (0, d.warn)(`_getElementsByName - element not allowed: ${Oe}`);
                      continue;
                    }
                    de.push({
                      id: Oe,
                      exportValue: Xe,
                      domElement: Ye
                    });
                  }
                return de;
              }
              for (const Ae of document.getElementsByName(ee)) {
                const {
                  exportValue: ke
                } = Ae, Oe = Ae.getAttribute("data-element-id");
                Oe !== K && E.has(Ae) && de.push({
                  id: Oe,
                  exportValue: ke,
                  domElement: Ae
                });
              }
              return de;
            }
            show() {
              var ee;
              this.container && (this.container.hidden = !1), (ee = this.popup) == null || ee.maybeShow();
            }
            hide() {
              var ee;
              this.container && (this.container.hidden = !0), (ee = this.popup) == null || ee.forceHide();
            }
            getElementsToTriggerPopup() {
              return this.container;
            }
            addHighlightArea() {
              const ee = this.getElementsToTriggerPopup();
              if (Array.isArray(ee))
                for (const K of ee)
                  K.classList.add("highlightArea");
              else
                ee.classList.add("highlightArea");
            }
            _editOnDoubleClick() {
              const {
                annotationEditorType: ee,
                data: {
                  id: K
                }
              } = this;
              this.container.addEventListener("dblclick", () => {
                var de;
                (de = this.linkService.eventBus) == null || de.dispatch("switchannotationeditormode", {
                  source: this,
                  mode: ee,
                  editId: K
                });
              });
            }
          };
          U = new WeakMap();
          let x = Z;
          class H extends x {
            constructor(K, de = null) {
              super(K, {
                isRenderable: !0,
                ignoreBorder: !!(de != null && de.ignoreBorder),
                createQuadrilaterals: !0
              });
              Ee(this, G);
              this.isTooltipOnly = K.data.isTooltipOnly;
            }
            render() {
              const {
                data: K,
                linkService: de
              } = this, Ae = document.createElement("a");
              Ae.setAttribute("data-element-id", K.id);
              let ke = !1;
              return K.url ? (de.addLinkAttributes(Ae, K.url, K.newWindow), ke = !0) : K.action ? (this._bindNamedAction(Ae, K.action), ke = !0) : K.attachment ? (this._bindAttachment(Ae, K.attachment), ke = !0) : K.setOCGState ? (_e(this, G, ei).call(this, Ae, K.setOCGState), ke = !0) : K.dest ? (this._bindLink(Ae, K.dest), ke = !0) : (K.actions && (K.actions.Action || K.actions["Mouse Up"] || K.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(Ae, K), ke = !0), K.resetForm ? (this._bindResetFormAction(Ae, K.resetForm), ke = !0) : this.isTooltipOnly && !ke && (this._bindLink(Ae, ""), ke = !0)), this.container.classList.add("linkAnnotation"), ke && this.container.append(Ae), this.container;
            }
            _bindLink(K, de) {
              K.href = this.linkService.getDestinationHash(de), K.onclick = () => (de && this.linkService.goToDestination(de), !1), (de || de === "") && _e(this, G, At).call(this);
            }
            _bindNamedAction(K, de) {
              K.href = this.linkService.getAnchorUrl(""), K.onclick = () => (this.linkService.executeNamedAction(de), !1), _e(this, G, At).call(this);
            }
            _bindAttachment(K, de) {
              K.href = this.linkService.getAnchorUrl(""), K.onclick = () => {
                var Ae;
                return (Ae = this.downloadManager) == null || Ae.openOrDownloadData(this.container, de.content, de.filename), !1;
              }, _e(this, G, At).call(this);
            }
            _bindJSAction(K, de) {
              K.href = this.linkService.getAnchorUrl("");
              const Ae = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
              for (const ke of Object.keys(de.actions)) {
                const Oe = Ae.get(ke);
                Oe && (K[Oe] = () => {
                  var Ne;
                  return (Ne = this.linkService.eventBus) == null || Ne.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id: de.id,
                      name: ke
                    }
                  }), !1;
                });
              }
              K.onclick || (K.onclick = () => !1), _e(this, G, At).call(this);
            }
            _bindResetFormAction(K, de) {
              const Ae = K.onclick;
              if (Ae || (K.href = this.linkService.getAnchorUrl("")), _e(this, G, At).call(this), !this._fieldObjects) {
                (0, d.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), Ae || (K.onclick = () => !1);
                return;
              }
              K.onclick = () => {
                var rt;
                Ae == null || Ae();
                const {
                  fields: ke,
                  refs: Oe,
                  include: Ne
                } = de, Xe = [];
                if (ke.length !== 0 || Oe.length !== 0) {
                  const Ke = new Set(Oe);
                  for (const Ge of ke) {
                    const it = this._fieldObjects[Ge] || [];
                    for (const {
                      id: ot
                    } of it)
                      Ke.add(ot);
                  }
                  for (const Ge of Object.values(this._fieldObjects))
                    for (const it of Ge)
                      Ke.has(it.id) === Ne && Xe.push(it);
                } else
                  for (const Ke of Object.values(this._fieldObjects))
                    Xe.push(...Ke);
                const Ye = this.annotationStorage, qe = [];
                for (const Ke of Xe) {
                  const {
                    id: Ge
                  } = Ke;
                  switch (qe.push(Ge), Ke.type) {
                    case "text": {
                      const ot = Ke.defaultValue || "";
                      Ye.setValue(Ge, {
                        value: ot
                      });
                      break;
                    }
                    case "checkbox":
                    case "radiobutton": {
                      const ot = Ke.defaultValue === Ke.exportValues;
                      Ye.setValue(Ge, {
                        value: ot
                      });
                      break;
                    }
                    case "combobox":
                    case "listbox": {
                      const ot = Ke.defaultValue || "";
                      Ye.setValue(Ge, {
                        value: ot
                      });
                      break;
                    }
                    default:
                      continue;
                  }
                  const it = document.querySelector(`[data-element-id="${Ge}"]`);
                  if (it) {
                    if (!E.has(it)) {
                      (0, d.warn)(`_bindResetFormAction - element not allowed: ${Ge}`);
                      continue;
                    }
                  } else continue;
                  it.dispatchEvent(new Event("resetform"));
                }
                return this.enableScripting && ((rt = this.linkService.eventBus) == null || rt.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: "app",
                    ids: qe,
                    name: "ResetForm"
                  }
                })), !1;
              };
            }
          }
          G = new WeakSet(), At = function() {
            this.container.setAttribute("data-internal-link", "");
          }, ei = function(K, de) {
            K.href = this.linkService.getAnchorUrl(""), K.onclick = () => (this.linkService.executeSetOCGState(de), !1), _e(this, G, At).call(this);
          };
          class T extends x {
            constructor(ee) {
              super(ee, {
                isRenderable: !0
              });
            }
            render() {
              this.container.classList.add("textAnnotation");
              const ee = document.createElement("img");
              return ee.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", ee.alt = "[{{type}} Annotation]", ee.dataset.l10nId = "text_annotation_type", ee.dataset.l10nArgs = JSON.stringify({
                type: this.data.name
              }), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(ee), this.container;
            }
          }
          class C extends x {
            render() {
              return this.data.alternativeText && (this.container.title = this.data.alternativeText), this.container;
            }
            showElementAndHideCanvas(ee) {
              var K;
              this.data.hasOwnCanvas && (((K = ee.previousSibling) == null ? void 0 : K.nodeName) === "CANVAS" && (ee.previousSibling.hidden = !0), ee.hidden = !1);
            }
            _getKeyModifier(ee) {
              const {
                isWin: K,
                isMac: de
              } = d.FeatureTest.platform;
              return K && ee.ctrlKey || de && ee.metaKey;
            }
            _setEventListener(ee, K, de, Ae, ke) {
              de.includes("mouse") ? ee.addEventListener(de, (Oe) => {
                var Ne;
                (Ne = this.linkService.eventBus) == null || Ne.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: Ae,
                    value: ke(Oe),
                    shift: Oe.shiftKey,
                    modifier: this._getKeyModifier(Oe)
                  }
                });
              }) : ee.addEventListener(de, (Oe) => {
                var Ne;
                if (de === "blur") {
                  if (!K.focused || !Oe.relatedTarget)
                    return;
                  K.focused = !1;
                } else if (de === "focus") {
                  if (K.focused)
                    return;
                  K.focused = !0;
                }
                ke && ((Ne = this.linkService.eventBus) == null || Ne.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: Ae,
                    value: ke(Oe)
                  }
                }));
              });
            }
            _setEventListeners(ee, K, de, Ae) {
              var ke, Oe, Ne;
              for (const [Xe, Ye] of de)
                (Ye === "Action" || (ke = this.data.actions) != null && ke[Ye]) && ((Ye === "Focus" || Ye === "Blur") && (K || (K = {
                  focused: !1
                })), this._setEventListener(ee, K, Xe, Ye, Ae), Ye === "Focus" && !((Oe = this.data.actions) != null && Oe.Blur) ? this._setEventListener(ee, K, "blur", "Blur", null) : Ye === "Blur" && !((Ne = this.data.actions) != null && Ne.Focus) && this._setEventListener(ee, K, "focus", "Focus", null));
            }
            _setBackgroundColor(ee) {
              const K = this.data.backgroundColor || null;
              ee.style.backgroundColor = K === null ? "transparent" : d.Util.makeHexColor(K[0], K[1], K[2]);
            }
            _setTextStyle(ee) {
              const K = ["left", "center", "right"], {
                fontColor: de
              } = this.data.defaultAppearanceData, Ae = this.data.defaultAppearanceData.fontSize || v, ke = ee.style;
              let Oe;
              const Ne = 2, Xe = (Ye) => Math.round(10 * Ye) / 10;
              if (this.data.multiLine) {
                const Ye = Math.abs(this.data.rect[3] - this.data.rect[1] - Ne), qe = Math.round(Ye / (d.LINE_FACTOR * Ae)) || 1, rt = Ye / qe;
                Oe = Math.min(Ae, Xe(rt / d.LINE_FACTOR));
              } else {
                const Ye = Math.abs(this.data.rect[3] - this.data.rect[1] - Ne);
                Oe = Math.min(Ae, Xe(Ye / d.LINE_FACTOR));
              }
              ke.fontSize = `calc(${Oe}px * var(--scale-factor))`, ke.color = d.Util.makeHexColor(de[0], de[1], de[2]), this.data.textAlignment !== null && (ke.textAlign = K[this.data.textAlignment]);
            }
            _setRequired(ee, K) {
              K ? ee.setAttribute("required", !0) : ee.removeAttribute("required"), ee.setAttribute("aria-required", K);
            }
          }
          class O extends C {
            constructor(ee) {
              const K = ee.renderForms || !ee.data.hasAppearance && !!ee.data.fieldValue;
              super(ee, {
                isRenderable: K
              });
            }
            setPropertyOnSiblings(ee, K, de, Ae) {
              const ke = this.annotationStorage;
              for (const Oe of this._getElementsByName(ee.name, ee.id))
                Oe.domElement && (Oe.domElement[K] = de), ke.setValue(Oe.id, {
                  [Ae]: de
                });
            }
            render() {
              var Ae, ke;
              const ee = this.annotationStorage, K = this.data.id;
              this.container.classList.add("textWidgetAnnotation");
              let de = null;
              if (this.renderForms) {
                const Oe = ee.getValue(K, {
                  value: this.data.fieldValue
                });
                let Ne = Oe.value || "";
                const Xe = ee.getValue(K, {
                  charLimit: this.data.maxLen
                }).charLimit;
                Xe && Ne.length > Xe && (Ne = Ne.slice(0, Xe));
                let Ye = Oe.formattedValue || ((Ae = this.data.textContent) == null ? void 0 : Ae.join(`
`)) || null;
                Ye && this.data.comb && (Ye = Ye.replaceAll(/\s+/g, ""));
                const qe = {
                  userValue: Ne,
                  formattedValue: Ye,
                  lastCommittedValue: null,
                  commitKey: 1,
                  focused: !1
                };
                this.data.multiLine ? (de = document.createElement("textarea"), de.textContent = Ye ?? Ne, this.data.doNotScroll && (de.style.overflowY = "hidden")) : (de = document.createElement("input"), de.type = "text", de.setAttribute("value", Ye ?? Ne), this.data.doNotScroll && (de.style.overflowX = "hidden")), this.data.hasOwnCanvas && (de.hidden = !0), E.add(de), de.setAttribute("data-element-id", K), de.disabled = this.data.readOnly, de.name = this.data.fieldName, de.tabIndex = y, this._setRequired(de, this.data.required), Xe && (de.maxLength = Xe), de.addEventListener("input", (Ke) => {
                  ee.setValue(K, {
                    value: Ke.target.value
                  }), this.setPropertyOnSiblings(de, "value", Ke.target.value, "value"), qe.formattedValue = null;
                }), de.addEventListener("resetform", (Ke) => {
                  const Ge = this.data.defaultFieldValue ?? "";
                  de.value = qe.userValue = Ge, qe.formattedValue = null;
                });
                let rt = (Ke) => {
                  const {
                    formattedValue: Ge
                  } = qe;
                  Ge != null && (Ke.target.value = Ge), Ke.target.scrollLeft = 0;
                };
                if (this.enableScripting && this.hasJSActions) {
                  de.addEventListener("focus", (Ge) => {
                    if (qe.focused)
                      return;
                    const {
                      target: it
                    } = Ge;
                    qe.userValue && (it.value = qe.userValue), qe.lastCommittedValue = it.value, qe.commitKey = 1, qe.focused = !0;
                  }), de.addEventListener("updatefromsandbox", (Ge) => {
                    this.showElementAndHideCanvas(Ge.target);
                    const it = {
                      value(ot) {
                        qe.userValue = ot.detail.value ?? "", ee.setValue(K, {
                          value: qe.userValue.toString()
                        }), ot.target.value = qe.userValue;
                      },
                      formattedValue(ot) {
                        const {
                          formattedValue: ut
                        } = ot.detail;
                        qe.formattedValue = ut, ut != null && ot.target !== document.activeElement && (ot.target.value = ut), ee.setValue(K, {
                          formattedValue: ut
                        });
                      },
                      selRange(ot) {
                        ot.target.setSelectionRange(...ot.detail.selRange);
                      },
                      charLimit: (ot) => {
                        var Je;
                        const {
                          charLimit: ut
                        } = ot.detail, {
                          target: ft
                        } = ot;
                        if (ut === 0) {
                          ft.removeAttribute("maxLength");
                          return;
                        }
                        ft.setAttribute("maxLength", ut);
                        let mt = qe.userValue;
                        !mt || mt.length <= ut || (mt = mt.slice(0, ut), ft.value = qe.userValue = mt, ee.setValue(K, {
                          value: mt
                        }), (Je = this.linkService.eventBus) == null || Je.dispatch("dispatcheventinsandbox", {
                          source: this,
                          detail: {
                            id: K,
                            name: "Keystroke",
                            value: mt,
                            willCommit: !0,
                            commitKey: 1,
                            selStart: ft.selectionStart,
                            selEnd: ft.selectionEnd
                          }
                        }));
                      }
                    };
                    this._dispatchEventFromSandbox(it, Ge);
                  }), de.addEventListener("keydown", (Ge) => {
                    var ut;
                    qe.commitKey = 1;
                    let it = -1;
                    if (Ge.key === "Escape" ? it = 0 : Ge.key === "Enter" && !this.data.multiLine ? it = 2 : Ge.key === "Tab" && (qe.commitKey = 3), it === -1)
                      return;
                    const {
                      value: ot
                    } = Ge.target;
                    qe.lastCommittedValue !== ot && (qe.lastCommittedValue = ot, qe.userValue = ot, (ut = this.linkService.eventBus) == null || ut.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: K,
                        name: "Keystroke",
                        value: ot,
                        willCommit: !0,
                        commitKey: it,
                        selStart: Ge.target.selectionStart,
                        selEnd: Ge.target.selectionEnd
                      }
                    }));
                  });
                  const Ke = rt;
                  rt = null, de.addEventListener("blur", (Ge) => {
                    var ot;
                    if (!qe.focused || !Ge.relatedTarget)
                      return;
                    qe.focused = !1;
                    const {
                      value: it
                    } = Ge.target;
                    qe.userValue = it, qe.lastCommittedValue !== it && ((ot = this.linkService.eventBus) == null || ot.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: K,
                        name: "Keystroke",
                        value: it,
                        willCommit: !0,
                        commitKey: qe.commitKey,
                        selStart: Ge.target.selectionStart,
                        selEnd: Ge.target.selectionEnd
                      }
                    })), Ke(Ge);
                  }), (ke = this.data.actions) != null && ke.Keystroke && de.addEventListener("beforeinput", (Ge) => {
                    var je;
                    qe.lastCommittedValue = null;
                    const {
                      data: it,
                      target: ot
                    } = Ge, {
                      value: ut,
                      selectionStart: ft,
                      selectionEnd: mt
                    } = ot;
                    let Je = ft, pe = mt;
                    switch (Ge.inputType) {
                      case "deleteWordBackward": {
                        const tt = ut.substring(0, ft).match(/\w*[^\w]*$/);
                        tt && (Je -= tt[0].length);
                        break;
                      }
                      case "deleteWordForward": {
                        const tt = ut.substring(ft).match(/^[^\w]*\w*/);
                        tt && (pe += tt[0].length);
                        break;
                      }
                      case "deleteContentBackward":
                        ft === mt && (Je -= 1);
                        break;
                      case "deleteContentForward":
                        ft === mt && (pe += 1);
                        break;
                    }
                    Ge.preventDefault(), (je = this.linkService.eventBus) == null || je.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id: K,
                        name: "Keystroke",
                        value: ut,
                        change: it || "",
                        willCommit: !1,
                        selStart: Je,
                        selEnd: pe
                      }
                    });
                  }), this._setEventListeners(de, qe, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (Ge) => Ge.target.value);
                }
                if (rt && de.addEventListener("blur", rt), this.data.comb) {
                  const Ge = (this.data.rect[2] - this.data.rect[0]) / Xe;
                  de.classList.add("comb"), de.style.letterSpacing = `calc(${Ge}px * var(--scale-factor) - 1ch)`;
                }
              } else
                de = document.createElement("div"), de.textContent = this.data.fieldValue, de.style.verticalAlign = "middle", de.style.display = "table-cell";
              return this._setTextStyle(de), this._setBackgroundColor(de), this._setDefaultPropertiesFromJS(de), this.container.append(de), this.container;
            }
          }
          class j extends C {
            constructor(ee) {
              super(ee, {
                isRenderable: !!ee.data.hasOwnCanvas
              });
            }
          }
          class B extends C {
            constructor(ee) {
              super(ee, {
                isRenderable: ee.renderForms
              });
            }
            render() {
              const ee = this.annotationStorage, K = this.data, de = K.id;
              let Ae = ee.getValue(de, {
                value: K.exportValue === K.fieldValue
              }).value;
              typeof Ae == "string" && (Ae = Ae !== "Off", ee.setValue(de, {
                value: Ae
              })), this.container.classList.add("buttonWidgetAnnotation", "checkBox");
              const ke = document.createElement("input");
              return E.add(ke), ke.setAttribute("data-element-id", de), ke.disabled = K.readOnly, this._setRequired(ke, this.data.required), ke.type = "checkbox", ke.name = K.fieldName, Ae && ke.setAttribute("checked", !0), ke.setAttribute("exportValue", K.exportValue), ke.tabIndex = y, ke.addEventListener("change", (Oe) => {
                const {
                  name: Ne,
                  checked: Xe
                } = Oe.target;
                for (const Ye of this._getElementsByName(Ne, de)) {
                  const qe = Xe && Ye.exportValue === K.exportValue;
                  Ye.domElement && (Ye.domElement.checked = qe), ee.setValue(Ye.id, {
                    value: qe
                  });
                }
                ee.setValue(de, {
                  value: Xe
                });
              }), ke.addEventListener("resetform", (Oe) => {
                const Ne = K.defaultFieldValue || "Off";
                Oe.target.checked = Ne === K.exportValue;
              }), this.enableScripting && this.hasJSActions && (ke.addEventListener("updatefromsandbox", (Oe) => {
                const Ne = {
                  value(Xe) {
                    Xe.target.checked = Xe.detail.value !== "Off", ee.setValue(de, {
                      value: Xe.target.checked
                    });
                  }
                };
                this._dispatchEventFromSandbox(Ne, Oe);
              }), this._setEventListeners(ke, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (Oe) => Oe.target.checked)), this._setBackgroundColor(ke), this._setDefaultPropertiesFromJS(ke), this.container.append(ke), this.container;
            }
          }
          class D extends C {
            constructor(ee) {
              super(ee, {
                isRenderable: ee.renderForms
              });
            }
            render() {
              this.container.classList.add("buttonWidgetAnnotation", "radioButton");
              const ee = this.annotationStorage, K = this.data, de = K.id;
              let Ae = ee.getValue(de, {
                value: K.fieldValue === K.buttonValue
              }).value;
              typeof Ae == "string" && (Ae = Ae !== K.buttonValue, ee.setValue(de, {
                value: Ae
              }));
              const ke = document.createElement("input");
              if (E.add(ke), ke.setAttribute("data-element-id", de), ke.disabled = K.readOnly, this._setRequired(ke, this.data.required), ke.type = "radio", ke.name = K.fieldName, Ae && ke.setAttribute("checked", !0), ke.tabIndex = y, ke.addEventListener("change", (Oe) => {
                const {
                  name: Ne,
                  checked: Xe
                } = Oe.target;
                for (const Ye of this._getElementsByName(Ne, de))
                  ee.setValue(Ye.id, {
                    value: !1
                  });
                ee.setValue(de, {
                  value: Xe
                });
              }), ke.addEventListener("resetform", (Oe) => {
                const Ne = K.defaultFieldValue;
                Oe.target.checked = Ne != null && Ne === K.buttonValue;
              }), this.enableScripting && this.hasJSActions) {
                const Oe = K.buttonValue;
                ke.addEventListener("updatefromsandbox", (Ne) => {
                  const Xe = {
                    value: (Ye) => {
                      const qe = Oe === Ye.detail.value;
                      for (const rt of this._getElementsByName(Ye.target.name)) {
                        const Ke = qe && rt.id === de;
                        rt.domElement && (rt.domElement.checked = Ke), ee.setValue(rt.id, {
                          value: Ke
                        });
                      }
                    }
                  };
                  this._dispatchEventFromSandbox(Xe, Ne);
                }), this._setEventListeners(ke, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (Ne) => Ne.target.checked);
              }
              return this._setBackgroundColor(ke), this._setDefaultPropertiesFromJS(ke), this.container.append(ke), this.container;
            }
          }
          class M extends H {
            constructor(ee) {
              super(ee, {
                ignoreBorder: ee.data.hasAppearance
              });
            }
            render() {
              const ee = super.render();
              ee.classList.add("buttonWidgetAnnotation", "pushButton"), this.data.alternativeText && (ee.title = this.data.alternativeText);
              const K = ee.lastChild;
              return this.enableScripting && this.hasJSActions && K && (this._setDefaultPropertiesFromJS(K), K.addEventListener("updatefromsandbox", (de) => {
                this._dispatchEventFromSandbox({}, de);
              })), ee;
            }
          }
          class I extends C {
            constructor(ee) {
              super(ee, {
                isRenderable: ee.renderForms
              });
            }
            render() {
              this.container.classList.add("choiceWidgetAnnotation");
              const ee = this.annotationStorage, K = this.data.id, de = ee.getValue(K, {
                value: this.data.fieldValue
              }), Ae = document.createElement("select");
              E.add(Ae), Ae.setAttribute("data-element-id", K), Ae.disabled = this.data.readOnly, this._setRequired(Ae, this.data.required), Ae.name = this.data.fieldName, Ae.tabIndex = y;
              let ke = this.data.combo && this.data.options.length > 0;
              this.data.combo || (Ae.size = this.data.options.length, this.data.multiSelect && (Ae.multiple = !0)), Ae.addEventListener("resetform", (qe) => {
                const rt = this.data.defaultFieldValue;
                for (const Ke of Ae.options)
                  Ke.selected = Ke.value === rt;
              });
              for (const qe of this.data.options) {
                const rt = document.createElement("option");
                rt.textContent = qe.displayValue, rt.value = qe.exportValue, de.value.includes(qe.exportValue) && (rt.setAttribute("selected", !0), ke = !1), Ae.append(rt);
              }
              let Oe = null;
              if (ke) {
                const qe = document.createElement("option");
                qe.value = " ", qe.setAttribute("hidden", !0), qe.setAttribute("selected", !0), Ae.prepend(qe), Oe = () => {
                  qe.remove(), Ae.removeEventListener("input", Oe), Oe = null;
                }, Ae.addEventListener("input", Oe);
              }
              const Ne = (qe) => {
                const rt = qe ? "value" : "textContent", {
                  options: Ke,
                  multiple: Ge
                } = Ae;
                return Ge ? Array.prototype.filter.call(Ke, (it) => it.selected).map((it) => it[rt]) : Ke.selectedIndex === -1 ? null : Ke[Ke.selectedIndex][rt];
              };
              let Xe = Ne(!1);
              const Ye = (qe) => {
                const rt = qe.target.options;
                return Array.prototype.map.call(rt, (Ke) => ({
                  displayValue: Ke.textContent,
                  exportValue: Ke.value
                }));
              };
              return this.enableScripting && this.hasJSActions ? (Ae.addEventListener("updatefromsandbox", (qe) => {
                const rt = {
                  value(Ke) {
                    Oe == null || Oe();
                    const Ge = Ke.detail.value, it = new Set(Array.isArray(Ge) ? Ge : [Ge]);
                    for (const ot of Ae.options)
                      ot.selected = it.has(ot.value);
                    ee.setValue(K, {
                      value: Ne(!0)
                    }), Xe = Ne(!1);
                  },
                  multipleSelection(Ke) {
                    Ae.multiple = !0;
                  },
                  remove(Ke) {
                    const Ge = Ae.options, it = Ke.detail.remove;
                    Ge[it].selected = !1, Ae.remove(it), Ge.length > 0 && Array.prototype.findIndex.call(Ge, (ut) => ut.selected) === -1 && (Ge[0].selected = !0), ee.setValue(K, {
                      value: Ne(!0),
                      items: Ye(Ke)
                    }), Xe = Ne(!1);
                  },
                  clear(Ke) {
                    for (; Ae.length !== 0; )
                      Ae.remove(0);
                    ee.setValue(K, {
                      value: null,
                      items: []
                    }), Xe = Ne(!1);
                  },
                  insert(Ke) {
                    const {
                      index: Ge,
                      displayValue: it,
                      exportValue: ot
                    } = Ke.detail.insert, ut = Ae.children[Ge], ft = document.createElement("option");
                    ft.textContent = it, ft.value = ot, ut ? ut.before(ft) : Ae.append(ft), ee.setValue(K, {
                      value: Ne(!0),
                      items: Ye(Ke)
                    }), Xe = Ne(!1);
                  },
                  items(Ke) {
                    const {
                      items: Ge
                    } = Ke.detail;
                    for (; Ae.length !== 0; )
                      Ae.remove(0);
                    for (const it of Ge) {
                      const {
                        displayValue: ot,
                        exportValue: ut
                      } = it, ft = document.createElement("option");
                      ft.textContent = ot, ft.value = ut, Ae.append(ft);
                    }
                    Ae.options.length > 0 && (Ae.options[0].selected = !0), ee.setValue(K, {
                      value: Ne(!0),
                      items: Ye(Ke)
                    }), Xe = Ne(!1);
                  },
                  indices(Ke) {
                    const Ge = new Set(Ke.detail.indices);
                    for (const it of Ke.target.options)
                      it.selected = Ge.has(it.index);
                    ee.setValue(K, {
                      value: Ne(!0)
                    }), Xe = Ne(!1);
                  },
                  editable(Ke) {
                    Ke.target.disabled = !Ke.detail.editable;
                  }
                };
                this._dispatchEventFromSandbox(rt, qe);
              }), Ae.addEventListener("input", (qe) => {
                var Ke;
                const rt = Ne(!0);
                ee.setValue(K, {
                  value: rt
                }), qe.preventDefault(), (Ke = this.linkService.eventBus) == null || Ke.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: K,
                    name: "Keystroke",
                    value: Xe,
                    changeEx: rt,
                    willCommit: !1,
                    commitKey: 1,
                    keyDown: !1
                  }
                });
              }), this._setEventListeners(Ae, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (qe) => qe.target.value)) : Ae.addEventListener("input", function(qe) {
                ee.setValue(K, {
                  value: Ne(!0)
                });
              }), this.data.combo && this._setTextStyle(Ae), this._setBackgroundColor(Ae), this._setDefaultPropertiesFromJS(Ae), this.container.append(Ae), this.container;
            }
          }
          class P extends x {
            constructor(ee) {
              const {
                data: K,
                elements: de
              } = ee;
              super(ee, {
                isRenderable: x._hasPopupData(K)
              }), this.elements = de;
            }
            render() {
              this.container.classList.add("popupAnnotation");
              const ee = new L({
                container: this.container,
                color: this.data.color,
                titleObj: this.data.titleObj,
                modificationDate: this.data.modificationDate,
                contentsObj: this.data.contentsObj,
                richText: this.data.richText,
                rect: this.data.rect,
                parentRect: this.data.parentRect || null,
                parent: this.parent,
                elements: this.elements,
                open: this.data.open
              }), K = [];
              for (const de of this.elements)
                de.popup = ee, K.push(de.data.id), de.addHighlightArea();
              return this.container.setAttribute("aria-controls", K.map((de) => `${d.AnnotationPrefix}${de}`).join(",")), this.container;
            }
          }
          class L {
            constructor({
              container: ee,
              color: K,
              elements: de,
              titleObj: Ae,
              modificationDate: ke,
              contentsObj: Oe,
              richText: Ne,
              parent: Xe,
              rect: Ye,
              parentRect: qe,
              open: rt
            }) {
              Ee(this, Be);
              Ee(this, me, null);
              Ee(this, Te, _e(this, Be, ti).bind(this));
              Ee(this, Pe, _e(this, Be, An).bind(this));
              Ee(this, Re, _e(this, Be, Sn).bind(this));
              Ee(this, Me, _e(this, Be, Vt).bind(this));
              Ee(this, Fe, null);
              Ee(this, ve, null);
              Ee(this, be, null);
              Ee(this, X, null);
              Ee(this, ne, null);
              Ee(this, te, null);
              Ee(this, ye, !1);
              Ee(this, xe, null);
              Ee(this, Le, null);
              Ee(this, Ie, null);
              Ee(this, fe, null);
              Ee(this, He, !1);
              var Ge;
              Se(this, ve, ee), Se(this, fe, Ae), Se(this, be, Oe), Se(this, Ie, Ne), Se(this, ne, Xe), Se(this, Fe, K), Se(this, Le, Ye), Se(this, te, qe), Se(this, X, de);
              const Ke = u.PDFDateString.toDateObject(ke);
              Ke && Se(this, me, Xe.l10n.get("annotation_date_string", {
                date: Ke.toLocaleDateString(),
                time: Ke.toLocaleTimeString()
              })), this.trigger = de.flatMap((it) => it.getElementsToTriggerPopup());
              for (const it of this.trigger)
                it.addEventListener("click", w(this, Me)), it.addEventListener("mouseenter", w(this, Re)), it.addEventListener("mouseleave", w(this, Pe)), it.classList.add("popupTriggerArea");
              for (const it of de)
                (Ge = it.container) == null || Ge.addEventListener("keydown", w(this, Te));
              w(this, ve).hidden = !0, rt && _e(this, Be, Vt).call(this);
            }
            render() {
              if (w(this, xe))
                return;
              const {
                page: {
                  view: ee
                },
                viewport: {
                  rawDims: {
                    pageWidth: K,
                    pageHeight: de,
                    pageX: Ae,
                    pageY: ke
                  }
                }
              } = w(this, ne), Oe = Se(this, xe, document.createElement("div"));
              if (Oe.className = "popup", w(this, Fe)) {
                const Je = Oe.style.outlineColor = d.Util.makeHexColor(...w(this, Fe));
                CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? Oe.style.backgroundColor = `color-mix(in srgb, ${Je} 30%, white)` : Oe.style.backgroundColor = d.Util.makeHexColor(...w(this, Fe).map((je) => Math.floor(0.7 * (255 - je) + je)));
              }
              const Ne = document.createElement("span");
              Ne.className = "header";
              const Xe = document.createElement("h1");
              if (Ne.append(Xe), {
                dir: Xe.dir,
                str: Xe.textContent
              } = w(this, fe), Oe.append(Ne), w(this, me)) {
                const Je = document.createElement("span");
                Je.classList.add("popupDate"), w(this, me).then((pe) => {
                  Je.textContent = pe;
                }), Ne.append(Je);
              }
              const Ye = w(this, be), qe = w(this, Ie);
              if (qe != null && qe.str && (!(Ye != null && Ye.str) || Ye.str === qe.str))
                b.XfaLayer.render({
                  xfaHtml: qe.html,
                  intent: "richText",
                  div: Oe
                }), Oe.lastChild.classList.add("richText", "popupContent");
              else {
                const Je = this._formatContents(Ye);
                Oe.append(Je);
              }
              let rt = !!w(this, te), Ke = rt ? w(this, te) : w(this, Le);
              for (const Je of w(this, X))
                if (!Ke || d.Util.intersect(Je.data.rect, Ke) !== null) {
                  Ke = Je.data.rect, rt = !0;
                  break;
                }
              const Ge = d.Util.normalizeRect([Ke[0], ee[3] - Ke[1] + ee[1], Ke[2], ee[3] - Ke[3] + ee[1]]), ot = rt ? Ke[2] - Ke[0] + 5 : 0, ut = Ge[0] + ot, ft = Ge[1], {
                style: mt
              } = w(this, ve);
              mt.left = `${100 * (ut - Ae) / K}%`, mt.top = `${100 * (ft - ke) / de}%`, w(this, ve).append(Oe);
            }
            _formatContents({
              str: ee,
              dir: K
            }) {
              const de = document.createElement("p");
              de.classList.add("popupContent"), de.dir = K;
              const Ae = ee.split(/(?:\r\n?|\n)/);
              for (let ke = 0, Oe = Ae.length; ke < Oe; ++ke) {
                const Ne = Ae[ke];
                de.append(document.createTextNode(Ne)), ke < Oe - 1 && de.append(document.createElement("br"));
              }
              return de;
            }
            forceHide() {
              Se(this, He, this.isVisible), w(this, He) && (w(this, ve).hidden = !0);
            }
            maybeShow() {
              w(this, He) && (Se(this, He, !1), w(this, ve).hidden = !1);
            }
            get isVisible() {
              return w(this, ve).hidden === !1;
            }
          }
          me = new WeakMap(), Te = new WeakMap(), Pe = new WeakMap(), Re = new WeakMap(), Me = new WeakMap(), Fe = new WeakMap(), ve = new WeakMap(), be = new WeakMap(), X = new WeakMap(), ne = new WeakMap(), te = new WeakMap(), ye = new WeakMap(), xe = new WeakMap(), Le = new WeakMap(), Ie = new WeakMap(), fe = new WeakMap(), He = new WeakMap(), Be = new WeakSet(), ti = function(ee) {
            ee.altKey || ee.shiftKey || ee.ctrlKey || ee.metaKey || (ee.key === "Enter" || ee.key === "Escape" && w(this, ye)) && _e(this, Be, Vt).call(this);
          }, Vt = function() {
            Se(this, ye, !w(this, ye)), w(this, ye) ? (_e(this, Be, Sn).call(this), w(this, ve).addEventListener("click", w(this, Me)), w(this, ve).addEventListener("keydown", w(this, Te))) : (_e(this, Be, An).call(this), w(this, ve).removeEventListener("click", w(this, Me)), w(this, ve).removeEventListener("keydown", w(this, Te)));
          }, Sn = function() {
            w(this, xe) || this.render(), this.isVisible ? w(this, ye) && w(this, ve).classList.add("focused") : (w(this, ve).hidden = !1, w(this, ve).style.zIndex = parseInt(w(this, ve).style.zIndex) + 1e3);
          }, An = function() {
            w(this, ve).classList.remove("focused"), !(w(this, ye) || !this.isVisible) && (w(this, ve).hidden = !0, w(this, ve).style.zIndex = parseInt(w(this, ve).style.zIndex) - 1e3);
          };
          class Y extends x {
            constructor(ee) {
              super(ee, {
                isRenderable: !0,
                ignoreBorder: !0
              }), this.textContent = ee.data.textContent, this.textPosition = ee.data.textPosition, this.annotationEditorType = d.AnnotationEditorType.FREETEXT;
            }
            render() {
              if (this.container.classList.add("freeTextAnnotation"), this.textContent) {
                const ee = document.createElement("div");
                ee.classList.add("annotationTextContent"), ee.setAttribute("role", "comment");
                for (const K of this.textContent) {
                  const de = document.createElement("span");
                  de.textContent = K, ee.append(de);
                }
                this.container.append(ee);
              }
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container;
            }
          }
          a.FreeTextAnnotationElement = Y;
          class N extends x {
            constructor(K) {
              super(K, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              Ee(this, et, null);
            }
            render() {
              this.container.classList.add("lineAnnotation");
              const K = this.data, {
                width: de,
                height: Ae
              } = S(K.rect), ke = this.svgFactory.create(de, Ae, !0), Oe = Se(this, et, this.svgFactory.createElement("svg:line"));
              return Oe.setAttribute("x1", K.rect[2] - K.lineCoordinates[0]), Oe.setAttribute("y1", K.rect[3] - K.lineCoordinates[1]), Oe.setAttribute("x2", K.rect[2] - K.lineCoordinates[2]), Oe.setAttribute("y2", K.rect[3] - K.lineCoordinates[3]), Oe.setAttribute("stroke-width", K.borderStyle.width || 1), Oe.setAttribute("stroke", "transparent"), Oe.setAttribute("fill", "transparent"), ke.append(Oe), this.container.append(ke), !K.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
            getElementsToTriggerPopup() {
              return w(this, et);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          et = new WeakMap();
          class W extends x {
            constructor(K) {
              super(K, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              Ee(this, lt, null);
            }
            render() {
              this.container.classList.add("squareAnnotation");
              const K = this.data, {
                width: de,
                height: Ae
              } = S(K.rect), ke = this.svgFactory.create(de, Ae, !0), Oe = K.borderStyle.width, Ne = Se(this, lt, this.svgFactory.createElement("svg:rect"));
              return Ne.setAttribute("x", Oe / 2), Ne.setAttribute("y", Oe / 2), Ne.setAttribute("width", de - Oe), Ne.setAttribute("height", Ae - Oe), Ne.setAttribute("stroke-width", Oe || 1), Ne.setAttribute("stroke", "transparent"), Ne.setAttribute("fill", "transparent"), ke.append(Ne), this.container.append(ke), !K.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
            getElementsToTriggerPopup() {
              return w(this, lt);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          lt = new WeakMap();
          class V extends x {
            constructor(K) {
              super(K, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              Ee(this, dt, null);
            }
            render() {
              this.container.classList.add("circleAnnotation");
              const K = this.data, {
                width: de,
                height: Ae
              } = S(K.rect), ke = this.svgFactory.create(de, Ae, !0), Oe = K.borderStyle.width, Ne = Se(this, dt, this.svgFactory.createElement("svg:ellipse"));
              return Ne.setAttribute("cx", de / 2), Ne.setAttribute("cy", Ae / 2), Ne.setAttribute("rx", de / 2 - Oe / 2), Ne.setAttribute("ry", Ae / 2 - Oe / 2), Ne.setAttribute("stroke-width", Oe || 1), Ne.setAttribute("stroke", "transparent"), Ne.setAttribute("fill", "transparent"), ke.append(Ne), this.container.append(ke), !K.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
            getElementsToTriggerPopup() {
              return w(this, dt);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          dt = new WeakMap();
          class ue extends x {
            constructor(K) {
              super(K, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              Ee(this, De, null);
              this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline";
            }
            render() {
              this.container.classList.add(this.containerClassName);
              const K = this.data, {
                width: de,
                height: Ae
              } = S(K.rect), ke = this.svgFactory.create(de, Ae, !0);
              let Oe = [];
              for (const Xe of K.vertices) {
                const Ye = Xe.x - K.rect[0], qe = K.rect[3] - Xe.y;
                Oe.push(Ye + "," + qe);
              }
              Oe = Oe.join(" ");
              const Ne = Se(this, De, this.svgFactory.createElement(this.svgElementName));
              return Ne.setAttribute("points", Oe), Ne.setAttribute("stroke-width", K.borderStyle.width || 1), Ne.setAttribute("stroke", "transparent"), Ne.setAttribute("fill", "transparent"), ke.append(Ne), this.container.append(ke), !K.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
            getElementsToTriggerPopup() {
              return w(this, De);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          De = new WeakMap();
          class se extends ue {
            constructor(ee) {
              super(ee), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon";
            }
          }
          class ce extends x {
            constructor(ee) {
              super(ee, {
                isRenderable: !0,
                ignoreBorder: !0
              });
            }
            render() {
              return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
          }
          class oe extends x {
            constructor(K) {
              super(K, {
                isRenderable: !0,
                ignoreBorder: !0
              });
              Ee(this, $e, []);
              this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = d.AnnotationEditorType.INK;
            }
            render() {
              this.container.classList.add(this.containerClassName);
              const K = this.data, {
                width: de,
                height: Ae
              } = S(K.rect), ke = this.svgFactory.create(de, Ae, !0);
              for (const Oe of K.inkLists) {
                let Ne = [];
                for (const Ye of Oe) {
                  const qe = Ye.x - K.rect[0], rt = K.rect[3] - Ye.y;
                  Ne.push(`${qe},${rt}`);
                }
                Ne = Ne.join(" ");
                const Xe = this.svgFactory.createElement(this.svgElementName);
                w(this, $e).push(Xe), Xe.setAttribute("points", Ne), Xe.setAttribute("stroke-width", K.borderStyle.width || 1), Xe.setAttribute("stroke", "transparent"), Xe.setAttribute("fill", "transparent"), !K.popupRef && this.hasPopupData && this._createPopup(), ke.append(Xe);
              }
              return this.container.append(ke), this.container;
            }
            getElementsToTriggerPopup() {
              return w(this, $e);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          $e = new WeakMap(), a.InkAnnotationElement = oe;
          class ge extends x {
            constructor(ee) {
              super(ee, {
                isRenderable: !0,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this.container;
            }
          }
          class J extends x {
            constructor(ee) {
              super(ee, {
                isRenderable: !0,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container;
            }
          }
          class ae extends x {
            constructor(ee) {
              super(ee, {
                isRenderable: !0,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container;
            }
          }
          class le extends x {
            constructor(ee) {
              super(ee, {
                isRenderable: !0,
                ignoreBorder: !0,
                createQuadrilaterals: !0
              });
            }
            render() {
              return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container;
            }
          }
          class z extends x {
            constructor(ee) {
              super(ee, {
                isRenderable: !0,
                ignoreBorder: !0
              });
            }
            render() {
              return this.container.classList.add("stampAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container;
            }
          }
          a.StampAnnotationElement = z;
          class A extends x {
            constructor(K) {
              var ke;
              super(K, {
                isRenderable: !0
              });
              Ee(this, ze);
              Ee(this, we, null);
              const {
                filename: de,
                content: Ae
              } = this.data.file;
              this.filename = (0, u.getFilenameFromUrl)(de, !0), this.content = Ae, (ke = this.linkService.eventBus) == null || ke.dispatch("fileattachmentannotation", {
                source: this,
                filename: de,
                content: Ae
              });
            }
            render() {
              this.container.classList.add("fileAttachmentAnnotation");
              const {
                container: K,
                data: de
              } = this;
              let Ae;
              de.hasAppearance || de.fillAlpha === 0 ? Ae = document.createElement("div") : (Ae = document.createElement("img"), Ae.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(de.name) ? "paperclip" : "pushpin"}.svg`, de.fillAlpha && de.fillAlpha < 1 && (Ae.style = `filter: opacity(${Math.round(de.fillAlpha * 100)}%);`)), Ae.addEventListener("dblclick", _e(this, ze, Cn).bind(this)), Se(this, we, Ae);
              const {
                isMac: ke
              } = d.FeatureTest.platform;
              return K.addEventListener("keydown", (Oe) => {
                Oe.key === "Enter" && (ke ? Oe.metaKey : Oe.ctrlKey) && _e(this, ze, Cn).call(this);
              }), !de.popupRef && this.hasPopupData ? this._createPopup() : Ae.classList.add("popupTriggerArea"), K.append(Ae), K;
            }
            getElementsToTriggerPopup() {
              return w(this, we);
            }
            addHighlightArea() {
              this.container.classList.add("highlightArea");
            }
          }
          we = new WeakMap(), ze = new WeakSet(), Cn = function() {
            var K;
            (K = this.downloadManager) == null || K.openOrDownloadData(this.container, this.content, this.filename);
          };
          class F {
            constructor({
              div: ee,
              accessibilityManager: K,
              annotationCanvasMap: de,
              l10n: Ae,
              page: ke,
              viewport: Oe
            }) {
              Ee(this, Ue);
              Ee(this, ct, null);
              Ee(this, ie, null);
              Ee(this, Ce, /* @__PURE__ */ new Map());
              this.div = ee, Se(this, ct, K), Se(this, ie, de), this.l10n = Ae, this.page = ke, this.viewport = Oe, this.zIndex = 0, this.l10n || (this.l10n = $.NullL10n);
            }
            async render(ee) {
              const {
                annotations: K
              } = ee, de = this.div;
              (0, u.setLayerDimensions)(de, this.viewport);
              const Ae = /* @__PURE__ */ new Map(), ke = {
                data: null,
                layer: de,
                linkService: ee.linkService,
                downloadManager: ee.downloadManager,
                imageResourcesPath: ee.imageResourcesPath || "",
                renderForms: ee.renderForms !== !1,
                svgFactory: new u.DOMSVGFactory(),
                annotationStorage: ee.annotationStorage || new _.AnnotationStorage(),
                enableScripting: ee.enableScripting === !0,
                hasJSActions: ee.hasJSActions,
                fieldObjects: ee.fieldObjects,
                parent: this,
                elements: null
              };
              for (const Oe of K) {
                if (Oe.noHTML)
                  continue;
                const Ne = Oe.annotationType === d.AnnotationType.POPUP;
                if (Ne) {
                  const qe = Ae.get(Oe.id);
                  if (!qe)
                    continue;
                  ke.elements = qe;
                } else {
                  const {
                    width: qe,
                    height: rt
                  } = S(Oe.rect);
                  if (qe <= 0 || rt <= 0)
                    continue;
                }
                ke.data = Oe;
                const Xe = R.create(ke);
                if (!Xe.isRenderable)
                  continue;
                if (!Ne && Oe.popupRef) {
                  const qe = Ae.get(Oe.popupRef);
                  qe ? qe.push(Xe) : Ae.set(Oe.popupRef, [Xe]);
                }
                Xe.annotationEditorType > 0 && w(this, Ce).set(Xe.data.id, Xe);
                const Ye = Xe.render();
                Oe.hidden && (Ye.style.visibility = "hidden"), _e(this, Ue, ni).call(this, Ye, Oe.id);
              }
              _e(this, Ue, Tn).call(this), await this.l10n.translate(de);
            }
            update({
              viewport: ee
            }) {
              const K = this.div;
              this.viewport = ee, (0, u.setLayerDimensions)(K, {
                rotation: ee.rotation
              }), _e(this, Ue, Tn).call(this), K.hidden = !1;
            }
            getEditableAnnotations() {
              return Array.from(w(this, Ce).values());
            }
            getEditableAnnotation(ee) {
              return w(this, Ce).get(ee);
            }
          }
          ct = new WeakMap(), ie = new WeakMap(), Ce = new WeakMap(), Ue = new WeakSet(), ni = function(ee, K) {
            var Ae;
            const de = ee.firstChild || ee;
            de.id = `${d.AnnotationPrefix}${K}`, this.div.append(ee), (Ae = w(this, ct)) == null || Ae.moveElementInDOM(this.div, ee, de, !1);
          }, Tn = function() {
            if (!w(this, ie))
              return;
            const ee = this.div;
            for (const [K, de] of w(this, ie)) {
              const Ae = ee.querySelector(`[data-annotation-id="${K}"]`);
              if (!Ae)
                continue;
              const {
                firstChild: ke
              } = Ae;
              ke ? ke.nodeName === "CANVAS" ? ke.replaceWith(de) : ke.before(de) : Ae.append(de);
            }
            w(this, ie).clear();
          }, a.AnnotationLayer = F;
        },
        /* 30 */
        /***/
        (c, a) => {
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.ColorConverters = void 0;
          function h(_) {
            return Math.floor(Math.max(0, Math.min(1, _)) * 255).toString(16).padStart(2, "0");
          }
          function d(_) {
            return Math.max(0, Math.min(255, 255 * _));
          }
          class u {
            static CMYK_G([g, $, b, y]) {
              return ["G", 1 - Math.min(1, 0.3 * g + 0.59 * b + 0.11 * $ + y)];
            }
            static G_CMYK([g]) {
              return ["CMYK", 0, 0, 0, 1 - g];
            }
            static G_RGB([g]) {
              return ["RGB", g, g, g];
            }
            static G_rgb([g]) {
              return g = d(g), [g, g, g];
            }
            static G_HTML([g]) {
              const $ = h(g);
              return `#${$}${$}${$}`;
            }
            static RGB_G([g, $, b]) {
              return ["G", 0.3 * g + 0.59 * $ + 0.11 * b];
            }
            static RGB_rgb(g) {
              return g.map(d);
            }
            static RGB_HTML(g) {
              return `#${g.map(h).join("")}`;
            }
            static T_HTML() {
              return "#00000000";
            }
            static T_rgb() {
              return [null];
            }
            static CMYK_RGB([g, $, b, y]) {
              return ["RGB", 1 - Math.min(1, g + y), 1 - Math.min(1, b + y), 1 - Math.min(1, $ + y)];
            }
            static CMYK_rgb([g, $, b, y]) {
              return [d(1 - Math.min(1, g + y)), d(1 - Math.min(1, b + y)), d(1 - Math.min(1, $ + y))];
            }
            static CMYK_HTML(g) {
              const $ = this.CMYK_RGB(g).slice(1);
              return this.RGB_HTML($);
            }
            static RGB_CMYK([g, $, b]) {
              const y = 1 - g, v = 1 - $, E = 1 - b, S = Math.min(y, v, E);
              return ["CMYK", y, v, E, S];
            }
          }
          a.ColorConverters = u;
        },
        /* 31 */
        /***/
        (c, a) => {
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.NullL10n = void 0, a.getL10nFallback = d;
          const h = {
            of_pages: "of {{pagesCount}}",
            page_of_pages: "({{pageNumber}} of {{pagesCount}})",
            document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)",
            document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)",
            document_properties_date_string: "{{date}}, {{time}}",
            document_properties_page_size_unit_inches: "in",
            document_properties_page_size_unit_millimeters: "mm",
            document_properties_page_size_orientation_portrait: "portrait",
            document_properties_page_size_orientation_landscape: "landscape",
            document_properties_page_size_name_a3: "A3",
            document_properties_page_size_name_a4: "A4",
            document_properties_page_size_name_letter: "Letter",
            document_properties_page_size_name_legal: "Legal",
            document_properties_page_size_dimension_string: "{{width}} × {{height}} {{unit}} ({{orientation}})",
            document_properties_page_size_dimension_name_string: "{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})",
            document_properties_linearized_yes: "Yes",
            document_properties_linearized_no: "No",
            additional_layers: "Additional Layers",
            page_landmark: "Page {{page}}",
            thumb_page_title: "Page {{page}}",
            thumb_page_canvas: "Thumbnail of Page {{page}}",
            find_reached_top: "Reached top of document, continued from bottom",
            find_reached_bottom: "Reached end of document, continued from top",
            "find_match_count[one]": "{{current}} of {{total}} match",
            "find_match_count[other]": "{{current}} of {{total}} matches",
            "find_match_count_limit[one]": "More than {{limit}} match",
            "find_match_count_limit[other]": "More than {{limit}} matches",
            find_not_found: "Phrase not found",
            page_scale_width: "Page Width",
            page_scale_fit: "Page Fit",
            page_scale_auto: "Automatic Zoom",
            page_scale_actual: "Actual Size",
            page_scale_percent: "{{scale}}%",
            loading_error: "An error occurred while loading the PDF.",
            invalid_file_error: "Invalid or corrupted PDF file.",
            missing_file_error: "Missing PDF file.",
            unexpected_response_error: "Unexpected server response.",
            rendering_error: "An error occurred while rendering the page.",
            annotation_date_string: "{{date}}, {{time}}",
            printing_not_supported: "Warning: Printing is not fully supported by this browser.",
            printing_not_ready: "Warning: The PDF is not fully loaded for printing.",
            web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts.",
            free_text2_default_content: "Start typing…",
            editor_free_text2_aria_label: "Text Editor",
            editor_ink2_aria_label: "Draw Editor",
            editor_ink_canvas_aria_label: "User-created image",
            editor_alt_text_button_label: "Alt text",
            editor_alt_text_edit_button_label: "Edit alt text",
            editor_alt_text_decorative_tooltip: "Marked as decorative"
          };
          h.print_progress_percent = "{{progress}}%";
          function d(g, $) {
            switch (g) {
              case "find_match_count":
                g = `find_match_count[${$.total === 1 ? "one" : "other"}]`;
                break;
              case "find_match_count_limit":
                g = `find_match_count_limit[${$.limit === 1 ? "one" : "other"}]`;
                break;
            }
            return h[g] || "";
          }
          function u(g, $) {
            return $ ? g.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, (b, y) => y in $ ? $[y] : "{{" + y + "}}") : g;
          }
          const _ = {
            async getLanguage() {
              return "en-us";
            },
            async getDirection() {
              return "ltr";
            },
            async get(g, $ = null, b = d(g, $)) {
              return u(b, $);
            },
            async translate(g) {
            }
          };
          a.NullL10n = _;
        },
        /* 32 */
        /***/
        (c, a, h) => {
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.XfaLayer = void 0;
          var d = h(25);
          class u {
            static setupStorage(g, $, b, y, v) {
              const E = y.getValue($, {
                value: null
              });
              switch (b.name) {
                case "textarea":
                  if (E.value !== null && (g.textContent = E.value), v === "print")
                    break;
                  g.addEventListener("input", (S) => {
                    y.setValue($, {
                      value: S.target.value
                    });
                  });
                  break;
                case "input":
                  if (b.attributes.type === "radio" || b.attributes.type === "checkbox") {
                    if (E.value === b.attributes.xfaOn ? g.setAttribute("checked", !0) : E.value === b.attributes.xfaOff && g.removeAttribute("checked"), v === "print")
                      break;
                    g.addEventListener("change", (S) => {
                      y.setValue($, {
                        value: S.target.checked ? S.target.getAttribute("xfaOn") : S.target.getAttribute("xfaOff")
                      });
                    });
                  } else {
                    if (E.value !== null && g.setAttribute("value", E.value), v === "print")
                      break;
                    g.addEventListener("input", (S) => {
                      y.setValue($, {
                        value: S.target.value
                      });
                    });
                  }
                  break;
                case "select":
                  if (E.value !== null) {
                    g.setAttribute("value", E.value);
                    for (const S of b.children)
                      S.attributes.value === E.value ? S.attributes.selected = !0 : S.attributes.hasOwnProperty("selected") && delete S.attributes.selected;
                  }
                  g.addEventListener("input", (S) => {
                    const R = S.target.options, x = R.selectedIndex === -1 ? "" : R[R.selectedIndex].value;
                    y.setValue($, {
                      value: x
                    });
                  });
                  break;
              }
            }
            static setAttributes({
              html: g,
              element: $,
              storage: b = null,
              intent: y,
              linkService: v
            }) {
              const {
                attributes: E
              } = $, S = g instanceof HTMLAnchorElement;
              E.type === "radio" && (E.name = `${E.name}-${y}`);
              for (const [R, x] of Object.entries(E))
                if (x != null)
                  switch (R) {
                    case "class":
                      x.length && g.setAttribute(R, x.join(" "));
                      break;
                    case "dataId":
                      break;
                    case "id":
                      g.setAttribute("data-element-id", x);
                      break;
                    case "style":
                      Object.assign(g.style, x);
                      break;
                    case "textContent":
                      g.textContent = x;
                      break;
                    default:
                      (!S || R !== "href" && R !== "newWindow") && g.setAttribute(R, x);
                  }
              S && v.addLinkAttributes(g, E.href, E.newWindow), b && E.dataId && this.setupStorage(g, E.dataId, $, b);
            }
            static render(g) {
              var H;
              const $ = g.annotationStorage, b = g.linkService, y = g.xfaHtml, v = g.intent || "display", E = document.createElement(y.name);
              y.attributes && this.setAttributes({
                html: E,
                element: y,
                intent: v,
                linkService: b
              });
              const S = [[y, -1, E]], R = g.div;
              if (R.append(E), g.viewport) {
                const T = `matrix(${g.viewport.transform.join(",")})`;
                R.style.transform = T;
              }
              v !== "richText" && R.setAttribute("class", "xfaLayer xfaFont");
              const x = [];
              for (; S.length > 0; ) {
                const [T, C, O] = S.at(-1);
                if (C + 1 === T.children.length) {
                  S.pop();
                  continue;
                }
                const j = T.children[++S.at(-1)[1]];
                if (j === null)
                  continue;
                const {
                  name: B
                } = j;
                if (B === "#text") {
                  const M = document.createTextNode(j.value);
                  x.push(M), O.append(M);
                  continue;
                }
                const D = (H = j == null ? void 0 : j.attributes) != null && H.xmlns ? document.createElementNS(j.attributes.xmlns, B) : document.createElement(B);
                if (O.append(D), j.attributes && this.setAttributes({
                  html: D,
                  element: j,
                  storage: $,
                  intent: v,
                  linkService: b
                }), j.children && j.children.length > 0)
                  S.push([j, -1, D]);
                else if (j.value) {
                  const M = document.createTextNode(j.value);
                  d.XfaText.shouldBuildText(B) && x.push(M), D.append(M);
                }
              }
              for (const T of R.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea"))
                T.setAttribute("readOnly", !0);
              return {
                textDivs: x
              };
            }
            static update(g) {
              const $ = `matrix(${g.viewport.transform.join(",")})`;
              g.div.style.transform = $, g.div.hidden = !1;
            }
          }
          a.XfaLayer = u;
        },
        /* 33 */
        /***/
        (c, a, h) => {
          var y, v, E, S, R, x, H, T, C, O, j, B, D, M, I, ii, si, ri, ai, kn, oi, Pn, li, ci, hi, di, ui, wt, xn, Xt, Yt, Pt, Rn, Kt, G, _i, Mn, fi, pi, Dn, Jt, xt;
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.InkEditor = void 0;
          var d = h(1), u = h(4), _ = h(29), g = h(6), $ = h(5);
          const Fe = class Fe extends u.AnnotationEditor {
            constructor(X) {
              super({
                ...X,
                name: "inkEditor"
              });
              Ee(this, I);
              Ee(this, y, 0);
              Ee(this, v, 0);
              Ee(this, E, this.canvasPointermove.bind(this));
              Ee(this, S, this.canvasPointerleave.bind(this));
              Ee(this, R, this.canvasPointerup.bind(this));
              Ee(this, x, this.canvasPointerdown.bind(this));
              Ee(this, H, new Path2D());
              Ee(this, T, !1);
              Ee(this, C, !1);
              Ee(this, O, !1);
              Ee(this, j, null);
              Ee(this, B, 0);
              Ee(this, D, 0);
              Ee(this, M, null);
              this.color = X.color || null, this.thickness = X.thickness || null, this.opacity = X.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0;
            }
            static initialize(X) {
              u.AnnotationEditor.initialize(X, {
                strings: ["editor_ink_canvas_aria_label", "editor_ink2_aria_label"]
              });
            }
            static updateDefaultParams(X, ne) {
              switch (X) {
                case d.AnnotationEditorParamsType.INK_THICKNESS:
                  Fe._defaultThickness = ne;
                  break;
                case d.AnnotationEditorParamsType.INK_COLOR:
                  Fe._defaultColor = ne;
                  break;
                case d.AnnotationEditorParamsType.INK_OPACITY:
                  Fe._defaultOpacity = ne / 100;
                  break;
              }
            }
            updateParams(X, ne) {
              switch (X) {
                case d.AnnotationEditorParamsType.INK_THICKNESS:
                  _e(this, I, ii).call(this, ne);
                  break;
                case d.AnnotationEditorParamsType.INK_COLOR:
                  _e(this, I, si).call(this, ne);
                  break;
                case d.AnnotationEditorParamsType.INK_OPACITY:
                  _e(this, I, ri).call(this, ne);
                  break;
              }
            }
            static get defaultPropertiesToUpdate() {
              return [[d.AnnotationEditorParamsType.INK_THICKNESS, Fe._defaultThickness], [d.AnnotationEditorParamsType.INK_COLOR, Fe._defaultColor || u.AnnotationEditor._defaultLineColor], [d.AnnotationEditorParamsType.INK_OPACITY, Math.round(Fe._defaultOpacity * 100)]];
            }
            get propertiesToUpdate() {
              return [[d.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || Fe._defaultThickness], [d.AnnotationEditorParamsType.INK_COLOR, this.color || Fe._defaultColor || u.AnnotationEditor._defaultLineColor], [d.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? Fe._defaultOpacity))]];
            }
            rebuild() {
              this.parent && (super.rebuild(), this.div !== null && (this.canvas || (_e(this, I, Xt).call(this), _e(this, I, Yt).call(this)), this.isAttachedToDOM || (this.parent.add(this), _e(this, I, Pt).call(this)), _e(this, I, xt).call(this)));
            }
            remove() {
              this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, w(this, j).disconnect(), Se(this, j, null), super.remove());
            }
            setParent(X) {
              !this.parent && X ? this._uiManager.removeShouldRescale(this) : this.parent && X === null && this._uiManager.addShouldRescale(this), super.setParent(X);
            }
            onScaleChanging() {
              const [X, ne] = this.parentDimensions, te = this.width * X, ye = this.height * ne;
              this.setDimensions(te, ye);
            }
            enableEditMode() {
              w(this, T) || this.canvas === null || (super.enableEditMode(), this._isDraggable = !1, this.canvas.addEventListener("pointerdown", w(this, x)));
            }
            disableEditMode() {
              !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", w(this, x)));
            }
            onceAdded() {
              this._isDraggable = !this.isEmpty();
            }
            isEmpty() {
              return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;
            }
            commit() {
              w(this, T) || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), Se(this, T, !0), this.div.classList.add("disabled"), _e(this, I, xt).call(this, !0), this.makeResizable(), this.parent.addInkEditorIfNeeded(!0), this.moveInDOM(), this.div.focus({
                preventScroll: !0
              }));
            }
            focusin(X) {
              this._focusEventsAllowed && (super.focusin(X), this.enableEditMode());
            }
            canvasPointerdown(X) {
              X.button !== 0 || !this.isInEditMode() || w(this, T) || (this.setInForeground(), X.preventDefault(), X.type !== "mouse" && this.div.focus(), _e(this, I, oi).call(this, X.offsetX, X.offsetY));
            }
            canvasPointermove(X) {
              X.preventDefault(), _e(this, I, Pn).call(this, X.offsetX, X.offsetY);
            }
            canvasPointerup(X) {
              X.preventDefault(), _e(this, I, xn).call(this, X);
            }
            canvasPointerleave(X) {
              _e(this, I, xn).call(this, X);
            }
            get isResizable() {
              return !this.isEmpty() && w(this, T);
            }
            render() {
              if (this.div)
                return this.div;
              let X, ne;
              this.width && (X = this.x, ne = this.y), super.render(), u.AnnotationEditor._l10nPromise.get("editor_ink2_aria_label").then((Ie) => {
                var fe;
                return (fe = this.div) == null ? void 0 : fe.setAttribute("aria-label", Ie);
              });
              const [te, ye, xe, Le] = _e(this, I, ai).call(this);
              if (this.setAt(te, ye, 0, 0), this.setDims(xe, Le), _e(this, I, Xt).call(this), this.width) {
                const [Ie, fe] = this.parentDimensions;
                this.setAspectRatio(this.width * Ie, this.height * fe), this.setAt(X * Ie, ne * fe, this.width * Ie, this.height * fe), Se(this, O, !0), _e(this, I, Pt).call(this), this.setDims(this.width * Ie, this.height * fe), _e(this, I, wt).call(this), this.div.classList.add("disabled");
              } else
                this.div.classList.add("editing"), this.enableEditMode();
              return _e(this, I, Yt).call(this), this.div;
            }
            setDimensions(X, ne) {
              const te = Math.round(X), ye = Math.round(ne);
              if (w(this, B) === te && w(this, D) === ye)
                return;
              Se(this, B, te), Se(this, D, ye), this.canvas.style.visibility = "hidden";
              const [xe, Le] = this.parentDimensions;
              this.width = X / xe, this.height = ne / Le, this.fixAndSetPosition(), w(this, T) && _e(this, I, Rn).call(this, X, ne), _e(this, I, Pt).call(this), _e(this, I, wt).call(this), this.canvas.style.visibility = "visible", this.fixDims();
            }
            static deserialize(X, ne, te) {
              var et, lt, dt;
              if (X instanceof _.InkAnnotationElement)
                return null;
              const ye = super.deserialize(X, ne, te);
              ye.thickness = X.thickness, ye.color = d.Util.makeHexColor(...X.color), ye.opacity = X.opacity;
              const [xe, Le] = ye.pageDimensions, Ie = ye.width * xe, fe = ye.height * Le, He = ye.parentScale, Be = X.thickness / 2;
              Se(ye, T, !0), Se(ye, B, Math.round(Ie)), Se(ye, D, Math.round(fe));
              const {
                paths: st,
                rect: nt,
                rotation: ht
              } = X;
              for (let {
                bezier: De
              } of st) {
                De = _e(et = Fe, G, fi).call(et, De, nt, ht);
                const $e = [];
                ye.paths.push($e);
                let we = He * (De[0] - Be), ze = He * (De[1] - Be);
                for (let ct = 2, ie = De.length; ct < ie; ct += 6) {
                  const Ce = He * (De[ct] - Be), Ue = He * (De[ct + 1] - Be), Ze = He * (De[ct + 2] - Be), Qe = He * (De[ct + 3] - Be), We = He * (De[ct + 4] - Be), ee = He * (De[ct + 5] - Be);
                  $e.push([[we, ze], [Ce, Ue], [Ze, Qe], [We, ee]]), we = We, ze = ee;
                }
                const at = _e(this, G, _i).call(this, $e);
                ye.bezierPath2D.push(at);
              }
              const Ve = _e(lt = ye, I, Dn).call(lt);
              return Se(ye, v, Math.max(u.AnnotationEditor.MIN_SIZE, Ve[2] - Ve[0])), Se(ye, y, Math.max(u.AnnotationEditor.MIN_SIZE, Ve[3] - Ve[1])), _e(dt = ye, I, Rn).call(dt, Ie, fe), ye;
            }
            serialize() {
              if (this.isEmpty())
                return null;
              const X = this.getRect(0, 0), ne = u.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);
              return {
                annotationType: d.AnnotationEditorType.INK,
                color: ne,
                thickness: this.thickness,
                opacity: this.opacity,
                paths: _e(this, I, pi).call(this, this.scaleFactor / this.parentScale, this.translationX, this.translationY, X),
                pageIndex: this.pageIndex,
                rect: X,
                rotation: this.rotation,
                structTreeParentId: this._structTreeParentId
              };
            }
          };
          y = new WeakMap(), v = new WeakMap(), E = new WeakMap(), S = new WeakMap(), R = new WeakMap(), x = new WeakMap(), H = new WeakMap(), T = new WeakMap(), C = new WeakMap(), O = new WeakMap(), j = new WeakMap(), B = new WeakMap(), D = new WeakMap(), M = new WeakMap(), I = new WeakSet(), ii = function(X) {
            const ne = this.thickness;
            this.addCommands({
              cmd: () => {
                this.thickness = X, _e(this, I, xt).call(this);
              },
              undo: () => {
                this.thickness = ne, _e(this, I, xt).call(this);
              },
              mustExec: !0,
              type: d.AnnotationEditorParamsType.INK_THICKNESS,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, si = function(X) {
            const ne = this.color;
            this.addCommands({
              cmd: () => {
                this.color = X, _e(this, I, wt).call(this);
              },
              undo: () => {
                this.color = ne, _e(this, I, wt).call(this);
              },
              mustExec: !0,
              type: d.AnnotationEditorParamsType.INK_COLOR,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, ri = function(X) {
            X /= 100;
            const ne = this.opacity;
            this.addCommands({
              cmd: () => {
                this.opacity = X, _e(this, I, wt).call(this);
              },
              undo: () => {
                this.opacity = ne, _e(this, I, wt).call(this);
              },
              mustExec: !0,
              type: d.AnnotationEditorParamsType.INK_OPACITY,
              overwriteIfSameType: !0,
              keepUndo: !0
            });
          }, ai = function() {
            const {
              parentRotation: X,
              parentDimensions: [ne, te]
            } = this;
            switch (X) {
              case 90:
                return [0, te, te, ne];
              case 180:
                return [ne, te, ne, te];
              case 270:
                return [ne, 0, te, ne];
              default:
                return [0, 0, ne, te];
            }
          }, kn = function() {
            const {
              ctx: X,
              color: ne,
              opacity: te,
              thickness: ye,
              parentScale: xe,
              scaleFactor: Le
            } = this;
            X.lineWidth = ye * xe / Le, X.lineCap = "round", X.lineJoin = "round", X.miterLimit = 10, X.strokeStyle = `${ne}${(0, $.opacityToHex)(te)}`;
          }, oi = function(X, ne) {
            this.canvas.addEventListener("contextmenu", g.noContextMenu), this.canvas.addEventListener("pointerleave", w(this, S)), this.canvas.addEventListener("pointermove", w(this, E)), this.canvas.addEventListener("pointerup", w(this, R)), this.canvas.removeEventListener("pointerdown", w(this, x)), this.isEditing = !0, w(this, O) || (Se(this, O, !0), _e(this, I, Pt).call(this), this.thickness || (this.thickness = Fe._defaultThickness), this.color || (this.color = Fe._defaultColor || u.AnnotationEditor._defaultLineColor), this.opacity ?? (this.opacity = Fe._defaultOpacity)), this.currentPath.push([X, ne]), Se(this, C, !1), _e(this, I, kn).call(this), Se(this, M, () => {
              _e(this, I, hi).call(this), w(this, M) && window.requestAnimationFrame(w(this, M));
            }), window.requestAnimationFrame(w(this, M));
          }, Pn = function(X, ne) {
            const [te, ye] = this.currentPath.at(-1);
            if (this.currentPath.length > 1 && X === te && ne === ye)
              return;
            const xe = this.currentPath;
            let Le = w(this, H);
            if (xe.push([X, ne]), Se(this, C, !0), xe.length <= 2) {
              Le.moveTo(...xe[0]), Le.lineTo(X, ne);
              return;
            }
            xe.length === 3 && (Se(this, H, Le = new Path2D()), Le.moveTo(...xe[0])), _e(this, I, di).call(this, Le, ...xe.at(-3), ...xe.at(-2), X, ne);
          }, li = function() {
            if (this.currentPath.length === 0)
              return;
            const X = this.currentPath.at(-1);
            w(this, H).lineTo(...X);
          }, ci = function(X, ne) {
            Se(this, M, null), X = Math.min(Math.max(X, 0), this.canvas.width), ne = Math.min(Math.max(ne, 0), this.canvas.height), _e(this, I, Pn).call(this, X, ne), _e(this, I, li).call(this);
            let te;
            if (this.currentPath.length !== 1)
              te = _e(this, I, ui).call(this);
            else {
              const fe = [X, ne];
              te = [[fe, fe.slice(), fe.slice(), fe]];
            }
            const ye = w(this, H), xe = this.currentPath;
            this.currentPath = [], Se(this, H, new Path2D());
            const Le = () => {
              this.allRawPaths.push(xe), this.paths.push(te), this.bezierPath2D.push(ye), this.rebuild();
            }, Ie = () => {
              this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (_e(this, I, Xt).call(this), _e(this, I, Yt).call(this)), _e(this, I, xt).call(this));
            };
            this.addCommands({
              cmd: Le,
              undo: Ie,
              mustExec: !0
            });
          }, hi = function() {
            if (!w(this, C))
              return;
            Se(this, C, !1);
            const X = Math.ceil(this.thickness * this.parentScale), ne = this.currentPath.slice(-3), te = ne.map((Le) => Le[0]), ye = ne.map((Le) => Le[1]);
            Math.min(...te) - X, Math.max(...te) + X, Math.min(...ye) - X, Math.max(...ye) + X;
            const {
              ctx: xe
            } = this;
            xe.save(), xe.clearRect(0, 0, this.canvas.width, this.canvas.height);
            for (const Le of this.bezierPath2D)
              xe.stroke(Le);
            xe.stroke(w(this, H)), xe.restore();
          }, di = function(X, ne, te, ye, xe, Le, Ie) {
            const fe = (ne + ye) / 2, He = (te + xe) / 2, Be = (ye + Le) / 2, st = (xe + Ie) / 2;
            X.bezierCurveTo(fe + 2 * (ye - fe) / 3, He + 2 * (xe - He) / 3, Be + 2 * (ye - Be) / 3, st + 2 * (xe - st) / 3, Be, st);
          }, ui = function() {
            const X = this.currentPath;
            if (X.length <= 2)
              return [[X[0], X[0], X.at(-1), X.at(-1)]];
            const ne = [];
            let te, [ye, xe] = X[0];
            for (te = 1; te < X.length - 2; te++) {
              const [nt, ht] = X[te], [Ve, et] = X[te + 1], lt = (nt + Ve) / 2, dt = (ht + et) / 2, De = [ye + 2 * (nt - ye) / 3, xe + 2 * (ht - xe) / 3], $e = [lt + 2 * (nt - lt) / 3, dt + 2 * (ht - dt) / 3];
              ne.push([[ye, xe], De, $e, [lt, dt]]), [ye, xe] = [lt, dt];
            }
            const [Le, Ie] = X[te], [fe, He] = X[te + 1], Be = [ye + 2 * (Le - ye) / 3, xe + 2 * (Ie - xe) / 3], st = [fe + 2 * (Le - fe) / 3, He + 2 * (Ie - He) / 3];
            return ne.push([[ye, xe], Be, st, [fe, He]]), ne;
          }, wt = function() {
            if (this.isEmpty()) {
              _e(this, I, Kt).call(this);
              return;
            }
            _e(this, I, kn).call(this);
            const {
              canvas: X,
              ctx: ne
            } = this;
            ne.setTransform(1, 0, 0, 1, 0, 0), ne.clearRect(0, 0, X.width, X.height), _e(this, I, Kt).call(this);
            for (const te of this.bezierPath2D)
              ne.stroke(te);
          }, xn = function(X) {
            this.canvas.removeEventListener("pointerleave", w(this, S)), this.canvas.removeEventListener("pointermove", w(this, E)), this.canvas.removeEventListener("pointerup", w(this, R)), this.canvas.addEventListener("pointerdown", w(this, x)), setTimeout(() => {
              this.canvas.removeEventListener("contextmenu", g.noContextMenu);
            }, 10), _e(this, I, ci).call(this, X.offsetX, X.offsetY), this.addToAnnotationStorage(), this.setInBackground();
          }, Xt = function() {
            this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", u.AnnotationEditor._l10nPromise.get("editor_ink_canvas_aria_label").then((X) => {
              var ne;
              return (ne = this.canvas) == null ? void 0 : ne.setAttribute("aria-label", X);
            }), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d");
          }, Yt = function() {
            Se(this, j, new ResizeObserver((X) => {
              const ne = X[0].contentRect;
              ne.width && ne.height && this.setDimensions(ne.width, ne.height);
            })), w(this, j).observe(this.div);
          }, Pt = function() {
            if (!w(this, O))
              return;
            const [X, ne] = this.parentDimensions;
            this.canvas.width = Math.ceil(this.width * X), this.canvas.height = Math.ceil(this.height * ne), _e(this, I, Kt).call(this);
          }, Rn = function(X, ne) {
            const te = _e(this, I, Jt).call(this), ye = (X - te) / w(this, v), xe = (ne - te) / w(this, y);
            this.scaleFactor = Math.min(ye, xe);
          }, Kt = function() {
            const X = _e(this, I, Jt).call(this) / 2;
            this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + X, this.translationY * this.scaleFactor + X);
          }, G = new WeakSet(), _i = function(X) {
            const ne = new Path2D();
            for (let te = 0, ye = X.length; te < ye; te++) {
              const [xe, Le, Ie, fe] = X[te];
              te === 0 && ne.moveTo(...xe), ne.bezierCurveTo(Le[0], Le[1], Ie[0], Ie[1], fe[0], fe[1]);
            }
            return ne;
          }, Mn = function(X, ne, te) {
            const [ye, xe, Le, Ie] = ne;
            switch (te) {
              case 0:
                for (let fe = 0, He = X.length; fe < He; fe += 2)
                  X[fe] += ye, X[fe + 1] = Ie - X[fe + 1];
                break;
              case 90:
                for (let fe = 0, He = X.length; fe < He; fe += 2) {
                  const Be = X[fe];
                  X[fe] = X[fe + 1] + ye, X[fe + 1] = Be + xe;
                }
                break;
              case 180:
                for (let fe = 0, He = X.length; fe < He; fe += 2)
                  X[fe] = Le - X[fe], X[fe + 1] += xe;
                break;
              case 270:
                for (let fe = 0, He = X.length; fe < He; fe += 2) {
                  const Be = X[fe];
                  X[fe] = Le - X[fe + 1], X[fe + 1] = Ie - Be;
                }
                break;
              default:
                throw new Error("Invalid rotation");
            }
            return X;
          }, fi = function(X, ne, te) {
            const [ye, xe, Le, Ie] = ne;
            switch (te) {
              case 0:
                for (let fe = 0, He = X.length; fe < He; fe += 2)
                  X[fe] -= ye, X[fe + 1] = Ie - X[fe + 1];
                break;
              case 90:
                for (let fe = 0, He = X.length; fe < He; fe += 2) {
                  const Be = X[fe];
                  X[fe] = X[fe + 1] - xe, X[fe + 1] = Be - ye;
                }
                break;
              case 180:
                for (let fe = 0, He = X.length; fe < He; fe += 2)
                  X[fe] = Le - X[fe], X[fe + 1] -= xe;
                break;
              case 270:
                for (let fe = 0, He = X.length; fe < He; fe += 2) {
                  const Be = X[fe];
                  X[fe] = Ie - X[fe + 1], X[fe + 1] = Le - Be;
                }
                break;
              default:
                throw new Error("Invalid rotation");
            }
            return X;
          }, pi = function(X, ne, te, ye) {
            var He, Be;
            const xe = [], Le = this.thickness / 2, Ie = X * ne + Le, fe = X * te + Le;
            for (const st of this.paths) {
              const nt = [], ht = [];
              for (let Ve = 0, et = st.length; Ve < et; Ve++) {
                const [lt, dt, De, $e] = st[Ve], we = X * lt[0] + Ie, ze = X * lt[1] + fe, at = X * dt[0] + Ie, ct = X * dt[1] + fe, ie = X * De[0] + Ie, Ce = X * De[1] + fe, Ue = X * $e[0] + Ie, Ze = X * $e[1] + fe;
                Ve === 0 && (nt.push(we, ze), ht.push(we, ze)), nt.push(at, ct, ie, Ce, Ue, Ze), ht.push(at, ct), Ve === et - 1 && ht.push(Ue, Ze);
              }
              xe.push({
                bezier: _e(He = Fe, G, Mn).call(He, nt, ye, this.rotation),
                points: _e(Be = Fe, G, Mn).call(Be, ht, ye, this.rotation)
              });
            }
            return xe;
          }, Dn = function() {
            let X = 1 / 0, ne = -1 / 0, te = 1 / 0, ye = -1 / 0;
            for (const xe of this.paths)
              for (const [Le, Ie, fe, He] of xe) {
                const Be = d.Util.bezierBoundingBox(...Le, ...Ie, ...fe, ...He);
                X = Math.min(X, Be[0]), te = Math.min(te, Be[1]), ne = Math.max(ne, Be[2]), ye = Math.max(ye, Be[3]);
              }
            return [X, te, ne, ye];
          }, Jt = function() {
            return w(this, T) ? Math.ceil(this.thickness * this.parentScale) : 0;
          }, xt = function(X = !1) {
            if (this.isEmpty())
              return;
            if (!w(this, T)) {
              _e(this, I, wt).call(this);
              return;
            }
            const ne = _e(this, I, Dn).call(this), te = _e(this, I, Jt).call(this);
            Se(this, v, Math.max(u.AnnotationEditor.MIN_SIZE, ne[2] - ne[0])), Se(this, y, Math.max(u.AnnotationEditor.MIN_SIZE, ne[3] - ne[1]));
            const ye = Math.ceil(te + w(this, v) * this.scaleFactor), xe = Math.ceil(te + w(this, y) * this.scaleFactor), [Le, Ie] = this.parentDimensions;
            this.width = ye / Le, this.height = xe / Ie, this.setAspectRatio(ye, xe);
            const fe = this.translationX, He = this.translationY;
            this.translationX = -ne[0], this.translationY = -ne[1], _e(this, I, Pt).call(this), _e(this, I, wt).call(this), Se(this, B, ye), Se(this, D, xe), this.setDims(ye, xe);
            const Be = X ? te / this.scaleFactor / 2 : 0;
            this.translate(fe - this.translationX - Be, He - this.translationY - Be);
          }, Ee(Fe, G), _t(Fe, "_defaultColor", null), _t(Fe, "_defaultOpacity", 1), _t(Fe, "_defaultThickness", 1), _t(Fe, "_type", "ink");
          let b = Fe;
          a.InkEditor = b;
        },
        /* 34 */
        /***/
        (c, a, h) => {
          var b, y, v, E, S, R, x, H, T, C, O, Nt, Bt, Zt, In, mi, gi, On, Qt, vi;
          Object.defineProperty(a, "__esModule", {
            value: !0
          }), a.StampEditor = void 0;
          var d = h(1), u = h(4), _ = h(6), g = h(29);
          const W = class W extends u.AnnotationEditor {
            constructor(se) {
              super({
                ...se,
                name: "stampEditor"
              });
              Ee(this, O);
              Ee(this, b, null);
              Ee(this, y, null);
              Ee(this, v, null);
              Ee(this, E, null);
              Ee(this, S, null);
              Ee(this, R, null);
              Ee(this, x, null);
              Ee(this, H, null);
              Ee(this, T, !1);
              Ee(this, C, !1);
              Se(this, E, se.bitmapUrl), Se(this, S, se.bitmapFile);
            }
            static initialize(se) {
              u.AnnotationEditor.initialize(se);
            }
            static get supportedTypes() {
              const se = ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"];
              return (0, d.shadow)(this, "supportedTypes", se.map((ce) => `image/${ce}`));
            }
            static get supportedTypesStr() {
              return (0, d.shadow)(this, "supportedTypesStr", this.supportedTypes.join(","));
            }
            static isHandlingMimeForPasting(se) {
              return this.supportedTypes.includes(se);
            }
            static paste(se, ce) {
              ce.pasteEditor(d.AnnotationEditorType.STAMP, {
                bitmapFile: se.getAsFile()
              });
            }
            remove() {
              var se, ce;
              w(this, y) && (Se(this, b, null), this._uiManager.imageManager.deleteId(w(this, y)), (se = w(this, R)) == null || se.remove(), Se(this, R, null), (ce = w(this, x)) == null || ce.disconnect(), Se(this, x, null)), super.remove();
            }
            rebuild() {
              if (!this.parent) {
                w(this, y) && _e(this, O, Zt).call(this);
                return;
              }
              super.rebuild(), this.div !== null && (w(this, y) && _e(this, O, Zt).call(this), this.isAttachedToDOM || this.parent.add(this));
            }
            onceAdded() {
              this._isDraggable = !0, this.div.focus();
            }
            isEmpty() {
              return !(w(this, v) || w(this, b) || w(this, E) || w(this, S));
            }
            get isResizable() {
              return !0;
            }
            render() {
              if (this.div)
                return this.div;
              let se, ce;
              if (this.width && (se = this.x, ce = this.y), super.render(), this.div.hidden = !0, w(this, b) ? _e(this, O, In).call(this) : _e(this, O, Zt).call(this), this.width) {
                const [oe, ge] = this.parentDimensions;
                this.setAt(se * oe, ce * ge, this.width * oe, this.height * ge);
              }
              return this.div;
            }
            static deserialize(se, ce, oe) {
              if (se instanceof g.StampAnnotationElement)
                return null;
              const ge = super.deserialize(se, ce, oe), {
                rect: J,
                bitmapUrl: ae,
                bitmapId: le,
                isSvg: z,
                accessibilityData: A
              } = se;
              le && oe.imageManager.isValidId(le) ? Se(ge, y, le) : Se(ge, E, ae), Se(ge, T, z);
              const [F, U] = ge.pageDimensions;
              return ge.width = (J[2] - J[0]) / F, ge.height = (J[3] - J[1]) / U, A && (ge.altTextData = A), ge;
            }
            serialize(se = !1, ce = null) {
              if (this.isEmpty())
                return null;
              const oe = {
                annotationType: d.AnnotationEditorType.STAMP,
                bitmapId: w(this, y),
                pageIndex: this.pageIndex,
                rect: this.getRect(0, 0),
                rotation: this.rotation,
                isSvg: w(this, T),
                structTreeParentId: this._structTreeParentId
              };
              if (se)
                return oe.bitmapUrl = _e(this, O, Qt).call(this, !0), oe.accessibilityData = this.altTextData, oe;
              const {
                decorative: ge,
                altText: J
              } = this.altTextData;
              if (!ge && J && (oe.accessibilityData = {
                type: "Figure",
                alt: J
              }), ce === null)
                return oe;
              ce.stamps || (ce.stamps = /* @__PURE__ */ new Map());
              const ae = w(this, T) ? (oe.rect[2] - oe.rect[0]) * (oe.rect[3] - oe.rect[1]) : null;
              if (!ce.stamps.has(w(this, y)))
                ce.stamps.set(w(this, y), {
                  area: ae,
                  serialized: oe
                }), oe.bitmap = _e(this, O, Qt).call(this, !1);
              else if (w(this, T)) {
                const le = ce.stamps.get(w(this, y));
                ae > le.area && (le.area = ae, le.serialized.bitmap.close(), le.serialized.bitmap = _e(this, O, Qt).call(this, !1));
              }
              return oe;
            }
          };
          b = new WeakMap(), y = new WeakMap(), v = new WeakMap(), E = new WeakMap(), S = new WeakMap(), R = new WeakMap(), x = new WeakMap(), H = new WeakMap(), T = new WeakMap(), C = new WeakMap(), O = new WeakSet(), Nt = function(se, ce = !1) {
            if (!se) {
              this.remove();
              return;
            }
            Se(this, b, se.bitmap), ce || (Se(this, y, se.id), Se(this, T, se.isSvg)), _e(this, O, In).call(this);
          }, Bt = function() {
            Se(this, v, null), this._uiManager.enableWaiting(!1), w(this, R) && this.div.focus();
          }, Zt = function() {
            if (w(this, y)) {
              this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(w(this, y)).then((ce) => _e(this, O, Nt).call(this, ce, !0)).finally(() => _e(this, O, Bt).call(this));
              return;
            }
            if (w(this, E)) {
              const ce = w(this, E);
              Se(this, E, null), this._uiManager.enableWaiting(!0), Se(this, v, this._uiManager.imageManager.getFromUrl(ce).then((oe) => _e(this, O, Nt).call(this, oe)).finally(() => _e(this, O, Bt).call(this)));
              return;
            }
            if (w(this, S)) {
              const ce = w(this, S);
              Se(this, S, null), this._uiManager.enableWaiting(!0), Se(this, v, this._uiManager.imageManager.getFromFile(ce).then((oe) => _e(this, O, Nt).call(this, oe)).finally(() => _e(this, O, Bt).call(this)));
              return;
            }
            const se = document.createElement("input");
            se.type = "file", se.accept = W.supportedTypesStr, Se(this, v, new Promise((ce) => {
              se.addEventListener("change", async () => {
                if (!se.files || se.files.length === 0)
                  this.remove();
                else {
                  this._uiManager.enableWaiting(!0);
                  const oe = await this._uiManager.imageManager.getFromFile(se.files[0]);
                  _e(this, O, Nt).call(this, oe);
                }
                ce();
              }), se.addEventListener("cancel", () => {
                this.remove(), ce();
              });
            }).finally(() => _e(this, O, Bt).call(this))), se.click();
          }, In = function() {
            const {
              div: se
            } = this;
            let {
              width: ce,
              height: oe
            } = w(this, b);
            const [ge, J] = this.pageDimensions, ae = 0.75;
            if (this.width)
              ce = this.width * ge, oe = this.height * J;
            else if (ce > ae * ge || oe > ae * J) {
              const F = Math.min(ae * ge / ce, ae * J / oe);
              ce *= F, oe *= F;
            }
            const [le, z] = this.parentDimensions;
            this.setDims(ce * le / ge, oe * z / J), this._uiManager.enableWaiting(!1);
            const A = Se(this, R, document.createElement("canvas"));
            se.append(A), se.hidden = !1, _e(this, O, On).call(this, ce, oe), _e(this, O, vi).call(this), w(this, C) || (this.parent.addUndoableEditor(this), Se(this, C, !0)), this._uiManager._eventBus.dispatch("reporttelemetry", {
              source: this,
              details: {
                type: "editing",
                subtype: this.editorType,
                data: {
                  action: "inserted_image"
                }
              }
            }), this.addAltTextButton();
          }, mi = function(se, ce) {
            var ae;
            const [oe, ge] = this.parentDimensions;
            this.width = se / oe, this.height = ce / ge, this.setDims(se, ce), (ae = this._initialOptions) != null && ae.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, w(this, H) !== null && clearTimeout(w(this, H)), Se(this, H, setTimeout(() => {
              Se(this, H, null), _e(this, O, On).call(this, se, ce);
            }, 200));
          }, gi = function(se, ce) {
            const {
              width: oe,
              height: ge
            } = w(this, b);
            let J = oe, ae = ge, le = w(this, b);
            for (; J > 2 * se || ae > 2 * ce; ) {
              const z = J, A = ae;
              J > 2 * se && (J = J >= 16384 ? Math.floor(J / 2) - 1 : Math.ceil(J / 2)), ae > 2 * ce && (ae = ae >= 16384 ? Math.floor(ae / 2) - 1 : Math.ceil(ae / 2));
              const F = new OffscreenCanvas(J, ae);
              F.getContext("2d").drawImage(le, 0, 0, z, A, 0, 0, J, ae), le = F.transferToImageBitmap();
            }
            return le;
          }, On = function(se, ce) {
            se = Math.ceil(se), ce = Math.ceil(ce);
            const oe = w(this, R);
            if (!oe || oe.width === se && oe.height === ce)
              return;
            oe.width = se, oe.height = ce;
            const ge = w(this, T) ? w(this, b) : _e(this, O, gi).call(this, se, ce), J = oe.getContext("2d");
            J.filter = this._uiManager.hcmFilter, J.drawImage(ge, 0, 0, ge.width, ge.height, 0, 0, se, ce);
          }, Qt = function(se) {
            if (se) {
              if (w(this, T)) {
                const ge = this._uiManager.imageManager.getSvgUrl(w(this, y));
                if (ge)
                  return ge;
              }
              const ce = document.createElement("canvas");
              return {
                width: ce.width,
                height: ce.height
              } = w(this, b), ce.getContext("2d").drawImage(w(this, b), 0, 0), ce.toDataURL();
            }
            if (w(this, T)) {
              const [ce, oe] = this.pageDimensions, ge = Math.round(this.width * ce * _.PixelsPerInch.PDF_TO_CSS_UNITS), J = Math.round(this.height * oe * _.PixelsPerInch.PDF_TO_CSS_UNITS), ae = new OffscreenCanvas(ge, J);
              return ae.getContext("2d").drawImage(w(this, b), 0, 0, w(this, b).width, w(this, b).height, 0, 0, ge, J), ae.transferToImageBitmap();
            }
            return structuredClone(w(this, b));
          }, vi = function() {
            Se(this, x, new ResizeObserver((se) => {
              const ce = se[0].contentRect;
              ce.width && ce.height && _e(this, O, mi).call(this, ce.width, ce.height);
            })), w(this, x).observe(this.div);
          }, _t(W, "_type", "stamp");
          let $ = W;
          a.StampEditor = $;
        }
      ], __webpack_module_cache__ = {};
      function __w_pdfjs_require__(c) {
        var a = __webpack_module_cache__[c];
        if (a !== void 0)
          return a.exports;
        var h = __webpack_module_cache__[c] = {
          /******/
          // no module.id needed
          /******/
          // no module.loaded needed
          /******/
          exports: {}
          /******/
        };
        return __webpack_modules__[c](h, h.exports, __w_pdfjs_require__), h.exports;
      }
      var __webpack_exports__ = {};
      return (() => {
        var c = __webpack_exports__;
        Object.defineProperty(c, "__esModule", {
          value: !0
        }), Object.defineProperty(c, "AbortException", {
          enumerable: !0,
          get: function() {
            return a.AbortException;
          }
        }), Object.defineProperty(c, "AnnotationEditorLayer", {
          enumerable: !0,
          get: function() {
            return _.AnnotationEditorLayer;
          }
        }), Object.defineProperty(c, "AnnotationEditorParamsType", {
          enumerable: !0,
          get: function() {
            return a.AnnotationEditorParamsType;
          }
        }), Object.defineProperty(c, "AnnotationEditorType", {
          enumerable: !0,
          get: function() {
            return a.AnnotationEditorType;
          }
        }), Object.defineProperty(c, "AnnotationEditorUIManager", {
          enumerable: !0,
          get: function() {
            return g.AnnotationEditorUIManager;
          }
        }), Object.defineProperty(c, "AnnotationLayer", {
          enumerable: !0,
          get: function() {
            return $.AnnotationLayer;
          }
        }), Object.defineProperty(c, "AnnotationMode", {
          enumerable: !0,
          get: function() {
            return a.AnnotationMode;
          }
        }), Object.defineProperty(c, "CMapCompressionType", {
          enumerable: !0,
          get: function() {
            return a.CMapCompressionType;
          }
        }), Object.defineProperty(c, "DOMSVGFactory", {
          enumerable: !0,
          get: function() {
            return d.DOMSVGFactory;
          }
        }), Object.defineProperty(c, "FeatureTest", {
          enumerable: !0,
          get: function() {
            return a.FeatureTest;
          }
        }), Object.defineProperty(c, "GlobalWorkerOptions", {
          enumerable: !0,
          get: function() {
            return b.GlobalWorkerOptions;
          }
        }), Object.defineProperty(c, "ImageKind", {
          enumerable: !0,
          get: function() {
            return a.ImageKind;
          }
        }), Object.defineProperty(c, "InvalidPDFException", {
          enumerable: !0,
          get: function() {
            return a.InvalidPDFException;
          }
        }), Object.defineProperty(c, "MissingPDFException", {
          enumerable: !0,
          get: function() {
            return a.MissingPDFException;
          }
        }), Object.defineProperty(c, "OPS", {
          enumerable: !0,
          get: function() {
            return a.OPS;
          }
        }), Object.defineProperty(c, "PDFDataRangeTransport", {
          enumerable: !0,
          get: function() {
            return h.PDFDataRangeTransport;
          }
        }), Object.defineProperty(c, "PDFDateString", {
          enumerable: !0,
          get: function() {
            return d.PDFDateString;
          }
        }), Object.defineProperty(c, "PDFWorker", {
          enumerable: !0,
          get: function() {
            return h.PDFWorker;
          }
        }), Object.defineProperty(c, "PasswordResponses", {
          enumerable: !0,
          get: function() {
            return a.PasswordResponses;
          }
        }), Object.defineProperty(c, "PermissionFlag", {
          enumerable: !0,
          get: function() {
            return a.PermissionFlag;
          }
        }), Object.defineProperty(c, "PixelsPerInch", {
          enumerable: !0,
          get: function() {
            return d.PixelsPerInch;
          }
        }), Object.defineProperty(c, "PromiseCapability", {
          enumerable: !0,
          get: function() {
            return a.PromiseCapability;
          }
        }), Object.defineProperty(c, "RenderingCancelledException", {
          enumerable: !0,
          get: function() {
            return d.RenderingCancelledException;
          }
        }), Object.defineProperty(c, "SVGGraphics", {
          enumerable: !0,
          get: function() {
            return h.SVGGraphics;
          }
        }), Object.defineProperty(c, "UnexpectedResponseException", {
          enumerable: !0,
          get: function() {
            return a.UnexpectedResponseException;
          }
        }), Object.defineProperty(c, "Util", {
          enumerable: !0,
          get: function() {
            return a.Util;
          }
        }), Object.defineProperty(c, "VerbosityLevel", {
          enumerable: !0,
          get: function() {
            return a.VerbosityLevel;
          }
        }), Object.defineProperty(c, "XfaLayer", {
          enumerable: !0,
          get: function() {
            return y.XfaLayer;
          }
        }), Object.defineProperty(c, "build", {
          enumerable: !0,
          get: function() {
            return h.build;
          }
        }), Object.defineProperty(c, "createValidAbsoluteUrl", {
          enumerable: !0,
          get: function() {
            return a.createValidAbsoluteUrl;
          }
        }), Object.defineProperty(c, "getDocument", {
          enumerable: !0,
          get: function() {
            return h.getDocument;
          }
        }), Object.defineProperty(c, "getFilenameFromUrl", {
          enumerable: !0,
          get: function() {
            return d.getFilenameFromUrl;
          }
        }), Object.defineProperty(c, "getPdfFilenameFromUrl", {
          enumerable: !0,
          get: function() {
            return d.getPdfFilenameFromUrl;
          }
        }), Object.defineProperty(c, "getXfaPageViewport", {
          enumerable: !0,
          get: function() {
            return d.getXfaPageViewport;
          }
        }), Object.defineProperty(c, "isDataScheme", {
          enumerable: !0,
          get: function() {
            return d.isDataScheme;
          }
        }), Object.defineProperty(c, "isPdfFile", {
          enumerable: !0,
          get: function() {
            return d.isPdfFile;
          }
        }), Object.defineProperty(c, "loadScript", {
          enumerable: !0,
          get: function() {
            return d.loadScript;
          }
        }), Object.defineProperty(c, "noContextMenu", {
          enumerable: !0,
          get: function() {
            return d.noContextMenu;
          }
        }), Object.defineProperty(c, "normalizeUnicode", {
          enumerable: !0,
          get: function() {
            return a.normalizeUnicode;
          }
        }), Object.defineProperty(c, "renderTextLayer", {
          enumerable: !0,
          get: function() {
            return u.renderTextLayer;
          }
        }), Object.defineProperty(c, "setLayerDimensions", {
          enumerable: !0,
          get: function() {
            return d.setLayerDimensions;
          }
        }), Object.defineProperty(c, "shadow", {
          enumerable: !0,
          get: function() {
            return a.shadow;
          }
        }), Object.defineProperty(c, "updateTextLayer", {
          enumerable: !0,
          get: function() {
            return u.updateTextLayer;
          }
        }), Object.defineProperty(c, "version", {
          enumerable: !0,
          get: function() {
            return h.version;
          }
        });
        var a = __w_pdfjs_require__(1), h = __w_pdfjs_require__(2), d = __w_pdfjs_require__(6), u = __w_pdfjs_require__(26), _ = __w_pdfjs_require__(27), g = __w_pdfjs_require__(5), $ = __w_pdfjs_require__(29), b = __w_pdfjs_require__(14), y = __w_pdfjs_require__(32);
      })(), __webpack_exports__;
    })()
  ));
})(pdf);
var pdfExports = pdf.exports;
function isMobile() {
  return window.innerWidth <= 576;
}
pdfExports.GlobalWorkerOptions.workerSrc = "https://g.alicdn.com/code/lib/pdf.js/3.11.174/pdf.worker.min.js";
const Pdf = ({
  src: c,
  height: a,
  width: h = "100%"
}) => {
  const [d, u] = useState(0), [_, g] = useState(0), $ = useRef(0), b = useRef(null), y = useRef(null), v = useRef(null), [E, S] = useState(null);
  function R() {
    E == null || E.getPage(d).then((H) => {
      var L;
      (L = v == null ? void 0 : v.current) == null || L.cancel();
      const T = y.current, C = b.current, O = T == null ? void 0 : T.getContext("2d");
      if (!C || !T || !O)
        return;
      const j = C.getBoundingClientRect().width;
      O.clearRect(0, 0, T.width, T.height);
      let B = H.getViewport({
        scale: 1
      });
      const D = j / B.width;
      let M = D;
      a ? M = Math.min(a / B.height, D) : (isMobile() || (M = D * 0.6), C.style.height = `${B.height * M}px`), B = H.getViewport({
        scale: M
      });
      const I = {
        canvasContext: O,
        viewport: B
      };
      T.width = B.width, T.height = B.height;
      const P = H.render(I);
      v.current = P, P.promise.catch(() => {
      });
    });
  }
  async function x() {
    if (!c)
      return;
    E == null || E.destroy();
    const T = await pdfExports.getDocument(c).promise;
    u(1), g(T.numPages), S(T);
  }
  return useEffect(() => {
    x();
  }, [c]), useEffect(() => {
    const H = b.current;
    if (!H)
      return;
    $.current = H.getBoundingClientRect().width;
    let T;
    const C = new ResizeObserver((O) => {
      const j = O[0];
      if (!j)
        return;
      const B = j.contentRect;
      B.width !== $.current && (T && clearTimeout(T), $.current = B.width, T = setTimeout(() => {
        R();
      }, 500));
    });
    return C.observe(H), R(), () => {
      C.disconnect();
    };
  }, [E, d, _]), /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
    children: !!_ && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
      className: "ms-file-view-pdf",
      children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
        ref: b,
        className: "ms-file-view-pdf-canvas",
        style: {
          width: h,
          height: a
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("canvas", {
          ref: y
        })
      }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", {
        className: "ms-file-view-pdf-button-row",
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, {
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CaretLeftOutlined, {}),
          disabled: d <= 1,
          onClick: () => {
            d <= 1 || (u(d - 1), R());
          }
        }), /* @__PURE__ */ jsxRuntimeExports.jsxs("span", {
          className: "ms-file-view-pdf-page-count",
          children: [d, " / ", _]
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(Button$1, {
          disabled: d >= _,
          icon: /* @__PURE__ */ jsxRuntimeExports.jsx(CaretRightOutlined, {}),
          onClick: () => {
            d >= _ || (u(d + 1), R());
          }
        })]
      })]
    })
  });
}, Image$1 = ({
  preview: c = !0,
  ...a
}) => {
  const h = usePreview();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
    style: {
      width: "100%"
    },
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image$3, {
      preview: c ? h : !1,
      style: {
        maxWidth: "100%",
        width: "auto"
      },
      ...a
    })
  });
}, Video = (c) => /* @__PURE__ */ jsxRuntimeExports.jsx("video", {
  style: {
    maxWidth: "100%"
  },
  preload: "auto",
  controls: !0,
  ...c,
  children: /* @__PURE__ */ jsxRuntimeExports.jsx("track", {
    kind: "captions"
  })
}), Audio = (c) => /* @__PURE__ */ jsxRuntimeExports.jsx("audio", {
  preload: "metadata",
  controls: !0,
  ...c,
  style: {
    maxWidth: "100%",
    ...c.style
  }
}), Link = (c) => {
  const {
    filename: a,
    href: h,
    icon: d = /* @__PURE__ */ jsxRuntimeExports.jsx(FileOutlined, {}),
    disabled: u,
    ..._
  } = c;
  return u ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      style: {
        marginRight: 2
      },
      children: d
    }), a || h]
  }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("a", {
    ..._,
    target: "_blank",
    rel: "noreferrer",
    href: h,
    download: a,
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      style: {
        marginRight: 2
      },
      children: d
    }), a || h]
  });
}, FileView = (c) => {
  const {
    url: a,
    type: h,
    ...d
  } = c;
  switch (h) {
    case "image":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Image$1, {
        src: a,
        ...d
      });
    case "video":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Video, {
        src: a,
        ...d
      });
    case "audio":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Audio, {
        src: a,
        ...d
      });
    case "pdf":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Pdf, {
        src: a,
        ...d
      });
    case "link":
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Link, {
        href: a,
        ...d
      });
  }
};
var isMergeableObject = function c(a) {
  return isNonNullObject(a) && !isSpecial(a);
};
function isNonNullObject(c) {
  return !!c && typeof c == "object";
}
function isSpecial(c) {
  var a = Object.prototype.toString.call(c);
  return a === "[object RegExp]" || a === "[object Date]" || isReactElement(c);
}
var canUseSymbol = typeof Symbol == "function" && Symbol.for, REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(c) {
  return c.$$typeof === REACT_ELEMENT_TYPE;
}
function emptyTarget(c) {
  return Array.isArray(c) ? [] : {};
}
function cloneUnlessOtherwiseSpecified(c, a) {
  return a.clone !== !1 && a.isMergeableObject(c) ? deepmerge(emptyTarget(c), c, a) : c;
}
function defaultArrayMerge(c, a, h) {
  return c.concat(a).map(function(d) {
    return cloneUnlessOtherwiseSpecified(d, h);
  });
}
function getMergeFunction(c, a) {
  if (!a.customMerge)
    return deepmerge;
  var h = a.customMerge(c);
  return typeof h == "function" ? h : deepmerge;
}
function getEnumerableOwnPropertySymbols(c) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(c).filter(function(a) {
    return Object.propertyIsEnumerable.call(c, a);
  }) : [];
}
function getKeys(c) {
  return Object.keys(c).concat(getEnumerableOwnPropertySymbols(c));
}
function propertyIsOnObject(c, a) {
  try {
    return a in c;
  } catch {
    return !1;
  }
}
function propertyIsUnsafe(c, a) {
  return propertyIsOnObject(c, a) && !(Object.hasOwnProperty.call(c, a) && Object.propertyIsEnumerable.call(c, a));
}
function mergeObject(c, a, h) {
  var d = {};
  return h.isMergeableObject(c) && getKeys(c).forEach(function(u) {
    d[u] = cloneUnlessOtherwiseSpecified(c[u], h);
  }), getKeys(a).forEach(function(u) {
    propertyIsUnsafe(c, u) || (propertyIsOnObject(c, u) && h.isMergeableObject(a[u]) ? d[u] = getMergeFunction(u, h)(c[u], a[u], h) : d[u] = cloneUnlessOtherwiseSpecified(a[u], h));
  }), d;
}
function deepmerge(c, a, h) {
  h = h || {}, h.arrayMerge = h.arrayMerge || defaultArrayMerge, h.isMergeableObject = h.isMergeableObject || isMergeableObject, h.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
  var d = Array.isArray(a), u = Array.isArray(c), _ = d === u;
  return _ ? d ? h.arrayMerge(c, a, h) : mergeObject(c, a, h) : cloneUnlessOtherwiseSpecified(a, h);
}
deepmerge.all = function c(a, h) {
  if (!Array.isArray(a))
    throw new Error("first argument should be an array");
  return a.reduce(function(d, u) {
    return deepmerge(d, u, h);
  }, {});
};
var deepmerge_1 = deepmerge, cjs = deepmerge_1;
const deepmerge$1 = /* @__PURE__ */ getDefaultExportFromCjs(cjs);
var en_US$7 = {}, interopRequireDefault = {
  exports: {}
};
(function(c) {
  function a(h) {
    return h && h.__esModule ? h : {
      default: h
    };
  }
  c.exports = a, c.exports.__esModule = !0, c.exports.default = c.exports;
})(interopRequireDefault);
var interopRequireDefaultExports = interopRequireDefault.exports, en_US$6 = {};
Object.defineProperty(en_US$6, "__esModule", {
  value: !0
});
en_US$6.default = void 0;
var locale$7 = {
  // Options
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "Page",
  // Pagination
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages",
  page_size: "Page Size"
};
en_US$6.default = locale$7;
var en_US$5 = {}, en_US$4 = {}, en_US$3 = {}, objectSpread2 = {
  exports: {}
}, defineProperty = {
  exports: {}
}, toPropertyKey = {
  exports: {}
}, _typeof = {
  exports: {}
};
(function(c) {
  function a(h) {
    "@babel/helpers - typeof";
    return c.exports = a = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(d) {
      return typeof d;
    } : function(d) {
      return d && typeof Symbol == "function" && d.constructor === Symbol && d !== Symbol.prototype ? "symbol" : typeof d;
    }, c.exports.__esModule = !0, c.exports.default = c.exports, a(h);
  }
  c.exports = a, c.exports.__esModule = !0, c.exports.default = c.exports;
})(_typeof);
var _typeofExports = _typeof.exports, toPrimitive = {
  exports: {}
};
(function(c) {
  var a = _typeofExports.default;
  function h(d, u) {
    if (a(d) != "object" || !d) return d;
    var _ = d[Symbol.toPrimitive];
    if (_ !== void 0) {
      var g = _.call(d, u || "default");
      if (a(g) != "object") return g;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (u === "string" ? String : Number)(d);
  }
  c.exports = h, c.exports.__esModule = !0, c.exports.default = c.exports;
})(toPrimitive);
var toPrimitiveExports = toPrimitive.exports;
(function(c) {
  var a = _typeofExports.default, h = toPrimitiveExports;
  function d(u) {
    var _ = h(u, "string");
    return a(_) == "symbol" ? _ : _ + "";
  }
  c.exports = d, c.exports.__esModule = !0, c.exports.default = c.exports;
})(toPropertyKey);
var toPropertyKeyExports = toPropertyKey.exports;
(function(c) {
  var a = toPropertyKeyExports;
  function h(d, u, _) {
    return (u = a(u)) in d ? Object.defineProperty(d, u, {
      value: _,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : d[u] = _, d;
  }
  c.exports = h, c.exports.__esModule = !0, c.exports.default = c.exports;
})(defineProperty);
var definePropertyExports = defineProperty.exports;
(function(c) {
  var a = definePropertyExports;
  function h(u, _) {
    var g = Object.keys(u);
    if (Object.getOwnPropertySymbols) {
      var $ = Object.getOwnPropertySymbols(u);
      _ && ($ = $.filter(function(b) {
        return Object.getOwnPropertyDescriptor(u, b).enumerable;
      })), g.push.apply(g, $);
    }
    return g;
  }
  function d(u) {
    for (var _ = 1; _ < arguments.length; _++) {
      var g = arguments[_] != null ? arguments[_] : {};
      _ % 2 ? h(Object(g), !0).forEach(function($) {
        a(u, $, g[$]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(u, Object.getOwnPropertyDescriptors(g)) : h(Object(g)).forEach(function($) {
        Object.defineProperty(u, $, Object.getOwnPropertyDescriptor(g, $));
      });
    }
    return u;
  }
  c.exports = d, c.exports.__esModule = !0, c.exports.default = c.exports;
})(objectSpread2);
var objectSpread2Exports = objectSpread2.exports, common = {};
Object.defineProperty(common, "__esModule", {
  value: !0
});
common.commonLocale = void 0;
common.commonLocale = {
  yearFormat: "YYYY",
  dayFormat: "D",
  cellMeridiemFormat: "A",
  monthBeforeYear: !0
};
var _interopRequireDefault$7 = interopRequireDefaultExports.default;
Object.defineProperty(en_US$3, "__esModule", {
  value: !0
});
en_US$3.default = void 0;
var _objectSpread2$1 = _interopRequireDefault$7(objectSpread2Exports), _common$1 = common, locale$6 = (0, _objectSpread2$1.default)((0, _objectSpread2$1.default)({}, _common$1.commonLocale), {}, {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "OK",
  clear: "Clear",
  week: "Week",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  dateFormat: "M/D/YYYY",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
});
en_US$3.default = locale$6;
var en_US$2 = {};
Object.defineProperty(en_US$2, "__esModule", {
  value: !0
});
en_US$2.default = void 0;
const locale$5 = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
};
en_US$2.default = locale$5;
var _interopRequireDefault$6 = interopRequireDefaultExports.default;
Object.defineProperty(en_US$4, "__esModule", {
  value: !0
});
en_US$4.default = void 0;
var _en_US$2 = _interopRequireDefault$6(en_US$3), _en_US2$1 = _interopRequireDefault$6(en_US$2);
const locale$4 = {
  lang: Object.assign({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, _en_US$2.default),
  timePickerLocale: Object.assign({}, _en_US2$1.default)
};
en_US$4.default = locale$4;
var _interopRequireDefault$5 = interopRequireDefaultExports.default;
Object.defineProperty(en_US$5, "__esModule", {
  value: !0
});
en_US$5.default = void 0;
var _en_US$1 = _interopRequireDefault$5(en_US$4);
en_US$5.default = _en_US$1.default;
var _interopRequireDefault$4 = interopRequireDefaultExports.default;
Object.defineProperty(en_US$7, "__esModule", {
  value: !0
});
en_US$7.default = void 0;
var _en_US = _interopRequireDefault$4(en_US$6), _en_US2 = _interopRequireDefault$4(en_US$5), _en_US3 = _interopRequireDefault$4(en_US$4), _en_US4 = _interopRequireDefault$4(en_US$2);
const typeTemplate$1 = "${label} is not a valid ${type}", localeValues$1 = {
  locale: "en",
  Pagination: _en_US.default,
  DatePicker: _en_US3.default,
  TimePicker: _en_US4.default,
  Calendar: _en_US2.default,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckAll: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    deselectAll: "Deselect all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand",
    collapse: "Collapse"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: typeTemplate$1,
        method: typeTemplate$1,
        array: typeTemplate$1,
        object: typeTemplate$1,
        number: typeTemplate$1,
        date: typeTemplate$1,
        boolean: typeTemplate$1,
        integer: typeTemplate$1,
        float: typeTemplate$1,
        regexp: typeTemplate$1,
        email: typeTemplate$1,
        url: typeTemplate$1,
        hex: typeTemplate$1
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh",
    scanned: "Scanned"
  },
  ColorPicker: {
    presetEmpty: "Empty",
    transparent: "Transparent",
    singleColor: "Single",
    gradientColor: "Gradient"
  }
};
en_US$7.default = localeValues$1;
var en_US = en_US$7;
const en_US$1 = /* @__PURE__ */ getDefaultExportFromCjs(en_US);
var zh_CN$7 = {}, zh_CN$6 = {};
Object.defineProperty(zh_CN$6, "__esModule", {
  value: !0
});
zh_CN$6.default = void 0;
var locale$3 = {
  // Options
  items_per_page: "条/页",
  jump_to: "跳至",
  jump_to_confirm: "确定",
  page: "页",
  // Pagination
  prev_page: "上一页",
  next_page: "下一页",
  prev_5: "向前 5 页",
  next_5: "向后 5 页",
  prev_3: "向前 3 页",
  next_3: "向后 3 页",
  page_size: "页码"
};
zh_CN$6.default = locale$3;
var zh_CN$5 = {}, zh_CN$4 = {}, zh_CN$3 = {}, _interopRequireDefault$3 = interopRequireDefaultExports.default;
Object.defineProperty(zh_CN$3, "__esModule", {
  value: !0
});
zh_CN$3.default = void 0;
var _objectSpread2 = _interopRequireDefault$3(objectSpread2Exports), _common = common, locale$2 = (0, _objectSpread2.default)((0, _objectSpread2.default)({}, _common.commonLocale), {}, {
  locale: "zh_CN",
  today: "今天",
  now: "此刻",
  backToToday: "返回今天",
  ok: "确定",
  timeSelect: "选择时间",
  dateSelect: "选择日期",
  weekSelect: "选择周",
  clear: "清除",
  week: "周",
  month: "月",
  year: "年",
  previousMonth: "上个月 (翻页上键)",
  nextMonth: "下个月 (翻页下键)",
  monthSelect: "选择月份",
  yearSelect: "选择年份",
  decadeSelect: "选择年代",
  previousYear: "上一年 (Control键加左方向键)",
  nextYear: "下一年 (Control键加右方向键)",
  previousDecade: "上一年代",
  nextDecade: "下一年代",
  previousCentury: "上一世纪",
  nextCentury: "下一世纪",
  yearFormat: "YYYY年",
  cellDateFormat: "D",
  monthBeforeYear: !1
});
zh_CN$3.default = locale$2;
var zh_CN$2 = {};
Object.defineProperty(zh_CN$2, "__esModule", {
  value: !0
});
zh_CN$2.default = void 0;
const locale$1 = {
  placeholder: "请选择时间",
  rangePlaceholder: ["开始时间", "结束时间"]
};
zh_CN$2.default = locale$1;
var _interopRequireDefault$2 = interopRequireDefaultExports.default;
Object.defineProperty(zh_CN$4, "__esModule", {
  value: !0
});
zh_CN$4.default = void 0;
var _zh_CN$2 = _interopRequireDefault$2(zh_CN$3), _zh_CN2$1 = _interopRequireDefault$2(zh_CN$2);
const locale = {
  lang: Object.assign({
    placeholder: "请选择日期",
    yearPlaceholder: "请选择年份",
    quarterPlaceholder: "请选择季度",
    monthPlaceholder: "请选择月份",
    weekPlaceholder: "请选择周",
    rangePlaceholder: ["开始日期", "结束日期"],
    rangeYearPlaceholder: ["开始年份", "结束年份"],
    rangeMonthPlaceholder: ["开始月份", "结束月份"],
    rangeQuarterPlaceholder: ["开始季度", "结束季度"],
    rangeWeekPlaceholder: ["开始周", "结束周"]
  }, _zh_CN$2.default),
  timePickerLocale: Object.assign({}, _zh_CN2$1.default)
};
locale.lang.ok = "确定";
zh_CN$4.default = locale;
var _interopRequireDefault$1 = interopRequireDefaultExports.default;
Object.defineProperty(zh_CN$5, "__esModule", {
  value: !0
});
zh_CN$5.default = void 0;
var _zh_CN$1 = _interopRequireDefault$1(zh_CN$4);
zh_CN$5.default = _zh_CN$1.default;
var _interopRequireDefault = interopRequireDefaultExports.default;
Object.defineProperty(zh_CN$7, "__esModule", {
  value: !0
});
zh_CN$7.default = void 0;
var _zh_CN = _interopRequireDefault(zh_CN$6), _zh_CN2 = _interopRequireDefault(zh_CN$5), _zh_CN3 = _interopRequireDefault(zh_CN$4), _zh_CN4 = _interopRequireDefault(zh_CN$2);
const typeTemplate = "${label}不是一个有效的${type}", localeValues = {
  locale: "zh-cn",
  Pagination: _zh_CN.default,
  DatePicker: _zh_CN3.default,
  TimePicker: _zh_CN4.default,
  Calendar: _zh_CN2.default,
  // locales for all components
  global: {
    placeholder: "请选择"
  },
  Table: {
    filterTitle: "筛选",
    filterConfirm: "确定",
    filterReset: "重置",
    filterEmptyText: "无筛选项",
    filterCheckAll: "全选",
    filterSearchPlaceholder: "在筛选项中搜索",
    emptyText: "暂无数据",
    selectAll: "全选当页",
    selectInvert: "反选当页",
    selectNone: "清空所有",
    selectionAll: "全选所有",
    sortTitle: "排序",
    expand: "展开行",
    collapse: "关闭行",
    triggerDesc: "点击降序",
    triggerAsc: "点击升序",
    cancelSort: "取消排序"
  },
  Modal: {
    okText: "确定",
    cancelText: "取消",
    justOkText: "知道了"
  },
  Tour: {
    Next: "下一步",
    Previous: "上一步",
    Finish: "结束导览"
  },
  Popconfirm: {
    cancelText: "取消",
    okText: "确定"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "请输入搜索内容",
    itemUnit: "项",
    itemsUnit: "项",
    remove: "删除",
    selectCurrent: "全选当页",
    removeCurrent: "删除当页",
    selectAll: "全选所有",
    deselectAll: "取消全选",
    removeAll: "删除全部",
    selectInvert: "反选当页"
  },
  Upload: {
    uploading: "文件上传中",
    removeFile: "删除文件",
    uploadError: "上传错误",
    previewFile: "预览文件",
    downloadFile: "下载文件"
  },
  Empty: {
    description: "暂无数据"
  },
  Icon: {
    icon: "图标"
  },
  Text: {
    edit: "编辑",
    copy: "复制",
    copied: "复制成功",
    expand: "展开",
    collapse: "收起"
  },
  Form: {
    optional: "（可选）",
    defaultValidateMessages: {
      default: "字段验证错误${label}",
      required: "请输入${label}",
      enum: "${label}必须是其中一个[${enum}]",
      whitespace: "${label}不能为空字符",
      date: {
        format: "${label}日期格式无效",
        parse: "${label}不能转换为日期",
        invalid: "${label}是一个无效日期"
      },
      types: {
        string: typeTemplate,
        method: typeTemplate,
        array: typeTemplate,
        object: typeTemplate,
        number: typeTemplate,
        date: typeTemplate,
        boolean: typeTemplate,
        integer: typeTemplate,
        float: typeTemplate,
        regexp: typeTemplate,
        email: typeTemplate,
        url: typeTemplate,
        hex: typeTemplate
      },
      string: {
        len: "${label}须为${len}个字符",
        min: "${label}最少${min}个字符",
        max: "${label}最多${max}个字符",
        range: "${label}须在${min}-${max}字符之间"
      },
      number: {
        len: "${label}必须等于${len}",
        min: "${label}最小值为${min}",
        max: "${label}最大值为${max}",
        range: "${label}须在${min}-${max}之间"
      },
      array: {
        len: "须为${len}个${label}",
        min: "最少${min}个${label}",
        max: "最多${max}个${label}",
        range: "${label}数量须在${min}-${max}之间"
      },
      pattern: {
        mismatch: "${label}与模式不匹配${pattern}"
      }
    }
  },
  Image: {
    preview: "预览"
  },
  QRCode: {
    expired: "二维码过期",
    refresh: "点击刷新",
    scanned: "已扫描"
  },
  ColorPicker: {
    presetEmpty: "暂无",
    transparent: "无色",
    singleColor: "单色",
    gradientColor: "渐变色"
  }
};
zh_CN$7.default = localeValues;
var zh_CN = zh_CN$7;
const zh_CN$1 = /* @__PURE__ */ getDefaultExportFromCjs(zh_CN), langs = {
  "en-US": en_US$1,
  "zh-CN": zh_CN$1
}, primaryColor = window.getComputedStyle(document.documentElement).getPropertyValue("--color-accent"), ComponentConfigProvider = (c) => {
  const {
    locale: a,
    theme: h,
    children: d
  } = c, [u, _] = useState();
  return useEffect(() => {
    a && _(langs[a]);
  }, [a]), /* @__PURE__ */ jsxRuntimeExports.jsx(ConfigProvider, {
    theme: useMemo(() => ({
      cssVar: !0,
      token: {
        colorPrimary: primaryColor
      },
      algorithm: h === "dark" ? theme.darkAlgorithm : theme.defaultAlgorithm
    }), [h]),
    locale: u,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(StyleProvider, {
      hashPriority: "high",
      transformers: useMemo(() => [legacyLogicalPropertiesTransformer], []),
      children: d
    })
  });
};
function mount(c, a, h, d) {
  const u = d || ReactDOM.createRoot(c);
  return u.render(/* @__PURE__ */ jsxRuntimeExports.jsx(ComponentConfigProvider, {
    locale: h.locale,
    theme: h.theme,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(a, {
      ...h
    })
  })), u;
}
var extendStatics = function(c, a) {
  return extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(h, d) {
    h.__proto__ = d;
  } || function(h, d) {
    for (var u in d) Object.prototype.hasOwnProperty.call(d, u) && (h[u] = d[u]);
  }, extendStatics(c, a);
};
function __extends(c, a) {
  if (typeof a != "function" && a !== null) throw new TypeError("Class extends value " + String(a) + " is not a constructor or null");
  extendStatics(c, a);
  function h() {
    this.constructor = c;
  }
  c.prototype = a === null ? Object.create(a) : (h.prototype = a.prototype, new h());
}
var __assign = function() {
  return __assign = Object.assign || function(a) {
    for (var h, d = 1, u = arguments.length; d < u; d++) {
      h = arguments[d];
      for (var _ in h) Object.prototype.hasOwnProperty.call(h, _) && (a[_] = h[_]);
    }
    return a;
  }, __assign.apply(this, arguments);
};
function __rest(c, a) {
  var h = {};
  for (var d in c) Object.prototype.hasOwnProperty.call(c, d) && a.indexOf(d) < 0 && (h[d] = c[d]);
  if (c != null && typeof Object.getOwnPropertySymbols == "function") for (var u = 0, d = Object.getOwnPropertySymbols(c); u < d.length; u++)
    a.indexOf(d[u]) < 0 && Object.prototype.propertyIsEnumerable.call(c, d[u]) && (h[d[u]] = c[d[u]]);
  return h;
}
function __spreadArray(c, a, h) {
  if (h || arguments.length === 2) for (var d = 0, u = a.length, _; d < u; d++)
    (_ || !(d in a)) && (_ || (_ = Array.prototype.slice.call(a, 0, d)), _[d] = a[d]);
  return c.concat(_ || Array.prototype.slice.call(a));
}
typeof SuppressedError == "function" && SuppressedError;
function memoize(c, a) {
  var h = a && a.cache ? a.cache : cacheDefault, d = a && a.serializer ? a.serializer : serializerDefault, u = a && a.strategy ? a.strategy : strategyDefault;
  return u(c, {
    cache: h,
    serializer: d
  });
}
function isPrimitive(c) {
  return c == null || typeof c == "number" || typeof c == "boolean";
}
function monadic(c, a, h, d) {
  var u = isPrimitive(d) ? d : h(d), _ = a.get(u);
  return typeof _ > "u" && (_ = c.call(this, d), a.set(u, _)), _;
}
function variadic(c, a, h) {
  var d = Array.prototype.slice.call(arguments, 3), u = h(d), _ = a.get(u);
  return typeof _ > "u" && (_ = c.apply(this, d), a.set(u, _)), _;
}
function assemble(c, a, h, d, u) {
  return h.bind(a, c, d, u);
}
function strategyDefault(c, a) {
  var h = c.length === 1 ? monadic : variadic;
  return assemble(c, this, h, a.cache.create(), a.serializer);
}
function strategyVariadic(c, a) {
  return assemble(c, this, variadic, a.cache.create(), a.serializer);
}
var serializerDefault = function() {
  return JSON.stringify(arguments);
};
function ObjectWithoutPrototypeCache() {
  this.cache = /* @__PURE__ */ Object.create(null);
}
ObjectWithoutPrototypeCache.prototype.get = function(c) {
  return this.cache[c];
};
ObjectWithoutPrototypeCache.prototype.set = function(c, a) {
  this.cache[c] = a;
};
var cacheDefault = {
  create: function c() {
    return new ObjectWithoutPrototypeCache();
  }
}, strategies = {
  variadic: strategyVariadic
}, ErrorKind;
(function(c) {
  c[c.EXPECT_ARGUMENT_CLOSING_BRACE = 1] = "EXPECT_ARGUMENT_CLOSING_BRACE", c[c.EMPTY_ARGUMENT = 2] = "EMPTY_ARGUMENT", c[c.MALFORMED_ARGUMENT = 3] = "MALFORMED_ARGUMENT", c[c.EXPECT_ARGUMENT_TYPE = 4] = "EXPECT_ARGUMENT_TYPE", c[c.INVALID_ARGUMENT_TYPE = 5] = "INVALID_ARGUMENT_TYPE", c[c.EXPECT_ARGUMENT_STYLE = 6] = "EXPECT_ARGUMENT_STYLE", c[c.INVALID_NUMBER_SKELETON = 7] = "INVALID_NUMBER_SKELETON", c[c.INVALID_DATE_TIME_SKELETON = 8] = "INVALID_DATE_TIME_SKELETON", c[c.EXPECT_NUMBER_SKELETON = 9] = "EXPECT_NUMBER_SKELETON", c[c.EXPECT_DATE_TIME_SKELETON = 10] = "EXPECT_DATE_TIME_SKELETON", c[c.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE = 11] = "UNCLOSED_QUOTE_IN_ARGUMENT_STYLE", c[c.EXPECT_SELECT_ARGUMENT_OPTIONS = 12] = "EXPECT_SELECT_ARGUMENT_OPTIONS", c[c.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE = 13] = "EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE", c[c.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE = 14] = "INVALID_PLURAL_ARGUMENT_OFFSET_VALUE", c[c.EXPECT_SELECT_ARGUMENT_SELECTOR = 15] = "EXPECT_SELECT_ARGUMENT_SELECTOR", c[c.EXPECT_PLURAL_ARGUMENT_SELECTOR = 16] = "EXPECT_PLURAL_ARGUMENT_SELECTOR", c[c.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT = 17] = "EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT", c[c.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT = 18] = "EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT", c[c.INVALID_PLURAL_ARGUMENT_SELECTOR = 19] = "INVALID_PLURAL_ARGUMENT_SELECTOR", c[c.DUPLICATE_PLURAL_ARGUMENT_SELECTOR = 20] = "DUPLICATE_PLURAL_ARGUMENT_SELECTOR", c[c.DUPLICATE_SELECT_ARGUMENT_SELECTOR = 21] = "DUPLICATE_SELECT_ARGUMENT_SELECTOR", c[c.MISSING_OTHER_CLAUSE = 22] = "MISSING_OTHER_CLAUSE", c[c.INVALID_TAG = 23] = "INVALID_TAG", c[c.INVALID_TAG_NAME = 25] = "INVALID_TAG_NAME", c[c.UNMATCHED_CLOSING_TAG = 26] = "UNMATCHED_CLOSING_TAG", c[c.UNCLOSED_TAG = 27] = "UNCLOSED_TAG";
})(ErrorKind || (ErrorKind = {}));
var TYPE;
(function(c) {
  c[c.literal = 0] = "literal", c[c.argument = 1] = "argument", c[c.number = 2] = "number", c[c.date = 3] = "date", c[c.time = 4] = "time", c[c.select = 5] = "select", c[c.plural = 6] = "plural", c[c.pound = 7] = "pound", c[c.tag = 8] = "tag";
})(TYPE || (TYPE = {}));
var SKELETON_TYPE;
(function(c) {
  c[c.number = 0] = "number", c[c.dateTime = 1] = "dateTime";
})(SKELETON_TYPE || (SKELETON_TYPE = {}));
function isLiteralElement(c) {
  return c.type === TYPE.literal;
}
function isArgumentElement(c) {
  return c.type === TYPE.argument;
}
function isNumberElement(c) {
  return c.type === TYPE.number;
}
function isDateElement(c) {
  return c.type === TYPE.date;
}
function isTimeElement(c) {
  return c.type === TYPE.time;
}
function isSelectElement(c) {
  return c.type === TYPE.select;
}
function isPluralElement(c) {
  return c.type === TYPE.plural;
}
function isPoundElement(c) {
  return c.type === TYPE.pound;
}
function isTagElement(c) {
  return c.type === TYPE.tag;
}
function isNumberSkeleton(c) {
  return !!(c && typeof c == "object" && c.type === SKELETON_TYPE.number);
}
function isDateTimeSkeleton(c) {
  return !!(c && typeof c == "object" && c.type === SKELETON_TYPE.dateTime);
}
var SPACE_SEPARATOR_REGEX = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/, DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function parseDateTimeSkeleton(c) {
  var a = {};
  return c.replace(DATE_TIME_REGEX, function(h) {
    var d = h.length;
    switch (h[0]) {
      case "G":
        a.era = d === 4 ? "long" : d === 5 ? "narrow" : "short";
        break;
      case "y":
        a.year = d === 2 ? "2-digit" : "numeric";
        break;
      case "Y":
      case "u":
      case "U":
      case "r":
        throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
      case "q":
      case "Q":
        throw new RangeError("`q/Q` (quarter) patterns are not supported");
      case "M":
      case "L":
        a.month = ["numeric", "2-digit", "short", "long", "narrow"][d - 1];
        break;
      case "w":
      case "W":
        throw new RangeError("`w/W` (week) patterns are not supported");
      case "d":
        a.day = ["numeric", "2-digit"][d - 1];
        break;
      case "D":
      case "F":
      case "g":
        throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
      case "E":
        a.weekday = d === 4 ? "long" : d === 5 ? "narrow" : "short";
        break;
      case "e":
        if (d < 4)
          throw new RangeError("`e..eee` (weekday) patterns are not supported");
        a.weekday = ["short", "long", "narrow", "short"][d - 4];
        break;
      case "c":
        if (d < 4)
          throw new RangeError("`c..ccc` (weekday) patterns are not supported");
        a.weekday = ["short", "long", "narrow", "short"][d - 4];
        break;
      case "a":
        a.hour12 = !0;
        break;
      case "b":
      case "B":
        throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
      case "h":
        a.hourCycle = "h12", a.hour = ["numeric", "2-digit"][d - 1];
        break;
      case "H":
        a.hourCycle = "h23", a.hour = ["numeric", "2-digit"][d - 1];
        break;
      case "K":
        a.hourCycle = "h11", a.hour = ["numeric", "2-digit"][d - 1];
        break;
      case "k":
        a.hourCycle = "h24", a.hour = ["numeric", "2-digit"][d - 1];
        break;
      case "j":
      case "J":
      case "C":
        throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
      case "m":
        a.minute = ["numeric", "2-digit"][d - 1];
        break;
      case "s":
        a.second = ["numeric", "2-digit"][d - 1];
        break;
      case "S":
      case "A":
        throw new RangeError("`S/A` (second) patterns are not supported, use `s` instead");
      case "z":
        a.timeZoneName = d < 4 ? "short" : "long";
        break;
      case "Z":
      case "O":
      case "v":
      case "V":
      case "X":
      case "x":
        throw new RangeError("`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead");
    }
    return "";
  }), a;
}
var WHITE_SPACE_REGEX = /[\t-\r \x85\u200E\u200F\u2028\u2029]/i;
function parseNumberSkeletonFromString(c) {
  if (c.length === 0)
    throw new Error("Number skeleton cannot be empty");
  for (var a = c.split(WHITE_SPACE_REGEX).filter(function(S) {
    return S.length > 0;
  }), h = [], d = 0, u = a; d < u.length; d++) {
    var _ = u[d], g = _.split("/");
    if (g.length === 0)
      throw new Error("Invalid number skeleton");
    for (var $ = g[0], b = g.slice(1), y = 0, v = b; y < v.length; y++) {
      var E = v[y];
      if (E.length === 0)
        throw new Error("Invalid number skeleton");
    }
    h.push({
      stem: $,
      options: b
    });
  }
  return h;
}
function icuUnitToEcma(c) {
  return c.replace(/^(.*?)-/, "");
}
var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\*)?|(#+)|(0+)(#+))$/g, SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?[rs]?$/g, INTEGER_WIDTH_REGEX = /(\*)(0+)|(#+)(0+)|(0+)/g, CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;
function parseSignificantPrecision(c) {
  var a = {};
  return c[c.length - 1] === "r" ? a.roundingPriority = "morePrecision" : c[c.length - 1] === "s" && (a.roundingPriority = "lessPrecision"), c.replace(SIGNIFICANT_PRECISION_REGEX, function(h, d, u) {
    return typeof u != "string" ? (a.minimumSignificantDigits = d.length, a.maximumSignificantDigits = d.length) : u === "+" ? a.minimumSignificantDigits = d.length : d[0] === "#" ? a.maximumSignificantDigits = d.length : (a.minimumSignificantDigits = d.length, a.maximumSignificantDigits = d.length + (typeof u == "string" ? u.length : 0)), "";
  }), a;
}
function parseSign(c) {
  switch (c) {
    case "sign-auto":
      return {
        signDisplay: "auto"
      };
    case "sign-accounting":
    case "()":
      return {
        currencySign: "accounting"
      };
    case "sign-always":
    case "+!":
      return {
        signDisplay: "always"
      };
    case "sign-accounting-always":
    case "()!":
      return {
        signDisplay: "always",
        currencySign: "accounting"
      };
    case "sign-except-zero":
    case "+?":
      return {
        signDisplay: "exceptZero"
      };
    case "sign-accounting-except-zero":
    case "()?":
      return {
        signDisplay: "exceptZero",
        currencySign: "accounting"
      };
    case "sign-never":
    case "+_":
      return {
        signDisplay: "never"
      };
  }
}
function parseConciseScientificAndEngineeringStem(c) {
  var a;
  if (c[0] === "E" && c[1] === "E" ? (a = {
    notation: "engineering"
  }, c = c.slice(2)) : c[0] === "E" && (a = {
    notation: "scientific"
  }, c = c.slice(1)), a) {
    var h = c.slice(0, 2);
    if (h === "+!" ? (a.signDisplay = "always", c = c.slice(2)) : h === "+?" && (a.signDisplay = "exceptZero", c = c.slice(2)), !CONCISE_INTEGER_WIDTH_REGEX.test(c))
      throw new Error("Malformed concise eng/scientific notation");
    a.minimumIntegerDigits = c.length;
  }
  return a;
}
function parseNotationOptions(c) {
  var a = {}, h = parseSign(c);
  return h || a;
}
function parseNumberSkeleton(c) {
  for (var a = {}, h = 0, d = c; h < d.length; h++) {
    var u = d[h];
    switch (u.stem) {
      case "percent":
      case "%":
        a.style = "percent";
        continue;
      case "%x100":
        a.style = "percent", a.scale = 100;
        continue;
      case "currency":
        a.style = "currency", a.currency = u.options[0];
        continue;
      case "group-off":
      case ",_":
        a.useGrouping = !1;
        continue;
      case "precision-integer":
      case ".":
        a.maximumFractionDigits = 0;
        continue;
      case "measure-unit":
      case "unit":
        a.style = "unit", a.unit = icuUnitToEcma(u.options[0]);
        continue;
      case "compact-short":
      case "K":
        a.notation = "compact", a.compactDisplay = "short";
        continue;
      case "compact-long":
      case "KK":
        a.notation = "compact", a.compactDisplay = "long";
        continue;
      case "scientific":
        a = __assign(__assign(__assign({}, a), {
          notation: "scientific"
        }), u.options.reduce(function(b, y) {
          return __assign(__assign({}, b), parseNotationOptions(y));
        }, {}));
        continue;
      case "engineering":
        a = __assign(__assign(__assign({}, a), {
          notation: "engineering"
        }), u.options.reduce(function(b, y) {
          return __assign(__assign({}, b), parseNotationOptions(y));
        }, {}));
        continue;
      case "notation-simple":
        a.notation = "standard";
        continue;
      case "unit-width-narrow":
        a.currencyDisplay = "narrowSymbol", a.unitDisplay = "narrow";
        continue;
      case "unit-width-short":
        a.currencyDisplay = "code", a.unitDisplay = "short";
        continue;
      case "unit-width-full-name":
        a.currencyDisplay = "name", a.unitDisplay = "long";
        continue;
      case "unit-width-iso-code":
        a.currencyDisplay = "symbol";
        continue;
      case "scale":
        a.scale = parseFloat(u.options[0]);
        continue;
      case "rounding-mode-floor":
        a.roundingMode = "floor";
        continue;
      case "rounding-mode-ceiling":
        a.roundingMode = "ceil";
        continue;
      case "rounding-mode-down":
        a.roundingMode = "trunc";
        continue;
      case "rounding-mode-up":
        a.roundingMode = "expand";
        continue;
      case "rounding-mode-half-even":
        a.roundingMode = "halfEven";
        continue;
      case "rounding-mode-half-down":
        a.roundingMode = "halfTrunc";
        continue;
      case "rounding-mode-half-up":
        a.roundingMode = "halfExpand";
        continue;
      case "integer-width":
        if (u.options.length > 1)
          throw new RangeError("integer-width stems only accept a single optional option");
        u.options[0].replace(INTEGER_WIDTH_REGEX, function(b, y, v, E, S, R) {
          if (y)
            a.minimumIntegerDigits = v.length;
          else {
            if (E && S)
              throw new Error("We currently do not support maximum integer digits");
            if (R)
              throw new Error("We currently do not support exact integer digits");
          }
          return "";
        });
        continue;
    }
    if (CONCISE_INTEGER_WIDTH_REGEX.test(u.stem)) {
      a.minimumIntegerDigits = u.stem.length;
      continue;
    }
    if (FRACTION_PRECISION_REGEX.test(u.stem)) {
      if (u.options.length > 1)
        throw new RangeError("Fraction-precision stems only accept a single optional option");
      u.stem.replace(FRACTION_PRECISION_REGEX, function(b, y, v, E, S, R) {
        return v === "*" ? a.minimumFractionDigits = y.length : E && E[0] === "#" ? a.maximumFractionDigits = E.length : S && R ? (a.minimumFractionDigits = S.length, a.maximumFractionDigits = S.length + R.length) : (a.minimumFractionDigits = y.length, a.maximumFractionDigits = y.length), "";
      });
      var _ = u.options[0];
      _ === "w" ? a = __assign(__assign({}, a), {
        trailingZeroDisplay: "stripIfInteger"
      }) : _ && (a = __assign(__assign({}, a), parseSignificantPrecision(_)));
      continue;
    }
    if (SIGNIFICANT_PRECISION_REGEX.test(u.stem)) {
      a = __assign(__assign({}, a), parseSignificantPrecision(u.stem));
      continue;
    }
    var g = parseSign(u.stem);
    g && (a = __assign(__assign({}, a), g));
    var $ = parseConciseScientificAndEngineeringStem(u.stem);
    $ && (a = __assign(__assign({}, a), $));
  }
  return a;
}
var timeData = {
  "001": ["H", "h"],
  419: ["h", "H", "hB", "hb"],
  AC: ["H", "h", "hb", "hB"],
  AD: ["H", "hB"],
  AE: ["h", "hB", "hb", "H"],
  AF: ["H", "hb", "hB", "h"],
  AG: ["h", "hb", "H", "hB"],
  AI: ["H", "h", "hb", "hB"],
  AL: ["h", "H", "hB"],
  AM: ["H", "hB"],
  AO: ["H", "hB"],
  AR: ["h", "H", "hB", "hb"],
  AS: ["h", "H"],
  AT: ["H", "hB"],
  AU: ["h", "hb", "H", "hB"],
  AW: ["H", "hB"],
  AX: ["H"],
  AZ: ["H", "hB", "h"],
  BA: ["H", "hB", "h"],
  BB: ["h", "hb", "H", "hB"],
  BD: ["h", "hB", "H"],
  BE: ["H", "hB"],
  BF: ["H", "hB"],
  BG: ["H", "hB", "h"],
  BH: ["h", "hB", "hb", "H"],
  BI: ["H", "h"],
  BJ: ["H", "hB"],
  BL: ["H", "hB"],
  BM: ["h", "hb", "H", "hB"],
  BN: ["hb", "hB", "h", "H"],
  BO: ["h", "H", "hB", "hb"],
  BQ: ["H"],
  BR: ["H", "hB"],
  BS: ["h", "hb", "H", "hB"],
  BT: ["h", "H"],
  BW: ["H", "h", "hb", "hB"],
  BY: ["H", "h"],
  BZ: ["H", "h", "hb", "hB"],
  CA: ["h", "hb", "H", "hB"],
  CC: ["H", "h", "hb", "hB"],
  CD: ["hB", "H"],
  CF: ["H", "h", "hB"],
  CG: ["H", "hB"],
  CH: ["H", "hB", "h"],
  CI: ["H", "hB"],
  CK: ["H", "h", "hb", "hB"],
  CL: ["h", "H", "hB", "hb"],
  CM: ["H", "h", "hB"],
  CN: ["H", "hB", "hb", "h"],
  CO: ["h", "H", "hB", "hb"],
  CP: ["H"],
  CR: ["h", "H", "hB", "hb"],
  CU: ["h", "H", "hB", "hb"],
  CV: ["H", "hB"],
  CW: ["H", "hB"],
  CX: ["H", "h", "hb", "hB"],
  CY: ["h", "H", "hb", "hB"],
  CZ: ["H"],
  DE: ["H", "hB"],
  DG: ["H", "h", "hb", "hB"],
  DJ: ["h", "H"],
  DK: ["H"],
  DM: ["h", "hb", "H", "hB"],
  DO: ["h", "H", "hB", "hb"],
  DZ: ["h", "hB", "hb", "H"],
  EA: ["H", "h", "hB", "hb"],
  EC: ["h", "H", "hB", "hb"],
  EE: ["H", "hB"],
  EG: ["h", "hB", "hb", "H"],
  EH: ["h", "hB", "hb", "H"],
  ER: ["h", "H"],
  ES: ["H", "hB", "h", "hb"],
  ET: ["hB", "hb", "h", "H"],
  FI: ["H"],
  FJ: ["h", "hb", "H", "hB"],
  FK: ["H", "h", "hb", "hB"],
  FM: ["h", "hb", "H", "hB"],
  FO: ["H", "h"],
  FR: ["H", "hB"],
  GA: ["H", "hB"],
  GB: ["H", "h", "hb", "hB"],
  GD: ["h", "hb", "H", "hB"],
  GE: ["H", "hB", "h"],
  GF: ["H", "hB"],
  GG: ["H", "h", "hb", "hB"],
  GH: ["h", "H"],
  GI: ["H", "h", "hb", "hB"],
  GL: ["H", "h"],
  GM: ["h", "hb", "H", "hB"],
  GN: ["H", "hB"],
  GP: ["H", "hB"],
  GQ: ["H", "hB", "h", "hb"],
  GR: ["h", "H", "hb", "hB"],
  GT: ["h", "H", "hB", "hb"],
  GU: ["h", "hb", "H", "hB"],
  GW: ["H", "hB"],
  GY: ["h", "hb", "H", "hB"],
  HK: ["h", "hB", "hb", "H"],
  HN: ["h", "H", "hB", "hb"],
  HR: ["H", "hB"],
  HU: ["H", "h"],
  IC: ["H", "h", "hB", "hb"],
  ID: ["H"],
  IE: ["H", "h", "hb", "hB"],
  IL: ["H", "hB"],
  IM: ["H", "h", "hb", "hB"],
  IN: ["h", "H"],
  IO: ["H", "h", "hb", "hB"],
  IQ: ["h", "hB", "hb", "H"],
  IR: ["hB", "H"],
  IS: ["H"],
  IT: ["H", "hB"],
  JE: ["H", "h", "hb", "hB"],
  JM: ["h", "hb", "H", "hB"],
  JO: ["h", "hB", "hb", "H"],
  JP: ["H", "K", "h"],
  KE: ["hB", "hb", "H", "h"],
  KG: ["H", "h", "hB", "hb"],
  KH: ["hB", "h", "H", "hb"],
  KI: ["h", "hb", "H", "hB"],
  KM: ["H", "h", "hB", "hb"],
  KN: ["h", "hb", "H", "hB"],
  KP: ["h", "H", "hB", "hb"],
  KR: ["h", "H", "hB", "hb"],
  KW: ["h", "hB", "hb", "H"],
  KY: ["h", "hb", "H", "hB"],
  KZ: ["H", "hB"],
  LA: ["H", "hb", "hB", "h"],
  LB: ["h", "hB", "hb", "H"],
  LC: ["h", "hb", "H", "hB"],
  LI: ["H", "hB", "h"],
  LK: ["H", "h", "hB", "hb"],
  LR: ["h", "hb", "H", "hB"],
  LS: ["h", "H"],
  LT: ["H", "h", "hb", "hB"],
  LU: ["H", "h", "hB"],
  LV: ["H", "hB", "hb", "h"],
  LY: ["h", "hB", "hb", "H"],
  MA: ["H", "h", "hB", "hb"],
  MC: ["H", "hB"],
  MD: ["H", "hB"],
  ME: ["H", "hB", "h"],
  MF: ["H", "hB"],
  MG: ["H", "h"],
  MH: ["h", "hb", "H", "hB"],
  MK: ["H", "h", "hb", "hB"],
  ML: ["H"],
  MM: ["hB", "hb", "H", "h"],
  MN: ["H", "h", "hb", "hB"],
  MO: ["h", "hB", "hb", "H"],
  MP: ["h", "hb", "H", "hB"],
  MQ: ["H", "hB"],
  MR: ["h", "hB", "hb", "H"],
  MS: ["H", "h", "hb", "hB"],
  MT: ["H", "h"],
  MU: ["H", "h"],
  MV: ["H", "h"],
  MW: ["h", "hb", "H", "hB"],
  MX: ["h", "H", "hB", "hb"],
  MY: ["hb", "hB", "h", "H"],
  MZ: ["H", "hB"],
  NA: ["h", "H", "hB", "hb"],
  NC: ["H", "hB"],
  NE: ["H"],
  NF: ["H", "h", "hb", "hB"],
  NG: ["H", "h", "hb", "hB"],
  NI: ["h", "H", "hB", "hb"],
  NL: ["H", "hB"],
  NO: ["H", "h"],
  NP: ["H", "h", "hB"],
  NR: ["H", "h", "hb", "hB"],
  NU: ["H", "h", "hb", "hB"],
  NZ: ["h", "hb", "H", "hB"],
  OM: ["h", "hB", "hb", "H"],
  PA: ["h", "H", "hB", "hb"],
  PE: ["h", "H", "hB", "hb"],
  PF: ["H", "h", "hB"],
  PG: ["h", "H"],
  PH: ["h", "hB", "hb", "H"],
  PK: ["h", "hB", "H"],
  PL: ["H", "h"],
  PM: ["H", "hB"],
  PN: ["H", "h", "hb", "hB"],
  PR: ["h", "H", "hB", "hb"],
  PS: ["h", "hB", "hb", "H"],
  PT: ["H", "hB"],
  PW: ["h", "H"],
  PY: ["h", "H", "hB", "hb"],
  QA: ["h", "hB", "hb", "H"],
  RE: ["H", "hB"],
  RO: ["H", "hB"],
  RS: ["H", "hB", "h"],
  RU: ["H"],
  RW: ["H", "h"],
  SA: ["h", "hB", "hb", "H"],
  SB: ["h", "hb", "H", "hB"],
  SC: ["H", "h", "hB"],
  SD: ["h", "hB", "hb", "H"],
  SE: ["H"],
  SG: ["h", "hb", "H", "hB"],
  SH: ["H", "h", "hb", "hB"],
  SI: ["H", "hB"],
  SJ: ["H"],
  SK: ["H"],
  SL: ["h", "hb", "H", "hB"],
  SM: ["H", "h", "hB"],
  SN: ["H", "h", "hB"],
  SO: ["h", "H"],
  SR: ["H", "hB"],
  SS: ["h", "hb", "H", "hB"],
  ST: ["H", "hB"],
  SV: ["h", "H", "hB", "hb"],
  SX: ["H", "h", "hb", "hB"],
  SY: ["h", "hB", "hb", "H"],
  SZ: ["h", "hb", "H", "hB"],
  TA: ["H", "h", "hb", "hB"],
  TC: ["h", "hb", "H", "hB"],
  TD: ["h", "H", "hB"],
  TF: ["H", "h", "hB"],
  TG: ["H", "hB"],
  TH: ["H", "h"],
  TJ: ["H", "h"],
  TL: ["H", "hB", "hb", "h"],
  TM: ["H", "h"],
  TN: ["h", "hB", "hb", "H"],
  TO: ["h", "H"],
  TR: ["H", "hB"],
  TT: ["h", "hb", "H", "hB"],
  TW: ["hB", "hb", "h", "H"],
  TZ: ["hB", "hb", "H", "h"],
  UA: ["H", "hB", "h"],
  UG: ["hB", "hb", "H", "h"],
  UM: ["h", "hb", "H", "hB"],
  US: ["h", "hb", "H", "hB"],
  UY: ["h", "H", "hB", "hb"],
  UZ: ["H", "hB", "h"],
  VA: ["H", "h", "hB"],
  VC: ["h", "hb", "H", "hB"],
  VE: ["h", "H", "hB", "hb"],
  VG: ["h", "hb", "H", "hB"],
  VI: ["h", "hb", "H", "hB"],
  VN: ["H", "h"],
  VU: ["h", "H"],
  WF: ["H", "hB"],
  WS: ["h", "H"],
  XK: ["H", "hB", "h"],
  YE: ["h", "hB", "hb", "H"],
  YT: ["H", "hB"],
  ZA: ["H", "h", "hb", "hB"],
  ZM: ["h", "hb", "H", "hB"],
  ZW: ["H", "h"],
  "af-ZA": ["H", "h", "hB", "hb"],
  "ar-001": ["h", "hB", "hb", "H"],
  "ca-ES": ["H", "h", "hB"],
  "en-001": ["h", "hb", "H", "hB"],
  "en-HK": ["h", "hb", "H", "hB"],
  "en-IL": ["H", "h", "hb", "hB"],
  "en-MY": ["h", "hb", "H", "hB"],
  "es-BR": ["H", "h", "hB", "hb"],
  "es-ES": ["H", "h", "hB", "hb"],
  "es-GQ": ["H", "h", "hB", "hb"],
  "fr-CA": ["H", "h", "hB"],
  "gl-ES": ["H", "h", "hB"],
  "gu-IN": ["hB", "hb", "h", "H"],
  "hi-IN": ["hB", "h", "H"],
  "it-CH": ["H", "h", "hB"],
  "it-IT": ["H", "h", "hB"],
  "kn-IN": ["hB", "h", "H"],
  "ml-IN": ["hB", "h", "H"],
  "mr-IN": ["hB", "hb", "h", "H"],
  "pa-IN": ["hB", "hb", "h", "H"],
  "ta-IN": ["hB", "h", "hb", "H"],
  "te-IN": ["hB", "h", "H"],
  "zu-ZA": ["H", "hB", "hb", "h"]
};
function getBestPattern(c, a) {
  for (var h = "", d = 0; d < c.length; d++) {
    var u = c.charAt(d);
    if (u === "j") {
      for (var _ = 0; d + 1 < c.length && c.charAt(d + 1) === u; )
        _++, d++;
      var g = 1 + (_ & 1), $ = _ < 2 ? 1 : 3 + (_ >> 1), b = "a", y = getDefaultHourSymbolFromLocale(a);
      for ((y == "H" || y == "k") && ($ = 0); $-- > 0; )
        h += b;
      for (; g-- > 0; )
        h = y + h;
    } else u === "J" ? h += "H" : h += u;
  }
  return h;
}
function getDefaultHourSymbolFromLocale(c) {
  var a = c.hourCycle;
  if (a === void 0 && // @ts-ignore hourCycle(s) is not identified yet
  c.hourCycles && // @ts-ignore
  c.hourCycles.length && (a = c.hourCycles[0]), a)
    switch (a) {
      case "h24":
        return "k";
      case "h23":
        return "H";
      case "h12":
        return "h";
      case "h11":
        return "K";
      default:
        throw new Error("Invalid hourCycle");
    }
  var h = c.language, d;
  h !== "root" && (d = c.maximize().region);
  var u = timeData[d || ""] || timeData[h || ""] || timeData["".concat(h, "-001")] || timeData["001"];
  return u[0];
}
var _a, SPACE_SEPARATOR_START_REGEX = new RegExp("^".concat(SPACE_SEPARATOR_REGEX.source, "*")), SPACE_SEPARATOR_END_REGEX = new RegExp("".concat(SPACE_SEPARATOR_REGEX.source, "*$"));
function createLocation(c, a) {
  return {
    start: c,
    end: a
  };
}
var hasNativeStartsWith = !!String.prototype.startsWith && "_a".startsWith("a", 1), hasNativeFromCodePoint = !!String.fromCodePoint, hasNativeFromEntries = !!Object.fromEntries, hasNativeCodePointAt = !!String.prototype.codePointAt, hasTrimStart = !!String.prototype.trimStart, hasTrimEnd = !!String.prototype.trimEnd, hasNativeIsSafeInteger = !!Number.isSafeInteger, isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function(c) {
  return typeof c == "number" && isFinite(c) && Math.floor(c) === c && Math.abs(c) <= 9007199254740991;
}, REGEX_SUPPORTS_U_AND_Y = !0;
try {
  var re = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec("a")) === null || _a === void 0 ? void 0 : _a[0]) === "a";
} catch (c) {
  REGEX_SUPPORTS_U_AND_Y = !1;
}
var startsWith = hasNativeStartsWith ? (
  // Native
  function c(a, h, d) {
    return a.startsWith(h, d);
  }
) : (
  // For IE11
  function c(a, h, d) {
    return a.slice(d, d + h.length) === h;
  }
), fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : (
  // IE11
  function c() {
    for (var a = [], h = 0; h < arguments.length; h++)
      a[h] = arguments[h];
    for (var d = "", u = a.length, _ = 0, g; u > _; ) {
      if (g = a[_++], g > 1114111) throw RangeError(g + " is not a valid code point");
      d += g < 65536 ? String.fromCharCode(g) : String.fromCharCode(((g -= 65536) >> 10) + 55296, g % 1024 + 56320);
    }
    return d;
  }
), fromEntries = (
  // native
  hasNativeFromEntries ? Object.fromEntries : (
    // Ponyfill
    function c(a) {
      for (var h = {}, d = 0, u = a; d < u.length; d++) {
        var _ = u[d], g = _[0], $ = _[1];
        h[g] = $;
      }
      return h;
    }
  )
), codePointAt = hasNativeCodePointAt ? (
  // Native
  function c(a, h) {
    return a.codePointAt(h);
  }
) : (
  // IE 11
  function c(a, h) {
    var d = a.length;
    if (!(h < 0 || h >= d)) {
      var u = a.charCodeAt(h), _;
      return u < 55296 || u > 56319 || h + 1 === d || (_ = a.charCodeAt(h + 1)) < 56320 || _ > 57343 ? u : (u - 55296 << 10) + (_ - 56320) + 65536;
    }
  }
), trimStart = hasTrimStart ? (
  // Native
  function c(a) {
    return a.trimStart();
  }
) : (
  // Ponyfill
  function c(a) {
    return a.replace(SPACE_SEPARATOR_START_REGEX, "");
  }
), trimEnd = hasTrimEnd ? (
  // Native
  function c(a) {
    return a.trimEnd();
  }
) : (
  // Ponyfill
  function c(a) {
    return a.replace(SPACE_SEPARATOR_END_REGEX, "");
  }
);
function RE(c, a) {
  return new RegExp(c, a);
}
var matchIdentifierAtIndex;
if (REGEX_SUPPORTS_U_AND_Y) {
  var IDENTIFIER_PREFIX_RE_1 = RE("([^\\p{White_Space}\\p{Pattern_Syntax}]*)", "yu");
  matchIdentifierAtIndex = function(a, h) {
    var d;
    IDENTIFIER_PREFIX_RE_1.lastIndex = h;
    var u = IDENTIFIER_PREFIX_RE_1.exec(a);
    return (d = u[1]) !== null && d !== void 0 ? d : "";
  };
} else
  matchIdentifierAtIndex = function(a, h) {
    for (var d = []; ; ) {
      var u = codePointAt(a, h);
      if (u === void 0 || _isWhiteSpace(u) || _isPatternSyntax(u))
        break;
      d.push(u), h += u >= 65536 ? 2 : 1;
    }
    return fromCodePoint.apply(void 0, d);
  };
var Parser = (
  /** @class */
  function() {
    function c(a, h) {
      h === void 0 && (h = {}), this.message = a, this.position = {
        offset: 0,
        line: 1,
        column: 1
      }, this.ignoreTag = !!h.ignoreTag, this.locale = h.locale, this.requiresOtherClause = !!h.requiresOtherClause, this.shouldParseSkeletons = !!h.shouldParseSkeletons;
    }
    return c.prototype.parse = function() {
      if (this.offset() !== 0)
        throw Error("parser can only be used once");
      return this.parseMessage(0, "", !1);
    }, c.prototype.parseMessage = function(a, h, d) {
      for (var u = []; !this.isEOF(); ) {
        var _ = this.char();
        if (_ === 123) {
          var g = this.parseArgument(a, d);
          if (g.err)
            return g;
          u.push(g.val);
        } else {
          if (_ === 125 && a > 0)
            break;
          if (_ === 35 && (h === "plural" || h === "selectordinal")) {
            var $ = this.clonePosition();
            this.bump(), u.push({
              type: TYPE.pound,
              location: createLocation($, this.clonePosition())
            });
          } else if (_ === 60 && !this.ignoreTag && this.peek() === 47) {
            if (d)
              break;
            return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));
          } else if (_ === 60 && !this.ignoreTag && _isAlpha(this.peek() || 0)) {
            var g = this.parseTag(a, h);
            if (g.err)
              return g;
            u.push(g.val);
          } else {
            var g = this.parseLiteral(a, h);
            if (g.err)
              return g;
            u.push(g.val);
          }
        }
      }
      return {
        val: u,
        err: null
      };
    }, c.prototype.parseTag = function(a, h) {
      var d = this.clonePosition();
      this.bump();
      var u = this.parseTagName();
      if (this.bumpSpace(), this.bumpIf("/>"))
        return {
          val: {
            type: TYPE.literal,
            value: "<".concat(u, "/>"),
            location: createLocation(d, this.clonePosition())
          },
          err: null
        };
      if (this.bumpIf(">")) {
        var _ = this.parseMessage(a + 1, h, !0);
        if (_.err)
          return _;
        var g = _.val, $ = this.clonePosition();
        if (this.bumpIf("</")) {
          if (this.isEOF() || !_isAlpha(this.char()))
            return this.error(ErrorKind.INVALID_TAG, createLocation($, this.clonePosition()));
          var b = this.clonePosition(), y = this.parseTagName();
          return u !== y ? this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(b, this.clonePosition())) : (this.bumpSpace(), this.bumpIf(">") ? {
            val: {
              type: TYPE.tag,
              value: u,
              children: g,
              location: createLocation(d, this.clonePosition())
            },
            err: null
          } : this.error(ErrorKind.INVALID_TAG, createLocation($, this.clonePosition())));
        } else
          return this.error(ErrorKind.UNCLOSED_TAG, createLocation(d, this.clonePosition()));
      } else
        return this.error(ErrorKind.INVALID_TAG, createLocation(d, this.clonePosition()));
    }, c.prototype.parseTagName = function() {
      var a = this.offset();
      for (this.bump(); !this.isEOF() && _isPotentialElementNameChar(this.char()); )
        this.bump();
      return this.message.slice(a, this.offset());
    }, c.prototype.parseLiteral = function(a, h) {
      for (var d = this.clonePosition(), u = ""; ; ) {
        var _ = this.tryParseQuote(h);
        if (_) {
          u += _;
          continue;
        }
        var g = this.tryParseUnquoted(a, h);
        if (g) {
          u += g;
          continue;
        }
        var $ = this.tryParseLeftAngleBracket();
        if ($) {
          u += $;
          continue;
        }
        break;
      }
      var b = createLocation(d, this.clonePosition());
      return {
        val: {
          type: TYPE.literal,
          value: u,
          location: b
        },
        err: null
      };
    }, c.prototype.tryParseLeftAngleBracket = function() {
      return !this.isEOF() && this.char() === 60 && (this.ignoreTag || // If at the opening tag or closing tag position, bail.
      !_isAlphaOrSlash(this.peek() || 0)) ? (this.bump(), "<") : null;
    }, c.prototype.tryParseQuote = function(a) {
      if (this.isEOF() || this.char() !== 39)
        return null;
      switch (this.peek()) {
        case 39:
          return this.bump(), this.bump(), "'";
        case 123:
        case 60:
        case 62:
        case 125:
          break;
        case 35:
          if (a === "plural" || a === "selectordinal")
            break;
          return null;
        default:
          return null;
      }
      this.bump();
      var h = [this.char()];
      for (this.bump(); !this.isEOF(); ) {
        var d = this.char();
        if (d === 39)
          if (this.peek() === 39)
            h.push(39), this.bump();
          else {
            this.bump();
            break;
          }
        else
          h.push(d);
        this.bump();
      }
      return fromCodePoint.apply(void 0, h);
    }, c.prototype.tryParseUnquoted = function(a, h) {
      if (this.isEOF())
        return null;
      var d = this.char();
      return d === 60 || d === 123 || d === 35 && (h === "plural" || h === "selectordinal") || d === 125 && a > 0 ? null : (this.bump(), fromCodePoint(d));
    }, c.prototype.parseArgument = function(a, h) {
      var d = this.clonePosition();
      if (this.bump(), this.bumpSpace(), this.isEOF())
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(d, this.clonePosition()));
      if (this.char() === 125)
        return this.bump(), this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(d, this.clonePosition()));
      var u = this.parseIdentifierIfPossible().value;
      if (!u)
        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(d, this.clonePosition()));
      if (this.bumpSpace(), this.isEOF())
        return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(d, this.clonePosition()));
      switch (this.char()) {
        case 125:
          return this.bump(), {
            val: {
              type: TYPE.argument,
              // value does not include the opening and closing braces.
              value: u,
              location: createLocation(d, this.clonePosition())
            },
            err: null
          };
        case 44:
          return this.bump(), this.bumpSpace(), this.isEOF() ? this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(d, this.clonePosition())) : this.parseArgumentOptions(a, h, u, d);
        default:
          return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(d, this.clonePosition()));
      }
    }, c.prototype.parseIdentifierIfPossible = function() {
      var a = this.clonePosition(), h = this.offset(), d = matchIdentifierAtIndex(this.message, h), u = h + d.length;
      this.bumpTo(u);
      var _ = this.clonePosition(), g = createLocation(a, _);
      return {
        value: d,
        location: g
      };
    }, c.prototype.parseArgumentOptions = function(a, h, d, u) {
      var _, g = this.clonePosition(), $ = this.parseIdentifierIfPossible().value, b = this.clonePosition();
      switch ($) {
        case "":
          return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(g, b));
        case "number":
        case "date":
        case "time": {
          this.bumpSpace();
          var y = null;
          if (this.bumpIf(",")) {
            this.bumpSpace();
            var v = this.clonePosition(), E = this.parseSimpleArgStyleIfPossible();
            if (E.err)
              return E;
            var S = trimEnd(E.val);
            if (S.length === 0)
              return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));
            var R = createLocation(v, this.clonePosition());
            y = {
              style: S,
              styleLocation: R
            };
          }
          var x = this.tryParseArgumentClose(u);
          if (x.err)
            return x;
          var H = createLocation(u, this.clonePosition());
          if (y && startsWith(y == null ? void 0 : y.style, "::", 0)) {
            var T = trimStart(y.style.slice(2));
            if ($ === "number") {
              var E = this.parseNumberSkeletonFromString(T, y.styleLocation);
              return E.err ? E : {
                val: {
                  type: TYPE.number,
                  value: d,
                  location: H,
                  style: E.val
                },
                err: null
              };
            } else {
              if (T.length === 0)
                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, H);
              var C = T;
              this.locale && (C = getBestPattern(T, this.locale));
              var S = {
                type: SKELETON_TYPE.dateTime,
                pattern: C,
                location: y.styleLocation,
                parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(C) : {}
              }, O = $ === "date" ? TYPE.date : TYPE.time;
              return {
                val: {
                  type: O,
                  value: d,
                  location: H,
                  style: S
                },
                err: null
              };
            }
          }
          return {
            val: {
              type: $ === "number" ? TYPE.number : $ === "date" ? TYPE.date : TYPE.time,
              value: d,
              location: H,
              style: (_ = y == null ? void 0 : y.style) !== null && _ !== void 0 ? _ : null
            },
            err: null
          };
        }
        case "plural":
        case "selectordinal":
        case "select": {
          var j = this.clonePosition();
          if (this.bumpSpace(), !this.bumpIf(","))
            return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(j, __assign({}, j)));
          this.bumpSpace();
          var B = this.parseIdentifierIfPossible(), D = 0;
          if ($ !== "select" && B.value === "offset") {
            if (!this.bumpIf(":"))
              return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));
            this.bumpSpace();
            var E = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);
            if (E.err)
              return E;
            this.bumpSpace(), B = this.parseIdentifierIfPossible(), D = E.val;
          }
          var M = this.tryParsePluralOrSelectOptions(a, $, h, B);
          if (M.err)
            return M;
          var x = this.tryParseArgumentClose(u);
          if (x.err)
            return x;
          var I = createLocation(u, this.clonePosition());
          return $ === "select" ? {
            val: {
              type: TYPE.select,
              value: d,
              options: fromEntries(M.val),
              location: I
            },
            err: null
          } : {
            val: {
              type: TYPE.plural,
              value: d,
              options: fromEntries(M.val),
              offset: D,
              pluralType: $ === "plural" ? "cardinal" : "ordinal",
              location: I
            },
            err: null
          };
        }
        default:
          return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(g, b));
      }
    }, c.prototype.tryParseArgumentClose = function(a) {
      return this.isEOF() || this.char() !== 125 ? this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(a, this.clonePosition())) : (this.bump(), {
        val: !0,
        err: null
      });
    }, c.prototype.parseSimpleArgStyleIfPossible = function() {
      for (var a = 0, h = this.clonePosition(); !this.isEOF(); ) {
        var d = this.char();
        switch (d) {
          case 39: {
            this.bump();
            var u = this.clonePosition();
            if (!this.bumpUntil("'"))
              return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(u, this.clonePosition()));
            this.bump();
            break;
          }
          case 123: {
            a += 1, this.bump();
            break;
          }
          case 125: {
            if (a > 0)
              a -= 1;
            else
              return {
                val: this.message.slice(h.offset, this.offset()),
                err: null
              };
            break;
          }
          default:
            this.bump();
            break;
        }
      }
      return {
        val: this.message.slice(h.offset, this.offset()),
        err: null
      };
    }, c.prototype.parseNumberSkeletonFromString = function(a, h) {
      var d = [];
      try {
        d = parseNumberSkeletonFromString(a);
      } catch {
        return this.error(ErrorKind.INVALID_NUMBER_SKELETON, h);
      }
      return {
        val: {
          type: SKELETON_TYPE.number,
          tokens: d,
          location: h,
          parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(d) : {}
        },
        err: null
      };
    }, c.prototype.tryParsePluralOrSelectOptions = function(a, h, d, u) {
      for (var _, g = !1, $ = [], b = /* @__PURE__ */ new Set(), y = u.value, v = u.location; ; ) {
        if (y.length === 0) {
          var E = this.clonePosition();
          if (h !== "select" && this.bumpIf("=")) {
            var S = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);
            if (S.err)
              return S;
            v = createLocation(E, this.clonePosition()), y = this.message.slice(E.offset, this.offset());
          } else
            break;
        }
        if (b.has(y))
          return this.error(h === "select" ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, v);
        y === "other" && (g = !0), this.bumpSpace();
        var R = this.clonePosition();
        if (!this.bumpIf("{"))
          return this.error(h === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));
        var x = this.parseMessage(a + 1, h, d);
        if (x.err)
          return x;
        var H = this.tryParseArgumentClose(R);
        if (H.err)
          return H;
        $.push([y, {
          value: x.val,
          location: createLocation(R, this.clonePosition())
        }]), b.add(y), this.bumpSpace(), _ = this.parseIdentifierIfPossible(), y = _.value, v = _.location;
      }
      return $.length === 0 ? this.error(h === "select" ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition())) : this.requiresOtherClause && !g ? this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition())) : {
        val: $,
        err: null
      };
    }, c.prototype.tryParseDecimalInteger = function(a, h) {
      var d = 1, u = this.clonePosition();
      this.bumpIf("+") || this.bumpIf("-") && (d = -1);
      for (var _ = !1, g = 0; !this.isEOF(); ) {
        var $ = this.char();
        if ($ >= 48 && $ <= 57)
          _ = !0, g = g * 10 + ($ - 48), this.bump();
        else
          break;
      }
      var b = createLocation(u, this.clonePosition());
      return _ ? (g *= d, isSafeInteger(g) ? {
        val: g,
        err: null
      } : this.error(h, b)) : this.error(a, b);
    }, c.prototype.offset = function() {
      return this.position.offset;
    }, c.prototype.isEOF = function() {
      return this.offset() === this.message.length;
    }, c.prototype.clonePosition = function() {
      return {
        offset: this.position.offset,
        line: this.position.line,
        column: this.position.column
      };
    }, c.prototype.char = function() {
      var a = this.position.offset;
      if (a >= this.message.length)
        throw Error("out of bound");
      var h = codePointAt(this.message, a);
      if (h === void 0)
        throw Error("Offset ".concat(a, " is at invalid UTF-16 code unit boundary"));
      return h;
    }, c.prototype.error = function(a, h) {
      return {
        val: null,
        err: {
          kind: a,
          message: this.message,
          location: h
        }
      };
    }, c.prototype.bump = function() {
      if (!this.isEOF()) {
        var a = this.char();
        a === 10 ? (this.position.line += 1, this.position.column = 1, this.position.offset += 1) : (this.position.column += 1, this.position.offset += a < 65536 ? 1 : 2);
      }
    }, c.prototype.bumpIf = function(a) {
      if (startsWith(this.message, a, this.offset())) {
        for (var h = 0; h < a.length; h++)
          this.bump();
        return !0;
      }
      return !1;
    }, c.prototype.bumpUntil = function(a) {
      var h = this.offset(), d = this.message.indexOf(a, h);
      return d >= 0 ? (this.bumpTo(d), !0) : (this.bumpTo(this.message.length), !1);
    }, c.prototype.bumpTo = function(a) {
      if (this.offset() > a)
        throw Error("targetOffset ".concat(a, " must be greater than or equal to the current offset ").concat(this.offset()));
      for (a = Math.min(a, this.message.length); ; ) {
        var h = this.offset();
        if (h === a)
          break;
        if (h > a)
          throw Error("targetOffset ".concat(a, " is at invalid UTF-16 code unit boundary"));
        if (this.bump(), this.isEOF())
          break;
      }
    }, c.prototype.bumpSpace = function() {
      for (; !this.isEOF() && _isWhiteSpace(this.char()); )
        this.bump();
    }, c.prototype.peek = function() {
      if (this.isEOF())
        return null;
      var a = this.char(), h = this.offset(), d = this.message.charCodeAt(h + (a >= 65536 ? 2 : 1));
      return d ?? null;
    }, c;
  }()
);
function _isAlpha(c) {
  return c >= 97 && c <= 122 || c >= 65 && c <= 90;
}
function _isAlphaOrSlash(c) {
  return _isAlpha(c) || c === 47;
}
function _isPotentialElementNameChar(c) {
  return c === 45 || c === 46 || c >= 48 && c <= 57 || c === 95 || c >= 97 && c <= 122 || c >= 65 && c <= 90 || c == 183 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 893 || c >= 895 && c <= 8191 || c >= 8204 && c <= 8205 || c >= 8255 && c <= 8256 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
}
function _isWhiteSpace(c) {
  return c >= 9 && c <= 13 || c === 32 || c === 133 || c >= 8206 && c <= 8207 || c === 8232 || c === 8233;
}
function _isPatternSyntax(c) {
  return c >= 33 && c <= 35 || c === 36 || c >= 37 && c <= 39 || c === 40 || c === 41 || c === 42 || c === 43 || c === 44 || c === 45 || c >= 46 && c <= 47 || c >= 58 && c <= 59 || c >= 60 && c <= 62 || c >= 63 && c <= 64 || c === 91 || c === 92 || c === 93 || c === 94 || c === 96 || c === 123 || c === 124 || c === 125 || c === 126 || c === 161 || c >= 162 && c <= 165 || c === 166 || c === 167 || c === 169 || c === 171 || c === 172 || c === 174 || c === 176 || c === 177 || c === 182 || c === 187 || c === 191 || c === 215 || c === 247 || c >= 8208 && c <= 8213 || c >= 8214 && c <= 8215 || c === 8216 || c === 8217 || c === 8218 || c >= 8219 && c <= 8220 || c === 8221 || c === 8222 || c === 8223 || c >= 8224 && c <= 8231 || c >= 8240 && c <= 8248 || c === 8249 || c === 8250 || c >= 8251 && c <= 8254 || c >= 8257 && c <= 8259 || c === 8260 || c === 8261 || c === 8262 || c >= 8263 && c <= 8273 || c === 8274 || c === 8275 || c >= 8277 && c <= 8286 || c >= 8592 && c <= 8596 || c >= 8597 && c <= 8601 || c >= 8602 && c <= 8603 || c >= 8604 && c <= 8607 || c === 8608 || c >= 8609 && c <= 8610 || c === 8611 || c >= 8612 && c <= 8613 || c === 8614 || c >= 8615 && c <= 8621 || c === 8622 || c >= 8623 && c <= 8653 || c >= 8654 && c <= 8655 || c >= 8656 && c <= 8657 || c === 8658 || c === 8659 || c === 8660 || c >= 8661 && c <= 8691 || c >= 8692 && c <= 8959 || c >= 8960 && c <= 8967 || c === 8968 || c === 8969 || c === 8970 || c === 8971 || c >= 8972 && c <= 8991 || c >= 8992 && c <= 8993 || c >= 8994 && c <= 9e3 || c === 9001 || c === 9002 || c >= 9003 && c <= 9083 || c === 9084 || c >= 9085 && c <= 9114 || c >= 9115 && c <= 9139 || c >= 9140 && c <= 9179 || c >= 9180 && c <= 9185 || c >= 9186 && c <= 9254 || c >= 9255 && c <= 9279 || c >= 9280 && c <= 9290 || c >= 9291 && c <= 9311 || c >= 9472 && c <= 9654 || c === 9655 || c >= 9656 && c <= 9664 || c === 9665 || c >= 9666 && c <= 9719 || c >= 9720 && c <= 9727 || c >= 9728 && c <= 9838 || c === 9839 || c >= 9840 && c <= 10087 || c === 10088 || c === 10089 || c === 10090 || c === 10091 || c === 10092 || c === 10093 || c === 10094 || c === 10095 || c === 10096 || c === 10097 || c === 10098 || c === 10099 || c === 10100 || c === 10101 || c >= 10132 && c <= 10175 || c >= 10176 && c <= 10180 || c === 10181 || c === 10182 || c >= 10183 && c <= 10213 || c === 10214 || c === 10215 || c === 10216 || c === 10217 || c === 10218 || c === 10219 || c === 10220 || c === 10221 || c === 10222 || c === 10223 || c >= 10224 && c <= 10239 || c >= 10240 && c <= 10495 || c >= 10496 && c <= 10626 || c === 10627 || c === 10628 || c === 10629 || c === 10630 || c === 10631 || c === 10632 || c === 10633 || c === 10634 || c === 10635 || c === 10636 || c === 10637 || c === 10638 || c === 10639 || c === 10640 || c === 10641 || c === 10642 || c === 10643 || c === 10644 || c === 10645 || c === 10646 || c === 10647 || c === 10648 || c >= 10649 && c <= 10711 || c === 10712 || c === 10713 || c === 10714 || c === 10715 || c >= 10716 && c <= 10747 || c === 10748 || c === 10749 || c >= 10750 && c <= 11007 || c >= 11008 && c <= 11055 || c >= 11056 && c <= 11076 || c >= 11077 && c <= 11078 || c >= 11079 && c <= 11084 || c >= 11085 && c <= 11123 || c >= 11124 && c <= 11125 || c >= 11126 && c <= 11157 || c === 11158 || c >= 11159 && c <= 11263 || c >= 11776 && c <= 11777 || c === 11778 || c === 11779 || c === 11780 || c === 11781 || c >= 11782 && c <= 11784 || c === 11785 || c === 11786 || c === 11787 || c === 11788 || c === 11789 || c >= 11790 && c <= 11798 || c === 11799 || c >= 11800 && c <= 11801 || c === 11802 || c === 11803 || c === 11804 || c === 11805 || c >= 11806 && c <= 11807 || c === 11808 || c === 11809 || c === 11810 || c === 11811 || c === 11812 || c === 11813 || c === 11814 || c === 11815 || c === 11816 || c === 11817 || c >= 11818 && c <= 11822 || c === 11823 || c >= 11824 && c <= 11833 || c >= 11834 && c <= 11835 || c >= 11836 && c <= 11839 || c === 11840 || c === 11841 || c === 11842 || c >= 11843 && c <= 11855 || c >= 11856 && c <= 11857 || c === 11858 || c >= 11859 && c <= 11903 || c >= 12289 && c <= 12291 || c === 12296 || c === 12297 || c === 12298 || c === 12299 || c === 12300 || c === 12301 || c === 12302 || c === 12303 || c === 12304 || c === 12305 || c >= 12306 && c <= 12307 || c === 12308 || c === 12309 || c === 12310 || c === 12311 || c === 12312 || c === 12313 || c === 12314 || c === 12315 || c === 12316 || c === 12317 || c >= 12318 && c <= 12319 || c === 12320 || c === 12336 || c === 64830 || c === 64831 || c >= 65093 && c <= 65094;
}
function pruneLocation(c) {
  c.forEach(function(a) {
    if (delete a.location, isSelectElement(a) || isPluralElement(a))
      for (var h in a.options)
        delete a.options[h].location, pruneLocation(a.options[h].value);
    else isNumberElement(a) && isNumberSkeleton(a.style) || (isDateElement(a) || isTimeElement(a)) && isDateTimeSkeleton(a.style) ? delete a.style.location : isTagElement(a) && pruneLocation(a.children);
  });
}
function parse(c, a) {
  a === void 0 && (a = {}), a = __assign({
    shouldParseSkeletons: !0,
    requiresOtherClause: !0
  }, a);
  var h = new Parser(c, a).parse();
  if (h.err) {
    var d = SyntaxError(ErrorKind[h.err.kind]);
    throw d.location = h.err.location, d.originalMessage = h.err.message, d;
  }
  return a != null && a.captureLocation || pruneLocation(h.val), h.val;
}
var ErrorCode;
(function(c) {
  c.MISSING_VALUE = "MISSING_VALUE", c.INVALID_VALUE = "INVALID_VALUE", c.MISSING_INTL_API = "MISSING_INTL_API";
})(ErrorCode || (ErrorCode = {}));
var FormatError = (
  /** @class */
  function(c) {
    __extends(a, c);
    function a(h, d, u) {
      var _ = c.call(this, h) || this;
      return _.code = d, _.originalMessage = u, _;
    }
    return a.prototype.toString = function() {
      return "[formatjs Error: ".concat(this.code, "] ").concat(this.message);
    }, a;
  }(Error)
), InvalidValueError = (
  /** @class */
  function(c) {
    __extends(a, c);
    function a(h, d, u, _) {
      return c.call(this, 'Invalid values for "'.concat(h, '": "').concat(d, '". Options are "').concat(Object.keys(u).join('", "'), '"'), ErrorCode.INVALID_VALUE, _) || this;
    }
    return a;
  }(FormatError)
), InvalidValueTypeError = (
  /** @class */
  function(c) {
    __extends(a, c);
    function a(h, d, u) {
      return c.call(this, 'Value for "'.concat(h, '" must be of type ').concat(d), ErrorCode.INVALID_VALUE, u) || this;
    }
    return a;
  }(FormatError)
), MissingValueError = (
  /** @class */
  function(c) {
    __extends(a, c);
    function a(h, d) {
      return c.call(this, 'The intl string context variable "'.concat(h, '" was not provided to the string "').concat(d, '"'), ErrorCode.MISSING_VALUE, d) || this;
    }
    return a;
  }(FormatError)
), PART_TYPE;
(function(c) {
  c[c.literal = 0] = "literal", c[c.object = 1] = "object";
})(PART_TYPE || (PART_TYPE = {}));
function mergeLiteral(c) {
  return c.length < 2 ? c : c.reduce(function(a, h) {
    var d = a[a.length - 1];
    return !d || d.type !== PART_TYPE.literal || h.type !== PART_TYPE.literal ? a.push(h) : d.value += h.value, a;
  }, []);
}
function isFormatXMLElementFn(c) {
  return typeof c == "function";
}
function formatToParts(c, a, h, d, u, _, g) {
  if (c.length === 1 && isLiteralElement(c[0]))
    return [{
      type: PART_TYPE.literal,
      value: c[0].value
    }];
  for (var $ = [], b = 0, y = c; b < y.length; b++) {
    var v = y[b];
    if (isLiteralElement(v)) {
      $.push({
        type: PART_TYPE.literal,
        value: v.value
      });
      continue;
    }
    if (isPoundElement(v)) {
      typeof _ == "number" && $.push({
        type: PART_TYPE.literal,
        value: h.getNumberFormat(a).format(_)
      });
      continue;
    }
    var E = v.value;
    if (!(u && E in u))
      throw new MissingValueError(E, g);
    var S = u[E];
    if (isArgumentElement(v)) {
      (!S || typeof S == "string" || typeof S == "number") && (S = typeof S == "string" || typeof S == "number" ? String(S) : ""), $.push({
        type: typeof S == "string" ? PART_TYPE.literal : PART_TYPE.object,
        value: S
      });
      continue;
    }
    if (isDateElement(v)) {
      var R = typeof v.style == "string" ? d.date[v.style] : isDateTimeSkeleton(v.style) ? v.style.parsedOptions : void 0;
      $.push({
        type: PART_TYPE.literal,
        value: h.getDateTimeFormat(a, R).format(S)
      });
      continue;
    }
    if (isTimeElement(v)) {
      var R = typeof v.style == "string" ? d.time[v.style] : isDateTimeSkeleton(v.style) ? v.style.parsedOptions : d.time.medium;
      $.push({
        type: PART_TYPE.literal,
        value: h.getDateTimeFormat(a, R).format(S)
      });
      continue;
    }
    if (isNumberElement(v)) {
      var R = typeof v.style == "string" ? d.number[v.style] : isNumberSkeleton(v.style) ? v.style.parsedOptions : void 0;
      R && R.scale && (S = S * (R.scale || 1)), $.push({
        type: PART_TYPE.literal,
        value: h.getNumberFormat(a, R).format(S)
      });
      continue;
    }
    if (isTagElement(v)) {
      var x = v.children, H = v.value, T = u[H];
      if (!isFormatXMLElementFn(T))
        throw new InvalidValueTypeError(H, "function", g);
      var C = formatToParts(x, a, h, d, u, _), O = T(C.map(function(D) {
        return D.value;
      }));
      Array.isArray(O) || (O = [O]), $.push.apply($, O.map(function(D) {
        return {
          type: typeof D == "string" ? PART_TYPE.literal : PART_TYPE.object,
          value: D
        };
      }));
    }
    if (isSelectElement(v)) {
      var j = v.options[S] || v.options.other;
      if (!j)
        throw new InvalidValueError(v.value, S, Object.keys(v.options), g);
      $.push.apply($, formatToParts(j.value, a, h, d, u));
      continue;
    }
    if (isPluralElement(v)) {
      var j = v.options["=".concat(S)];
      if (!j) {
        if (!Intl.PluralRules)
          throw new FormatError(`Intl.PluralRules is not available in this environment.
Try polyfilling it using "@formatjs/intl-pluralrules"
`, ErrorCode.MISSING_INTL_API, g);
        var B = h.getPluralRules(a, {
          type: v.pluralType
        }).select(S - (v.offset || 0));
        j = v.options[B] || v.options.other;
      }
      if (!j)
        throw new InvalidValueError(v.value, S, Object.keys(v.options), g);
      $.push.apply($, formatToParts(j.value, a, h, d, u, S - (v.offset || 0)));
      continue;
    }
  }
  return mergeLiteral($);
}
function mergeConfig(c, a) {
  return a ? __assign(__assign(__assign({}, c || {}), a || {}), Object.keys(c).reduce(function(h, d) {
    return h[d] = __assign(__assign({}, c[d]), a[d] || {}), h;
  }, {})) : c;
}
function mergeConfigs(c, a) {
  return a ? Object.keys(c).reduce(function(h, d) {
    return h[d] = mergeConfig(c[d], a[d]), h;
  }, __assign({}, c)) : c;
}
function createFastMemoizeCache(c) {
  return {
    create: function() {
      return {
        get: function(a) {
          return c[a];
        },
        set: function(a, h) {
          c[a] = h;
        }
      };
    }
  };
}
function createDefaultFormatters(c) {
  return c === void 0 && (c = {
    number: {},
    dateTime: {},
    pluralRules: {}
  }), {
    getNumberFormat: memoize(function() {
      for (var a, h = [], d = 0; d < arguments.length; d++)
        h[d] = arguments[d];
      return new ((a = Intl.NumberFormat).bind.apply(a, __spreadArray([void 0], h, !1)))();
    }, {
      cache: createFastMemoizeCache(c.number),
      strategy: strategies.variadic
    }),
    getDateTimeFormat: memoize(function() {
      for (var a, h = [], d = 0; d < arguments.length; d++)
        h[d] = arguments[d];
      return new ((a = Intl.DateTimeFormat).bind.apply(a, __spreadArray([void 0], h, !1)))();
    }, {
      cache: createFastMemoizeCache(c.dateTime),
      strategy: strategies.variadic
    }),
    getPluralRules: memoize(function() {
      for (var a, h = [], d = 0; d < arguments.length; d++)
        h[d] = arguments[d];
      return new ((a = Intl.PluralRules).bind.apply(a, __spreadArray([void 0], h, !1)))();
    }, {
      cache: createFastMemoizeCache(c.pluralRules),
      strategy: strategies.variadic
    })
  };
}
var IntlMessageFormat = (
  /** @class */
  function() {
    function c(a, h, d, u) {
      h === void 0 && (h = c.defaultLocale);
      var _ = this;
      if (this.formatterCache = {
        number: {},
        dateTime: {},
        pluralRules: {}
      }, this.format = function(b) {
        var y = _.formatToParts(b);
        if (y.length === 1)
          return y[0].value;
        var v = y.reduce(function(E, S) {
          return !E.length || S.type !== PART_TYPE.literal || typeof E[E.length - 1] != "string" ? E.push(S.value) : E[E.length - 1] += S.value, E;
        }, []);
        return v.length <= 1 ? v[0] || "" : v;
      }, this.formatToParts = function(b) {
        return formatToParts(_.ast, _.locales, _.formatters, _.formats, b, void 0, _.message);
      }, this.resolvedOptions = function() {
        var b;
        return {
          locale: ((b = _.resolvedLocale) === null || b === void 0 ? void 0 : b.toString()) || Intl.NumberFormat.supportedLocalesOf(_.locales)[0]
        };
      }, this.getAst = function() {
        return _.ast;
      }, this.locales = h, this.resolvedLocale = c.resolveLocale(h), typeof a == "string") {
        if (this.message = a, !c.__parse)
          throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
        var g = u || {};
        g.formatters;
        var $ = __rest(g, ["formatters"]);
        this.ast = c.__parse(a, __assign(__assign({}, $), {
          locale: this.resolvedLocale
        }));
      } else
        this.ast = a;
      if (!Array.isArray(this.ast))
        throw new TypeError("A message must be provided as a String or AST.");
      this.formats = mergeConfigs(c.formats, d), this.formatters = u && u.formatters || createDefaultFormatters(this.formatterCache);
    }
    return Object.defineProperty(c, "defaultLocale", {
      get: function() {
        return c.memoizedDefaultLocale || (c.memoizedDefaultLocale = new Intl.NumberFormat().resolvedOptions().locale), c.memoizedDefaultLocale;
      },
      enumerable: !1,
      configurable: !0
    }), c.memoizedDefaultLocale = null, c.resolveLocale = function(a) {
      if (!(typeof Intl.Locale > "u")) {
        var h = Intl.NumberFormat.supportedLocalesOf(a);
        return h.length > 0 ? new Intl.Locale(h[0]) : new Intl.Locale(typeof a == "string" ? a : a[0]);
      }
    }, c.__parse = parse, c.formats = {
      number: {
        integer: {
          maximumFractionDigits: 0
        },
        currency: {
          style: "currency"
        },
        percent: {
          style: "percent"
        }
      },
      date: {
        short: {
          month: "numeric",
          day: "numeric",
          year: "2-digit"
        },
        medium: {
          month: "short",
          day: "numeric",
          year: "numeric"
        },
        long: {
          month: "long",
          day: "numeric",
          year: "numeric"
        },
        full: {
          weekday: "long",
          month: "long",
          day: "numeric",
          year: "numeric"
        }
      },
      time: {
        short: {
          hour: "numeric",
          minute: "numeric"
        },
        medium: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric"
        },
        long: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        },
        full: {
          hour: "numeric",
          minute: "numeric",
          second: "numeric",
          timeZoneName: "short"
        }
      }
    }, c;
  }()
);
function delve(c, a) {
  if (a == null) return;
  if (a in c)
    return c[a];
  const h = a.split(".");
  let d = c;
  for (let u = 0; u < h.length; u++)
    if (typeof d == "object") {
      if (u > 0) {
        const _ = h.slice(u, h.length).join(".");
        if (_ in d) {
          d = d[_];
          break;
        }
      }
      d = d[h[u]];
    } else
      d = void 0;
  return d;
}
const lookupCache = {}, addToCache = (c, a, h) => h && (a in lookupCache || (lookupCache[a] = {}), c in lookupCache[a] || (lookupCache[a][c] = h), h), lookup = (c, a) => {
  if (a == null) return;
  if (a in lookupCache && c in lookupCache[a])
    return lookupCache[a][c];
  const h = getPossibleLocales(a);
  for (let d = 0; d < h.length; d++) {
    const u = h[d], _ = getMessageFromDictionary(u, c);
    if (_)
      return addToCache(c, a, _);
  }
};
let dictionary;
const $dictionary = writable({});
function getLocaleDictionary(c) {
  return dictionary[c] || null;
}
function hasLocaleDictionary(c) {
  return c in dictionary;
}
function getMessageFromDictionary(c, a) {
  if (!hasLocaleDictionary(c))
    return null;
  const h = getLocaleDictionary(c);
  return delve(h, a);
}
function getClosestAvailableLocale(c) {
  if (c == null) return;
  const a = getPossibleLocales(c);
  for (let h = 0; h < a.length; h++) {
    const d = a[h];
    if (hasLocaleDictionary(d))
      return d;
  }
}
function addMessages(c, ...a) {
  delete lookupCache[c], $dictionary.update((h) => (h[c] = deepmerge$1.all([h[c] || {}, ...a]), h));
}
derived([$dictionary], ([c]) => Object.keys(c));
$dictionary.subscribe((c) => dictionary = c);
const queue = {};
function removeLoaderFromQueue(c, a) {
  queue[c].delete(a), queue[c].size === 0 && delete queue[c];
}
function getLocaleQueue(c) {
  return queue[c];
}
function getLocalesQueues(c) {
  return getPossibleLocales(c).map((a) => {
    const h = getLocaleQueue(a);
    return [a, h ? [...h] : []];
  }).filter(([, a]) => a.length > 0);
}
function hasLocaleQueue(c) {
  return c == null ? !1 : getPossibleLocales(c).some((a) => {
    var h;
    return (h = getLocaleQueue(a)) == null ? void 0 : h.size;
  });
}
function loadLocaleQueue(c, a) {
  return Promise.all(a.map((d) => (removeLoaderFromQueue(c, d), d().then((u) => u.default || u)))).then((d) => addMessages(c, ...d));
}
const activeFlushes = {};
function flush$1(c) {
  if (!hasLocaleQueue(c))
    return c in activeFlushes ? activeFlushes[c] : Promise.resolve();
  const a = getLocalesQueues(c);
  return activeFlushes[c] = Promise.all(a.map(([h, d]) => loadLocaleQueue(h, d))).then(() => {
    if (hasLocaleQueue(c))
      return flush$1(c);
    delete activeFlushes[c];
  }), activeFlushes[c];
}
const defaultFormats = {
  number: {
    scientific: {
      notation: "scientific"
    },
    engineering: {
      notation: "engineering"
    },
    compactLong: {
      notation: "compact",
      compactDisplay: "long"
    },
    compactShort: {
      notation: "compact",
      compactDisplay: "short"
    }
  },
  date: {
    short: {
      month: "numeric",
      day: "numeric",
      year: "2-digit"
    },
    medium: {
      month: "short",
      day: "numeric",
      year: "numeric"
    },
    long: {
      month: "long",
      day: "numeric",
      year: "numeric"
    },
    full: {
      weekday: "long",
      month: "long",
      day: "numeric",
      year: "numeric"
    }
  },
  time: {
    short: {
      hour: "numeric",
      minute: "numeric"
    },
    medium: {
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    },
    long: {
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      timeZoneName: "short"
    },
    full: {
      hour: "numeric",
      minute: "numeric",
      second: "numeric",
      timeZoneName: "short"
    }
  }
}, defaultOptions = {
  fallbackLocale: null,
  loadingDelay: 200,
  formats: defaultFormats,
  warnOnMissingMessages: !0,
  handleMissingMessage: void 0,
  ignoreTag: !0
}, options = defaultOptions;
function getOptions() {
  return options;
}
const $isLoading = writable(!1);
var __defProp$1 = Object.defineProperty, __defProps = Object.defineProperties, __getOwnPropDescs = Object.getOwnPropertyDescriptors, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (c, a, h) => a in c ? __defProp$1(c, a, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: h
}) : c[a] = h, __spreadValues$1 = (c, a) => {
  for (var h in a || (a = {})) __hasOwnProp$1.call(a, h) && __defNormalProp$1(c, h, a[h]);
  if (__getOwnPropSymbols$1) for (var h of __getOwnPropSymbols$1(a))
    __propIsEnum$1.call(a, h) && __defNormalProp$1(c, h, a[h]);
  return c;
}, __spreadProps = (c, a) => __defProps(c, __getOwnPropDescs(a));
let current;
const internalLocale = writable(null);
function getSubLocales(c) {
  return c.split("-").map((a, h, d) => d.slice(0, h + 1).join("-")).reverse();
}
function getPossibleLocales(c, a = getOptions().fallbackLocale) {
  const h = getSubLocales(c);
  return a ? [.../* @__PURE__ */ new Set([...h, ...getSubLocales(a)])] : h;
}
function getCurrentLocale() {
  return current ?? void 0;
}
internalLocale.subscribe((c) => {
  current = c ?? void 0, typeof window < "u" && c != null && document.documentElement.setAttribute("lang", c);
});
const set = (c) => {
  if (c && getClosestAvailableLocale(c) && hasLocaleQueue(c)) {
    const {
      loadingDelay: a
    } = getOptions();
    let h;
    return typeof window < "u" && getCurrentLocale() != null && a ? h = window.setTimeout(() => $isLoading.set(!0), a) : $isLoading.set(!0), flush$1(c).then(() => {
      internalLocale.set(c);
    }).finally(() => {
      clearTimeout(h), $isLoading.set(!1);
    });
  }
  return internalLocale.set(c);
}, $locale = __spreadProps(__spreadValues$1({}, internalLocale), {
  set
}), getLocaleFromNavigator = () => typeof window > "u" ? null : window.navigator.language || window.navigator.languages[0], monadicMemoize = (c) => {
  const a = /* @__PURE__ */ Object.create(null);
  return (d) => {
    const u = JSON.stringify(d);
    return u in a ? a[u] : a[u] = c(d);
  };
};
var __defProp = Object.defineProperty, __getOwnPropSymbols = Object.getOwnPropertySymbols, __hasOwnProp = Object.prototype.hasOwnProperty, __propIsEnum = Object.prototype.propertyIsEnumerable, __defNormalProp = (c, a, h) => a in c ? __defProp(c, a, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: h
}) : c[a] = h, __spreadValues = (c, a) => {
  for (var h in a || (a = {})) __hasOwnProp.call(a, h) && __defNormalProp(c, h, a[h]);
  if (__getOwnPropSymbols) for (var h of __getOwnPropSymbols(a))
    __propIsEnum.call(a, h) && __defNormalProp(c, h, a[h]);
  return c;
}, __objRest = (c, a) => {
  var h = {};
  for (var d in c) __hasOwnProp.call(c, d) && a.indexOf(d) < 0 && (h[d] = c[d]);
  if (c != null && __getOwnPropSymbols) for (var d of __getOwnPropSymbols(c))
    a.indexOf(d) < 0 && __propIsEnum.call(c, d) && (h[d] = c[d]);
  return h;
};
const getIntlFormatterOptions = (c, a) => {
  const {
    formats: h
  } = getOptions();
  if (c in h && a in h[c])
    return h[c][a];
  throw new Error(`[svelte-i18n] Unknown "${a}" ${c} format.`);
}, createNumberFormatter = monadicMemoize((c) => {
  var a = c, {
    locale: h,
    format: d
  } = a, u = __objRest(a, ["locale", "format"]);
  if (h == null)
    throw new Error('[svelte-i18n] A "locale" must be set to format numbers');
  return d && (u = getIntlFormatterOptions("number", d)), new Intl.NumberFormat(h, u);
}), createDateFormatter = monadicMemoize((c) => {
  var a = c, {
    locale: h,
    format: d
  } = a, u = __objRest(a, ["locale", "format"]);
  if (h == null)
    throw new Error('[svelte-i18n] A "locale" must be set to format dates');
  return d ? u = getIntlFormatterOptions("date", d) : Object.keys(u).length === 0 && (u = getIntlFormatterOptions("date", "short")), new Intl.DateTimeFormat(h, u);
}), createTimeFormatter = monadicMemoize((c) => {
  var a = c, {
    locale: h,
    format: d
  } = a, u = __objRest(a, ["locale", "format"]);
  if (h == null)
    throw new Error('[svelte-i18n] A "locale" must be set to format time values');
  return d ? u = getIntlFormatterOptions("time", d) : Object.keys(u).length === 0 && (u = getIntlFormatterOptions("time", "short")), new Intl.DateTimeFormat(h, u);
}), getNumberFormatter = (c = {}) => {
  var a = c, {
    locale: h = getCurrentLocale()
  } = a, d = __objRest(a, ["locale"]);
  return createNumberFormatter(__spreadValues({
    locale: h
  }, d));
}, getDateFormatter = (c = {}) => {
  var a = c, {
    locale: h = getCurrentLocale()
  } = a, d = __objRest(a, ["locale"]);
  return createDateFormatter(__spreadValues({
    locale: h
  }, d));
}, getTimeFormatter = (c = {}) => {
  var a = c, {
    locale: h = getCurrentLocale()
  } = a, d = __objRest(a, ["locale"]);
  return createTimeFormatter(__spreadValues({
    locale: h
  }, d));
}, getMessageFormatter = monadicMemoize(
  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
  (c, a = getCurrentLocale()) => new IntlMessageFormat(c, a, getOptions().formats, {
    ignoreTag: getOptions().ignoreTag
  })
), formatMessage = (c, a = {}) => {
  var h, d, u, _;
  let g = a;
  typeof c == "object" && (g = c, c = g.id);
  const {
    values: $,
    locale: b = getCurrentLocale(),
    default: y
  } = g;
  if (b == null)
    throw new Error("[svelte-i18n] Cannot format a message without first setting the initial locale.");
  let v = lookup(c, b);
  if (!v)
    v = (_ = (u = (d = (h = getOptions()).handleMissingMessage) == null ? void 0 : d.call(h, {
      locale: b,
      id: c,
      defaultValue: y
    })) != null ? u : y) != null ? _ : c;
  else if (typeof v != "string")
    return console.warn(`[svelte-i18n] Message with id "${c}" must be of type "string", found: "${typeof v}". Gettin its value through the "$format" method is deprecated; use the "json" method instead.`), v;
  if (!$)
    return v;
  let E = v;
  try {
    E = getMessageFormatter(v, b).format($);
  } catch (S) {
    S instanceof Error && console.warn(`[svelte-i18n] Message "${c}" has syntax error:`, S.message);
  }
  return E;
}, formatTime = (c, a) => getTimeFormatter(a).format(c), formatDate = (c, a) => getDateFormatter(a).format(c), formatNumber = (c, a) => getNumberFormatter(a).format(c), getJSON = (c, a = getCurrentLocale()) => lookup(c, a);
derived([$locale, $dictionary], () => formatMessage);
derived([$locale], () => formatTime);
derived([$locale], () => formatDate);
derived([$locale], () => formatNumber);
derived([$locale, $dictionary], () => getJSON);
const {
  SvelteComponent: SvelteComponent$d,
  assign: assign$5,
  attr: attr$8,
  binding_callbacks: binding_callbacks$5,
  children: children$8,
  claim_element: claim_element$7,
  compute_rest_props: compute_rest_props$2,
  detach: detach$a,
  element: element$7,
  exclude_internal_props: exclude_internal_props$2,
  init: init$d,
  insert_hydration: insert_hydration$a,
  noop: noop$4,
  safe_not_equal: safe_not_equal$d
} = window.__gradio__svelte__internal, {
  afterUpdate: afterUpdate$1,
  onDestroy
} = window.__gradio__svelte__internal;
function create_fragment$c(c) {
  let a, h;
  return {
    c() {
      a = element$7("div"), this.h();
    },
    l(d) {
      a = claim_element$7(d, "DIV", {
        class: !0,
        style: !0
      }), children$8(a).forEach(detach$a), this.h();
    },
    h() {
      attr$8(a, "class", h = /*elem_classes*/
      c[1].join(" ")), attr$8(
        a,
        "style",
        /*elem_style*/
        c[0]
      );
    },
    m(d, u) {
      insert_hydration$a(d, a, u), c[5](a);
    },
    p(d, [u]) {
      u & /*elem_classes*/
      2 && h !== (h = /*elem_classes*/
      d[1].join(" ")) && attr$8(a, "class", h), u & /*elem_style*/
      1 && attr$8(
        a,
        "style",
        /*elem_style*/
        d[0]
      );
    },
    i: noop$4,
    o: noop$4,
    d(d) {
      d && detach$a(a), c[5](null);
    }
  };
}
function instance$a(c, a, h) {
  const d = ["component", "elem_style", "elem_classes", "theme"];
  let u = compute_rest_props$2(a, d), {
    component: _
  } = a, {
    elem_style: g = ""
  } = a, {
    elem_classes: $ = []
  } = a, {
    theme: b = "light"
  } = a, y = null, v;
  const E = getLocaleFromNavigator();
  afterUpdate$1(() => {
    y && (v = mount(y, _, {
      children: null,
      ...u,
      theme: b,
      locale: E
    }, v));
  }), onDestroy(() => {
    v == null || v.unmount();
  });
  function S(R) {
    binding_callbacks$5[R ? "unshift" : "push"](() => {
      y = R, h(2, y);
    });
  }
  return c.$$set = (R) => {
    a = assign$5(assign$5({}, a), exclude_internal_props$2(R)), h(8, u = compute_rest_props$2(a, d)), "component" in R && h(3, _ = R.component), "elem_style" in R && h(0, g = R.elem_style), "elem_classes" in R && h(1, $ = R.elem_classes), "theme" in R && h(4, b = R.theme);
  }, [g, $, y, _, b, S];
}
class ReactComponent extends SvelteComponent$d {
  constructor(a) {
    super(), init$d(this, a, instance$a, create_fragment$c, safe_not_equal$d, {
      component: 3,
      elem_style: 0,
      elem_classes: 1,
      theme: 4
    });
  }
}
const {
  SvelteComponent: SvelteComponent$c,
  assign: assign$4,
  claim_component: claim_component$a,
  compute_rest_props: compute_rest_props$1,
  create_component: create_component$a,
  destroy_component: destroy_component$a,
  exclude_internal_props: exclude_internal_props$1,
  get_spread_object: get_spread_object$4,
  get_spread_update: get_spread_update$4,
  init: init$c,
  mount_component: mount_component$a,
  safe_not_equal: safe_not_equal$c,
  transition_in: transition_in$b,
  transition_out: transition_out$b
} = window.__gradio__svelte__internal;
function create_fragment$b(c) {
  let a, h;
  const d = [
    /*$$restProps*/
    c[2],
    {
      component: FileView
    },
    {
      elem_classes: (
        /*elem_classes*/
        c[1]
      )
    },
    {
      elem_style: (
        /*elem_style*/
        c[0]
      )
    }
  ];
  let u = {};
  for (let _ = 0; _ < d.length; _ += 1)
    u = assign$4(u, d[_]);
  return a = new ReactComponent({
    props: u
  }), {
    c() {
      create_component$a(a.$$.fragment);
    },
    l(_) {
      claim_component$a(a.$$.fragment, _);
    },
    m(_, g) {
      mount_component$a(a, _, g), h = !0;
    },
    p(_, [g]) {
      const $ = g & /*$$restProps, elem_classes, elem_style*/
      7 ? get_spread_update$4(d, [g & /*$$restProps*/
      4 && get_spread_object$4(
        /*$$restProps*/
        _[2]
      ), d[1], g & /*elem_classes*/
      2 && {
        elem_classes: (
          /*elem_classes*/
          _[1]
        )
      }, g & /*elem_style*/
      1 && {
        elem_style: (
          /*elem_style*/
          _[0]
        )
      }]) : {};
      a.$set($);
    },
    i(_) {
      h || (transition_in$b(a.$$.fragment, _), h = !0);
    },
    o(_) {
      transition_out$b(a.$$.fragment, _), h = !1;
    },
    d(_) {
      destroy_component$a(a, _);
    }
  };
}
function instance$9(c, a, h) {
  const d = ["elem_style", "elem_classes"];
  let u = compute_rest_props$1(a, d), {
    elem_style: _ = ""
  } = a, {
    elem_classes: g = []
  } = a;
  return c.$$set = ($) => {
    a = assign$4(assign$4({}, a), exclude_internal_props$1($)), h(2, u = compute_rest_props$1(a, d)), "elem_style" in $ && h(0, _ = $.elem_style), "elem_classes" in $ && h(1, g = $.elem_classes);
  }, [_, g, u];
}
let FileView_1$1 = class extends SvelteComponent$c {
  constructor(a) {
    super(), init$c(this, a, instance$9, create_fragment$b, safe_not_equal$c, {
      elem_style: 0,
      elem_classes: 1
    });
  }
};
const {
  SvelteComponent: SvelteComponent$b,
  assign: assign$3,
  claim_component: claim_component$9,
  compute_rest_props,
  create_component: create_component$9,
  destroy_component: destroy_component$9,
  exclude_internal_props,
  get_spread_object: get_spread_object$3,
  get_spread_update: get_spread_update$3,
  init: init$b,
  mount_component: mount_component$9,
  safe_not_equal: safe_not_equal$b,
  transition_in: transition_in$a,
  transition_out: transition_out$a
} = window.__gradio__svelte__internal;
function create_fragment$a(c) {
  let a, h;
  const d = [
    /*$$restProps*/
    c[7],
    {
      theme: (
        /*theme*/
        c[0]
      )
    },
    {
      disabled: (
        /*type*/
        c[6] === "link" ? (
          /*link_disabled*/
          c[2]
        ) : void 0
      )
    },
    {
      elem_classes: (
        /*elem_classes*/
        c[4]
      )
    },
    {
      elem_style: (
        /*elem_style*/
        c[3]
      )
    },
    {
      type: (
        /*type*/
        c[6]
      )
    },
    {
      url: (
        /*file*/
        c[1].url
      )
    },
    {
      title: (
        /*alt_text*/
        c[5]
      )
    },
    {
      filename: window.__is_colab__ ? null : (
        /*file*/
        c[1].orig_name || /*file*/
        c[1].path
      )
    }
  ];
  let u = {};
  for (let _ = 0; _ < d.length; _ += 1)
    u = assign$3(u, d[_]);
  return a = new FileView_1$1({
    props: u
  }), {
    c() {
      create_component$9(a.$$.fragment);
    },
    l(_) {
      claim_component$9(a.$$.fragment, _);
    },
    m(_, g) {
      mount_component$9(a, _, g), h = !0;
    },
    p(_, [g]) {
      const $ = g & /*$$restProps, theme, type, link_disabled, undefined, elem_classes, elem_style, file, alt_text, window*/
      255 ? get_spread_update$3(d, [g & /*$$restProps*/
      128 && get_spread_object$3(
        /*$$restProps*/
        _[7]
      ), g & /*theme*/
      1 && {
        theme: (
          /*theme*/
          _[0]
        )
      }, g & /*type, link_disabled, undefined*/
      68 && {
        disabled: (
          /*type*/
          _[6] === "link" ? (
            /*link_disabled*/
            _[2]
          ) : void 0
        )
      }, g & /*elem_classes*/
      16 && {
        elem_classes: (
          /*elem_classes*/
          _[4]
        )
      }, g & /*elem_style*/
      8 && {
        elem_style: (
          /*elem_style*/
          _[3]
        )
      }, g & /*type*/
      64 && {
        type: (
          /*type*/
          _[6]
        )
      }, g & /*file*/
      2 && {
        url: (
          /*file*/
          _[1].url
        )
      }, g & /*alt_text*/
      32 && {
        title: (
          /*alt_text*/
          _[5]
        )
      }, g & /*window, file*/
      2 && {
        filename: window.__is_colab__ ? null : (
          /*file*/
          _[1].orig_name || /*file*/
          _[1].path
        )
      }]) : {};
      a.$set($);
    },
    i(_) {
      h || (transition_in$a(a.$$.fragment, _), h = !0);
    },
    o(_) {
      transition_out$a(a.$$.fragment, _), h = !1;
    },
    d(_) {
      destroy_component$9(a, _);
    }
  };
}
function instance$8(c, a, h) {
  let d;
  const u = ["theme", "file", "link_disabled", "excludes", "elem_style", "elem_classes", "alt_text"];
  let _ = compute_rest_props(a, u), {
    theme: g = "light"
  } = a, {
    file: $
  } = a, {
    link_disabled: b = !1
  } = a, {
    excludes: y = []
  } = a, {
    elem_style: v = ""
  } = a, {
    elem_classes: E = []
  } = a, {
    alt_text: S = $.alt_text || $.orig_name
  } = a;
  function R(x = "") {
    let H = "link";
    return x.includes("audio") ? H = "audio" : x.includes("video") ? H = "video" : x.includes("image") && (H = "image"), y.includes(H) ? "link" : H;
  }
  return c.$$set = (x) => {
    a = assign$3(assign$3({}, a), exclude_internal_props(x)), h(7, _ = compute_rest_props(a, u)), "theme" in x && h(0, g = x.theme), "file" in x && h(1, $ = x.file), "link_disabled" in x && h(2, b = x.link_disabled), "excludes" in x && h(8, y = x.excludes), "elem_style" in x && h(3, v = x.elem_style), "elem_classes" in x && h(4, E = x.elem_classes), "alt_text" in x && h(5, S = x.alt_text);
  }, c.$$.update = () => {
    c.$$.dirty & /*file*/
    2 && h(6, d = R($.mime_type || ""));
  }, [g, $, b, v, E, S, d, _, y];
}
class FileView_1 extends SvelteComponent$b {
  constructor(a) {
    super(), init$b(this, a, instance$8, create_fragment$a, safe_not_equal$b, {
      theme: 0,
      file: 1,
      link_disabled: 2,
      excludes: 8,
      elem_style: 3,
      elem_classes: 4,
      alt_text: 5
    });
  }
}
const {
  SvelteComponent: SvelteComponent$a,
  claim_component: claim_component$8,
  create_component: create_component$8,
  destroy_component: destroy_component$8,
  init: init$a,
  mount_component: mount_component$8,
  noop: noop$3,
  safe_not_equal: safe_not_equal$a,
  transition_in: transition_in$9,
  transition_out: transition_out$9
} = window.__gradio__svelte__internal;
function create_fragment$9(c) {
  let a, h;
  return a = new Static({
    props: {
      queue_position: null,
      queue_size: null,
      i18n: func$1,
      autoscroll: !1,
      timer: !1,
      loading_text: "",
      status: "pending"
    }
  }), {
    c() {
      create_component$8(a.$$.fragment);
    },
    l(d) {
      claim_component$8(a.$$.fragment, d);
    },
    m(d, u) {
      mount_component$8(a, d, u), h = !0;
    },
    p: noop$3,
    i(d) {
      h || (transition_in$9(a.$$.fragment, d), h = !0);
    },
    o(d) {
      transition_out$9(a.$$.fragment, d), h = !1;
    },
    d(d) {
      destroy_component$8(a, d);
    }
  };
}
const func$1 = (c) => c;
class Loader extends SvelteComponent$a {
  constructor(a) {
    super(), init$a(this, a, null, create_fragment$9, safe_not_equal$a, {});
  }
}
const {
  HtmlTagHydration,
  SvelteComponent: SvelteComponent$9,
  append_hydration: append_hydration$6,
  attr: attr$7,
  check_outros: check_outros$6,
  children: children$7,
  claim_component: claim_component$7,
  claim_element: claim_element$6,
  claim_html_tag,
  claim_space: claim_space$6,
  claim_text: claim_text$6,
  create_component: create_component$7,
  destroy_component: destroy_component$7,
  destroy_each: destroy_each$2,
  detach: detach$9,
  element: element$6,
  ensure_array_like: ensure_array_like$2,
  group_outros: group_outros$6,
  init: init$9,
  insert_hydration: insert_hydration$9,
  listen: listen$4,
  mount_component: mount_component$7,
  safe_not_equal: safe_not_equal$9,
  set_data: set_data$6,
  set_style: set_style$2,
  space: space$6,
  text: text$6,
  toggle_class: toggle_class$4,
  transition_in: transition_in$8,
  transition_out: transition_out$8
} = window.__gradio__svelte__internal, {
  createEventDispatcher: createEventDispatcher$4
} = window.__gradio__svelte__internal;
function get_each_context$2(c, a, h) {
  const d = c.slice();
  return d[11] = a[h], d[13] = h, d;
}
function create_if_block_1$4(c) {
  let a, h;
  return a = new Loader({}), {
    c() {
      create_component$7(a.$$.fragment);
    },
    l(d) {
      claim_component$7(a.$$.fragment, d);
    },
    m(d, u) {
      mount_component$7(a, d, u), h = !0;
    },
    i(d) {
      h || (transition_in$8(a.$$.fragment, d), h = !0);
    },
    o(d) {
      transition_out$8(a.$$.fragment, d), h = !1;
    },
    d(d) {
      destroy_component$7(a, d);
    }
  };
}
function create_else_block$3(c) {
  let a = (
    /*i18n*/
    c[1]("file.uploading") + ""
  ), h;
  return {
    c() {
      h = text$6(a);
    },
    l(d) {
      h = claim_text$6(d, a);
    },
    m(d, u) {
      insert_hydration$9(d, h, u);
    },
    p(d, u) {
      u & /*i18n*/
      2 && a !== (a = /*i18n*/
      d[1]("file.uploading") + "") && set_data$6(h, a);
    },
    d(d) {
      d && detach$9(h);
    }
  };
}
function create_if_block$6(c) {
  let a, h, d = (
    /*file*/
    (c[11].size != null ? prettyBytes(
      /*file*/
      c[11].size
    ) : "(size unknown)") + ""
  ), u, _, g;
  return {
    c() {
      a = element$6("a"), h = new HtmlTagHydration(!1), u = text$6(" ⇣"), this.h();
    },
    l($) {
      a = claim_element$6($, "A", {
        href: !0,
        rel: !0,
        target: !0,
        download: !0
      });
      var b = children$7(a);
      h = claim_html_tag(b, !1), u = claim_text$6(b, " ⇣"), b.forEach(detach$9), this.h();
    },
    h() {
      h.a = u, attr$7(a, "href", _ = /*file*/
      c[11].url), attr$7(a, "rel", "noopener noreferrer"), attr$7(a, "target", "_blank"), attr$7(a, "download", g = window.__is_colab__ ? null : (
        /*file*/
        c[11].orig_name
      ));
    },
    m($, b) {
      insert_hydration$9($, a, b), h.m(d, a), append_hydration$6(a, u);
    },
    p($, b) {
      b & /*normalized_files*/
      64 && d !== (d = /*file*/
      ($[11].size != null ? prettyBytes(
        /*file*/
        $[11].size
      ) : "(size unknown)") + "") && h.p(d), b & /*normalized_files*/
      64 && _ !== (_ = /*file*/
      $[11].url) && attr$7(a, "href", _), b & /*normalized_files*/
      64 && g !== (g = window.__is_colab__ ? null : (
        /*file*/
        $[11].orig_name
      )) && attr$7(a, "download", g);
    },
    d($) {
      $ && detach$9(a);
    }
  };
}
function create_each_block$2(c) {
  let a, h, d, u, _, g, $, b, y, v, E, S, R;
  d = new FileView_1({
    props: {
      theme: (
        /*theme*/
        c[2]
      ),
      style: {
        maxHeight: 80
      },
      excludes: ["video"],
      link_disabled: !0,
      file: (
        /*file*/
        c[11]
      ),
      alt_text: (
        /*file*/
        c[11].alt_text || /*file*/
        c[11].orig_name
      )
    }
  });
  function x(j, B) {
    return (
      /*file*/
      j[11].url ? create_if_block$6 : create_else_block$3
    );
  }
  let H = x(c), T = H(c);
  function C() {
    return (
      /*click_handler*/
      c[9](
        /*i*/
        c[13]
      )
    );
  }
  y = new IconButton$1({
    props: {
      Icon: RemoveIcon,
      size: "small",
      disabled: (
        /*disabled*/
        c[4]
      )
    }
  }), y.$on("click", C);
  function O() {
    return (
      /*click_handler_1*/
      c[10](
        /*file*/
        c[11],
        /*i*/
        c[13]
      )
    );
  }
  return {
    c() {
      a = element$6("tr"), h = element$6("td"), create_component$7(d.$$.fragment), _ = space$6(), g = element$6("td"), T.c(), $ = space$6(), b = element$6("td"), create_component$7(y.$$.fragment), v = space$6(), this.h();
    },
    l(j) {
      a = claim_element$6(j, "TR", {
        class: !0
      });
      var B = children$7(a);
      h = claim_element$6(B, "TD", {
        class: !0,
        "aria-label": !0
      });
      var D = children$7(h);
      claim_component$7(d.$$.fragment, D), D.forEach(detach$9), _ = claim_space$6(B), g = claim_element$6(B, "TD", {
        class: !0
      });
      var M = children$7(g);
      T.l(M), M.forEach(detach$9), $ = claim_space$6(B), b = claim_element$6(B, "TD", {
        class: !0
      });
      var I = children$7(b);
      claim_component$7(y.$$.fragment, I), I.forEach(detach$9), v = claim_space$6(B), B.forEach(detach$9), this.h();
    },
    h() {
      attr$7(h, "class", "filename svelte-15456wk"), attr$7(h, "aria-label", u = /*file*/
      c[11].orig_name), attr$7(g, "class", "download svelte-15456wk"), attr$7(b, "class", "clear svelte-15456wk"), attr$7(a, "class", "file svelte-15456wk"), toggle_class$4(
        a,
        "selectable",
        /*selectable*/
        c[0]
      );
    },
    m(j, B) {
      insert_hydration$9(j, a, B), append_hydration$6(a, h), mount_component$7(d, h, null), append_hydration$6(a, _), append_hydration$6(a, g), T.m(g, null), append_hydration$6(a, $), append_hydration$6(a, b), mount_component$7(y, b, null), append_hydration$6(a, v), E = !0, S || (R = listen$4(a, "click", O), S = !0);
    },
    p(j, B) {
      c = j;
      const D = {};
      B & /*theme*/
      4 && (D.theme = /*theme*/
      c[2]), B & /*normalized_files*/
      64 && (D.file = /*file*/
      c[11]), B & /*normalized_files*/
      64 && (D.alt_text = /*file*/
      c[11].alt_text || /*file*/
      c[11].orig_name), d.$set(D), (!E || B & /*normalized_files*/
      64 && u !== (u = /*file*/
      c[11].orig_name)) && attr$7(h, "aria-label", u), H === (H = x(c)) && T ? T.p(c, B) : (T.d(1), T = H(c), T && (T.c(), T.m(g, null)));
      const M = {};
      B & /*disabled*/
      16 && (M.disabled = /*disabled*/
      c[4]), y.$set(M), (!E || B & /*selectable*/
      1) && toggle_class$4(
        a,
        "selectable",
        /*selectable*/
        c[0]
      );
    },
    i(j) {
      E || (transition_in$8(d.$$.fragment, j), transition_in$8(y.$$.fragment, j), E = !0);
    },
    o(j) {
      transition_out$8(d.$$.fragment, j), transition_out$8(y.$$.fragment, j), E = !1;
    },
    d(j) {
      j && detach$9(a), destroy_component$7(d), T.d(), destroy_component$7(y), S = !1, R();
    }
  };
}
function create_fragment$8(c) {
  let a, h, d, u, _, g = (
    /*loading*/
    c[3] && create_if_block_1$4()
  ), $ = ensure_array_like$2(
    /*normalized_files*/
    c[6]
  ), b = [];
  for (let v = 0; v < $.length; v += 1)
    b[v] = create_each_block$2(get_each_context$2(c, $, v));
  const y = (v) => transition_out$8(b[v], 1, 1, () => {
    b[v] = null;
  });
  return {
    c() {
      a = element$6("div"), g && g.c(), h = space$6(), d = element$6("table"), u = element$6("tbody");
      for (let v = 0; v < b.length; v += 1)
        b[v].c();
      this.h();
    },
    l(v) {
      a = claim_element$6(v, "DIV", {
        class: !0,
        style: !0
      });
      var E = children$7(a);
      g && g.l(E), h = claim_space$6(E), d = claim_element$6(E, "TABLE", {
        class: !0
      });
      var S = children$7(d);
      u = claim_element$6(S, "TBODY", {
        class: !0
      });
      var R = children$7(u);
      for (let x = 0; x < b.length; x += 1)
        b[x].l(R);
      R.forEach(detach$9), S.forEach(detach$9), E.forEach(detach$9), this.h();
    },
    h() {
      attr$7(u, "class", "svelte-15456wk"), attr$7(d, "class", "file-preview svelte-15456wk"), attr$7(a, "class", "file-preview-holder svelte-15456wk"), set_style$2(a, "max-height", typeof /*props*/
      c[5].height > "u" ? "auto" : (
        /*props*/
        c[5].height + "px"
      ));
    },
    m(v, E) {
      insert_hydration$9(v, a, E), g && g.m(a, null), append_hydration$6(a, h), append_hydration$6(a, d), append_hydration$6(d, u);
      for (let S = 0; S < b.length; S += 1)
        b[S] && b[S].m(u, null);
      _ = !0;
    },
    p(v, [E]) {
      if (/*loading*/
      v[3] ? g ? E & /*loading*/
      8 && transition_in$8(g, 1) : (g = create_if_block_1$4(), g.c(), transition_in$8(g, 1), g.m(a, h)) : g && (group_outros$6(), transition_out$8(g, 1, 1, () => {
        g = null;
      }), check_outros$6()), E & /*selectable, dispatch, normalized_files, disabled, window, i18n, theme*/
      215) {
        $ = ensure_array_like$2(
          /*normalized_files*/
          v[6]
        );
        let S;
        for (S = 0; S < $.length; S += 1) {
          const R = get_each_context$2(v, $, S);
          b[S] ? (b[S].p(R, E), transition_in$8(b[S], 1)) : (b[S] = create_each_block$2(R), b[S].c(), transition_in$8(b[S], 1), b[S].m(u, null));
        }
        for (group_outros$6(), S = $.length; S < b.length; S += 1)
          y(S);
        check_outros$6();
      }
      (!_ || E & /*props*/
      32) && set_style$2(a, "max-height", typeof /*props*/
      v[5].height > "u" ? "auto" : (
        /*props*/
        v[5].height + "px"
      ));
    },
    i(v) {
      if (!_) {
        transition_in$8(g);
        for (let E = 0; E < $.length; E += 1)
          transition_in$8(b[E]);
        _ = !0;
      }
    },
    o(v) {
      transition_out$8(g), b = b.filter(Boolean);
      for (let E = 0; E < b.length; E += 1)
        transition_out$8(b[E]);
      _ = !1;
    },
    d(v) {
      v && detach$9(a), g && g.d(), destroy_each$2(b, v);
    }
  };
}
function instance$7(c, a, h) {
  let d;
  const u = createEventDispatcher$4();
  let {
    value: _
  } = a, {
    selectable: g = !1
  } = a, {
    i18n: $
  } = a, {
    theme: b = "light"
  } = a, {
    loading: y = !1
  } = a, {
    disabled: v
  } = a, {
    props: E = {}
  } = a;
  const S = (x) => {
    u("delete", x);
  }, R = (x, H) => u("select", {
    value: x.orig_name,
    index: H
  });
  return c.$$set = (x) => {
    "value" in x && h(8, _ = x.value), "selectable" in x && h(0, g = x.selectable), "i18n" in x && h(1, $ = x.i18n), "theme" in x && h(2, b = x.theme), "loading" in x && h(3, y = x.loading), "disabled" in x && h(4, v = x.disabled), "props" in x && h(5, E = x.props);
  }, c.$$.update = () => {
    c.$$.dirty & /*value*/
    256 && h(6, d = (Array.isArray(_) ? _ : [_]).map((x) => x));
  }, [g, $, b, y, v, E, d, u, _, S, R];
}
class FilePreview extends SvelteComponent$9 {
  constructor(a) {
    super(), init$9(this, a, instance$7, create_fragment$8, safe_not_equal$9, {
      value: 8,
      selectable: 0,
      i18n: 1,
      theme: 2,
      loading: 3,
      disabled: 4,
      props: 5
    });
  }
}
const {
  SvelteComponent: SvelteComponent$8,
  action_destroyer: action_destroyer$1,
  append_hydration: append_hydration$5,
  attr: attr$6,
  binding_callbacks: binding_callbacks$4,
  check_outros: check_outros$5,
  children: children$6,
  claim_component: claim_component$6,
  claim_element: claim_element$5,
  claim_space: claim_space$5,
  create_component: create_component$6,
  destroy_component: destroy_component$6,
  detach: detach$8,
  element: element$5,
  empty: empty$3,
  group_outros: group_outros$5,
  init: init$8,
  insert_hydration: insert_hydration$8,
  is_function: is_function$1,
  listen: listen$3,
  mount_component: mount_component$6,
  noop: noop$2,
  run_all: run_all$2,
  safe_not_equal: safe_not_equal$8,
  set_input_value: set_input_value$1,
  space: space$5,
  toggle_class: toggle_class$3,
  transition_in: transition_in$7,
  transition_out: transition_out$7
} = window.__gradio__svelte__internal, {
  afterUpdate,
  beforeUpdate,
  createEventDispatcher: createEventDispatcher$3,
  tick: tick$1
} = window.__gradio__svelte__internal;
function create_if_block_4$2(c) {
  let a, h, d, u;
  const _ = [create_if_block_5$2, create_else_block_1$1], g = [];
  function $(b, y) {
    return (
      /*copied*/
      b[13] ? 0 : 1
    );
  }
  return a = $(c), h = g[a] = _[a](c), {
    c() {
      h.c(), d = empty$3();
    },
    l(b) {
      h.l(b), d = empty$3();
    },
    m(b, y) {
      g[a].m(b, y), insert_hydration$8(b, d, y), u = !0;
    },
    p(b, y) {
      let v = a;
      a = $(b), a === v ? g[a].p(b, y) : (group_outros$5(), transition_out$7(g[v], 1, 1, () => {
        g[v] = null;
      }), check_outros$5(), h = g[a], h ? h.p(b, y) : (h = g[a] = _[a](b), h.c()), transition_in$7(h, 1), h.m(d.parentNode, d));
    },
    i(b) {
      u || (transition_in$7(h), u = !0);
    },
    o(b) {
      transition_out$7(h), u = !1;
    },
    d(b) {
      b && detach$8(d), g[a].d(b);
    }
  };
}
function create_else_block_1$1(c) {
  let a, h, d, u, _;
  return h = new Copy({}), {
    c() {
      a = element$5("button"), create_component$6(h.$$.fragment), this.h();
    },
    l(g) {
      a = claim_element$5(g, "BUTTON", {
        "aria-label": !0,
        "aria-roledescription": !0,
        class: !0
      });
      var $ = children$6(a);
      claim_component$6(h.$$.fragment, $), $.forEach(detach$8), this.h();
    },
    h() {
      attr$6(a, "aria-label", "Copy"), attr$6(a, "aria-roledescription", "Copy text"), attr$6(a, "class", "svelte-18cupnf");
    },
    m(g, $) {
      insert_hydration$8(g, a, $), mount_component$6(h, a, null), d = !0, u || (_ = listen$3(
        a,
        "click",
        /*handle_copy*/
        c[14]
      ), u = !0);
    },
    p: noop$2,
    i(g) {
      d || (transition_in$7(h.$$.fragment, g), d = !0);
    },
    o(g) {
      transition_out$7(h.$$.fragment, g), d = !1;
    },
    d(g) {
      g && detach$8(a), destroy_component$6(h), u = !1, _();
    }
  };
}
function create_if_block_5$2(c) {
  let a, h, d;
  return h = new Check({}), {
    c() {
      a = element$5("button"), create_component$6(h.$$.fragment), this.h();
    },
    l(u) {
      a = claim_element$5(u, "BUTTON", {
        "aria-label": !0,
        "aria-roledescription": !0,
        class: !0
      });
      var _ = children$6(a);
      claim_component$6(h.$$.fragment, _), _.forEach(detach$8), this.h();
    },
    h() {
      attr$6(a, "aria-label", "Copied"), attr$6(a, "aria-roledescription", "Text copied"), attr$6(a, "class", "svelte-18cupnf");
    },
    m(u, _) {
      insert_hydration$8(u, a, _), mount_component$6(h, a, null), d = !0;
    },
    p: noop$2,
    i(u) {
      d || (transition_in$7(h.$$.fragment, u), d = !0);
    },
    o(u) {
      transition_out$7(h.$$.fragment, u), d = !1;
    },
    d(u) {
      u && detach$8(a), destroy_component$6(h);
    }
  };
}
function create_else_block$2(c) {
  let a, h, d, u, _, g;
  return {
    c() {
      a = element$5("textarea"), this.h();
    },
    l($) {
      a = claim_element$5($, "TEXTAREA", {
        class: !0,
        dir: !0,
        placeholder: !0,
        rows: !0,
        style: !0
      }), children$6(a).forEach(detach$8), this.h();
    },
    h() {
      attr$6(a, "class", "scroll-hide svelte-18cupnf"), attr$6(a, "dir", h = /*rtl*/
      c[9] ? "rtl" : "ltr"), attr$6(
        a,
        "placeholder",
        /*placeholder*/
        c[2]
      ), attr$6(
        a,
        "rows",
        /*lines*/
        c[1]
      ), a.disabled = /*disabled*/
      c[3], a.autofocus = /*autofocus*/
      c[10], attr$6(a, "style", d = /*text_align*/
      c[11] ? "text-align: " + /*text_align*/
      c[11] : "");
    },
    m($, b) {
      insert_hydration$8($, a, b), set_input_value$1(
        a,
        /*value*/
        c[0]
      ), c[30](a), /*autofocus*/
      c[10] && a.focus(), _ || (g = [action_destroyer$1(u = /*text_area_resize*/
      c[20].call(
        null,
        a,
        /*value*/
        c[0]
      )), listen$3(
        a,
        "input",
        /*textarea_input_handler*/
        c[29]
      ), listen$3(
        a,
        "keypress",
        /*handle_keypress*/
        c[18]
      ), listen$3(
        a,
        "blur",
        /*handle_blur*/
        c[17]
      ), listen$3(
        a,
        "select",
        /*handle_select*/
        c[15]
      ), listen$3(
        a,
        "focus",
        /*handle_focus*/
        c[16]
      ), listen$3(
        a,
        "scroll",
        /*handle_scroll*/
        c[19]
      )], _ = !0);
    },
    p($, b) {
      b[0] & /*rtl*/
      512 && h !== (h = /*rtl*/
      $[9] ? "rtl" : "ltr") && attr$6(a, "dir", h), b[0] & /*placeholder*/
      4 && attr$6(
        a,
        "placeholder",
        /*placeholder*/
        $[2]
      ), b[0] & /*lines*/
      2 && attr$6(
        a,
        "rows",
        /*lines*/
        $[1]
      ), b[0] & /*disabled*/
      8 && (a.disabled = /*disabled*/
      $[3]), b[0] & /*autofocus*/
      1024 && (a.autofocus = /*autofocus*/
      $[10]), b[0] & /*text_align*/
      2048 && d !== (d = /*text_align*/
      $[11] ? "text-align: " + /*text_align*/
      $[11] : "") && attr$6(a, "style", d), u && is_function$1(u.update) && b[0] & /*value*/
      1 && u.update.call(
        null,
        /*value*/
        $[0]
      ), b[0] & /*value*/
      1 && set_input_value$1(
        a,
        /*value*/
        $[0]
      );
    },
    d($) {
      $ && detach$8(a), c[30](null), _ = !1, run_all$2(g);
    }
  };
}
function create_if_block$5(c) {
  let a;
  function h(_, g) {
    if (
      /*type*/
      _[7] === "text"
    ) return create_if_block_1$3;
    if (
      /*type*/
      _[7] === "password"
    ) return create_if_block_2$3;
    if (
      /*type*/
      _[7] === "email"
    ) return create_if_block_3$2;
  }
  let d = h(c), u = d && d(c);
  return {
    c() {
      u && u.c(), a = empty$3();
    },
    l(_) {
      u && u.l(_), a = empty$3();
    },
    m(_, g) {
      u && u.m(_, g), insert_hydration$8(_, a, g);
    },
    p(_, g) {
      d === (d = h(_)) && u ? u.p(_, g) : (u && u.d(1), u = d && d(_), u && (u.c(), u.m(a.parentNode, a)));
    },
    d(_) {
      _ && detach$8(a), u && u.d(_);
    }
  };
}
function create_if_block_3$2(c) {
  let a, h, d;
  return {
    c() {
      a = element$5("input"), this.h();
    },
    l(u) {
      a = claim_element$5(u, "INPUT", {
        type: !0,
        class: !0,
        placeholder: !0,
        autocomplete: !0
      }), this.h();
    },
    h() {
      attr$6(a, "type", "email"), attr$6(a, "class", "scroll-hide svelte-18cupnf"), attr$6(
        a,
        "placeholder",
        /*placeholder*/
        c[2]
      ), a.disabled = /*disabled*/
      c[3], a.autofocus = /*autofocus*/
      c[10], attr$6(a, "autocomplete", "email");
    },
    m(u, _) {
      insert_hydration$8(u, a, _), set_input_value$1(
        a,
        /*value*/
        c[0]
      ), c[28](a), /*autofocus*/
      c[10] && a.focus(), h || (d = [listen$3(
        a,
        "input",
        /*input_input_handler_2*/
        c[27]
      ), listen$3(
        a,
        "keypress",
        /*handle_keypress*/
        c[18]
      ), listen$3(
        a,
        "blur",
        /*handle_blur*/
        c[17]
      ), listen$3(
        a,
        "select",
        /*handle_select*/
        c[15]
      ), listen$3(
        a,
        "focus",
        /*handle_focus*/
        c[16]
      )], h = !0);
    },
    p(u, _) {
      _[0] & /*placeholder*/
      4 && attr$6(
        a,
        "placeholder",
        /*placeholder*/
        u[2]
      ), _[0] & /*disabled*/
      8 && (a.disabled = /*disabled*/
      u[3]), _[0] & /*autofocus*/
      1024 && (a.autofocus = /*autofocus*/
      u[10]), _[0] & /*value*/
      1 && a.value !== /*value*/
      u[0] && set_input_value$1(
        a,
        /*value*/
        u[0]
      );
    },
    d(u) {
      u && detach$8(a), c[28](null), h = !1, run_all$2(d);
    }
  };
}
function create_if_block_2$3(c) {
  let a, h, d;
  return {
    c() {
      a = element$5("input"), this.h();
    },
    l(u) {
      a = claim_element$5(u, "INPUT", {
        type: !0,
        class: !0,
        placeholder: !0,
        autocomplete: !0
      }), this.h();
    },
    h() {
      attr$6(a, "type", "password"), attr$6(a, "class", "scroll-hide svelte-18cupnf"), attr$6(
        a,
        "placeholder",
        /*placeholder*/
        c[2]
      ), a.disabled = /*disabled*/
      c[3], a.autofocus = /*autofocus*/
      c[10], attr$6(a, "autocomplete", "");
    },
    m(u, _) {
      insert_hydration$8(u, a, _), set_input_value$1(
        a,
        /*value*/
        c[0]
      ), c[26](a), /*autofocus*/
      c[10] && a.focus(), h || (d = [listen$3(
        a,
        "input",
        /*input_input_handler_1*/
        c[25]
      ), listen$3(
        a,
        "keypress",
        /*handle_keypress*/
        c[18]
      ), listen$3(
        a,
        "blur",
        /*handle_blur*/
        c[17]
      ), listen$3(
        a,
        "select",
        /*handle_select*/
        c[15]
      ), listen$3(
        a,
        "focus",
        /*handle_focus*/
        c[16]
      )], h = !0);
    },
    p(u, _) {
      _[0] & /*placeholder*/
      4 && attr$6(
        a,
        "placeholder",
        /*placeholder*/
        u[2]
      ), _[0] & /*disabled*/
      8 && (a.disabled = /*disabled*/
      u[3]), _[0] & /*autofocus*/
      1024 && (a.autofocus = /*autofocus*/
      u[10]), _[0] & /*value*/
      1 && a.value !== /*value*/
      u[0] && set_input_value$1(
        a,
        /*value*/
        u[0]
      );
    },
    d(u) {
      u && detach$8(a), c[26](null), h = !1, run_all$2(d);
    }
  };
}
function create_if_block_1$3(c) {
  let a, h, d, u, _;
  return {
    c() {
      a = element$5("input"), this.h();
    },
    l(g) {
      a = claim_element$5(g, "INPUT", {
        type: !0,
        class: !0,
        dir: !0,
        placeholder: !0,
        style: !0
      }), this.h();
    },
    h() {
      attr$6(a, "type", "text"), attr$6(a, "class", "scroll-hide svelte-18cupnf"), attr$6(a, "dir", h = /*rtl*/
      c[9] ? "rtl" : "ltr"), attr$6(
        a,
        "placeholder",
        /*placeholder*/
        c[2]
      ), a.disabled = /*disabled*/
      c[3], a.autofocus = /*autofocus*/
      c[10], attr$6(a, "style", d = /*text_align*/
      c[11] ? "text-align: " + /*text_align*/
      c[11] : "");
    },
    m(g, $) {
      insert_hydration$8(g, a, $), set_input_value$1(
        a,
        /*value*/
        c[0]
      ), c[24](a), /*autofocus*/
      c[10] && a.focus(), u || (_ = [listen$3(
        a,
        "input",
        /*input_input_handler*/
        c[23]
      ), listen$3(
        a,
        "keypress",
        /*handle_keypress*/
        c[18]
      ), listen$3(
        a,
        "blur",
        /*handle_blur*/
        c[17]
      ), listen$3(
        a,
        "select",
        /*handle_select*/
        c[15]
      ), listen$3(
        a,
        "focus",
        /*handle_focus*/
        c[16]
      )], u = !0);
    },
    p(g, $) {
      $[0] & /*rtl*/
      512 && h !== (h = /*rtl*/
      g[9] ? "rtl" : "ltr") && attr$6(a, "dir", h), $[0] & /*placeholder*/
      4 && attr$6(
        a,
        "placeholder",
        /*placeholder*/
        g[2]
      ), $[0] & /*disabled*/
      8 && (a.disabled = /*disabled*/
      g[3]), $[0] & /*autofocus*/
      1024 && (a.autofocus = /*autofocus*/
      g[10]), $[0] & /*text_align*/
      2048 && d !== (d = /*text_align*/
      g[11] ? "text-align: " + /*text_align*/
      g[11] : "") && attr$6(a, "style", d), $[0] & /*value*/
      1 && a.value !== /*value*/
      g[0] && set_input_value$1(
        a,
        /*value*/
        g[0]
      );
    },
    d(g) {
      g && detach$8(a), c[24](null), u = !1, run_all$2(_);
    }
  };
}
function create_fragment$7(c) {
  let a, h, d, u = (
    /*show_label*/
    c[4] && /*show_copy_button*/
    c[8] && create_if_block_4$2(c)
  );
  function _(b, y) {
    return (
      /*lines*/
      b[1] === 1 && /*max_lines*/
      b[6] === 1 ? create_if_block$5 : create_else_block$2
    );
  }
  let g = _(c), $ = g(c);
  return {
    c() {
      a = element$5("label"), u && u.c(), h = space$5(), $.c(), this.h();
    },
    l(b) {
      a = claim_element$5(b, "LABEL", {
        class: !0
      });
      var y = children$6(a);
      u && u.l(y), h = claim_space$5(y), $.l(y), y.forEach(detach$8), this.h();
    },
    h() {
      attr$6(a, "class", "svelte-18cupnf"), toggle_class$3(
        a,
        "container",
        /*container*/
        c[5]
      );
    },
    m(b, y) {
      insert_hydration$8(b, a, y), u && u.m(a, null), append_hydration$5(a, h), $.m(a, null), d = !0;
    },
    p(b, y) {
      /*show_label*/
      b[4] && /*show_copy_button*/
      b[8] ? u ? (u.p(b, y), y[0] & /*show_label, show_copy_button*/
      272 && transition_in$7(u, 1)) : (u = create_if_block_4$2(b), u.c(), transition_in$7(u, 1), u.m(a, h)) : u && (group_outros$5(), transition_out$7(u, 1, 1, () => {
        u = null;
      }), check_outros$5()), g === (g = _(b)) && $ ? $.p(b, y) : ($.d(1), $ = g(b), $ && ($.c(), $.m(a, null))), (!d || y[0] & /*container*/
      32) && toggle_class$3(
        a,
        "container",
        /*container*/
        b[5]
      );
    },
    i(b) {
      d || (transition_in$7(u), d = !0);
    },
    o(b) {
      transition_out$7(u), d = !1;
    },
    d(b) {
      b && detach$8(a), u && u.d(), $.d();
    }
  };
}
function instance$6(c, a, h) {
  let {
    value: d = ""
  } = a, {
    value_is_output: u = !1
  } = a, {
    lines: _ = 1
  } = a, {
    placeholder: g = ""
  } = a, {
    disabled: $ = !1
  } = a, {
    show_label: b = !0
  } = a, {
    container: y = !0
  } = a, {
    max_lines: v
  } = a, {
    type: E = "text"
  } = a, {
    show_copy_button: S = !1
  } = a, {
    rtl: R = !1
  } = a, {
    autofocus: x = !1
  } = a, {
    text_align: H = void 0
  } = a, {
    autoscroll: T = !0
  } = a, C, O = !1, j, B, D = 0, M = !1;
  const I = createEventDispatcher$3();
  beforeUpdate(() => {
    B = C && C.offsetHeight + C.scrollTop > C.scrollHeight - 100;
  });
  const P = () => {
    B && T && !M && C.scrollTo(0, C.scrollHeight);
  };
  function L() {
    I("change", d), u || I("input");
  }
  afterUpdate(() => {
    x && C.focus(), B && T && P(), h(21, u = !1);
  });
  async function Y() {
    "clipboard" in navigator && (await navigator.clipboard.writeText(d), N());
  }
  function N() {
    h(13, O = !0), j && clearTimeout(j), j = setTimeout(() => {
      h(13, O = !1);
    }, 1e3);
  }
  function W(G) {
    const Q = G.target, he = Q.value, me = [Q.selectionStart, Q.selectionEnd];
    I("select", {
      value: he.substring(...me),
      index: me
    });
  }
  function V() {
    I("focus");
  }
  function ue() {
    I("blur");
  }
  async function se(G) {
    await tick$1(), (G.key === "Enter" && G.shiftKey && _ > 1 || G.key === "Enter" && !G.shiftKey && _ === 1 && v >= 1) && (G.preventDefault(), I("submit"));
  }
  function ce(G) {
    const Q = G.target, he = Q.scrollTop;
    he < D && (M = !0), D = he;
    const me = Q.scrollHeight - Q.clientHeight;
    he >= me && (M = !1);
  }
  async function oe(G) {
    if (await tick$1(), _ === v) return;
    const Q = v === void 0 ? !1 : v === void 0 ? 21 * 11 : 21 * (v + 1), he = 21 * (_ + 1), me = G.target;
    me.style.height = "1px";
    let Te;
    Q && me.scrollHeight > Q ? Te = Q : me.scrollHeight < he ? Te = he : Te = me.scrollHeight, me.style.height = `${Te}px`;
  }
  function ge(G, Q) {
    if (_ !== v && (G.style.overflowY = "scroll", G.addEventListener("input", oe), !!Q.trim()))
      return oe({
        target: G
      }), {
        destroy: () => G.removeEventListener("input", oe)
      };
  }
  function J() {
    d = this.value, h(0, d);
  }
  function ae(G) {
    binding_callbacks$4[G ? "unshift" : "push"](() => {
      C = G, h(12, C);
    });
  }
  function le() {
    d = this.value, h(0, d);
  }
  function z(G) {
    binding_callbacks$4[G ? "unshift" : "push"](() => {
      C = G, h(12, C);
    });
  }
  function A() {
    d = this.value, h(0, d);
  }
  function F(G) {
    binding_callbacks$4[G ? "unshift" : "push"](() => {
      C = G, h(12, C);
    });
  }
  function U() {
    d = this.value, h(0, d);
  }
  function Z(G) {
    binding_callbacks$4[G ? "unshift" : "push"](() => {
      C = G, h(12, C);
    });
  }
  return c.$$set = (G) => {
    "value" in G && h(0, d = G.value), "value_is_output" in G && h(21, u = G.value_is_output), "lines" in G && h(1, _ = G.lines), "placeholder" in G && h(2, g = G.placeholder), "disabled" in G && h(3, $ = G.disabled), "show_label" in G && h(4, b = G.show_label), "container" in G && h(5, y = G.container), "max_lines" in G && h(6, v = G.max_lines), "type" in G && h(7, E = G.type), "show_copy_button" in G && h(8, S = G.show_copy_button), "rtl" in G && h(9, R = G.rtl), "autofocus" in G && h(10, x = G.autofocus), "text_align" in G && h(11, H = G.text_align), "autoscroll" in G && h(22, T = G.autoscroll);
  }, c.$$.update = () => {
    c.$$.dirty[0] & /*value*/
    1 && d === null && h(0, d = ""), c.$$.dirty[0] & /*value, el, lines, max_lines*/
    4163 && C && _ !== v && oe({
      target: C
    }), c.$$.dirty[0] & /*value*/
    1 && L();
  }, [d, _, g, $, b, y, v, E, S, R, x, H, C, O, Y, W, V, ue, se, ce, ge, u, T, J, ae, le, z, A, F, U, Z];
}
class Input extends SvelteComponent$8 {
  constructor(a) {
    super(), init$8(this, a, instance$6, create_fragment$7, safe_not_equal$8, {
      value: 0,
      value_is_output: 21,
      lines: 1,
      placeholder: 2,
      disabled: 3,
      show_label: 4,
      container: 5,
      max_lines: 6,
      type: 7,
      show_copy_button: 8,
      rtl: 9,
      autofocus: 10,
      text_align: 11,
      autoscroll: 22
    }, null, [-1, -1]);
  }
}
const {
  SvelteComponent: SvelteComponent$7,
  append_hydration: append_hydration$4,
  attr: attr$5,
  bubble: bubble$1,
  check_outros: check_outros$4,
  children: children$5,
  claim_element: claim_element$4,
  claim_space: claim_space$4,
  create_slot,
  detach: detach$7,
  element: element$4,
  empty: empty$2,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros: group_outros$4,
  init: init$7,
  insert_hydration: insert_hydration$7,
  listen: listen$2,
  safe_not_equal: safe_not_equal$7,
  set_style: set_style$1,
  space: space$4,
  src_url_equal,
  toggle_class: toggle_class$2,
  transition_in: transition_in$6,
  transition_out: transition_out$6,
  update_slot_base
} = window.__gradio__svelte__internal;
function create_else_block$1(c) {
  let a, h, d, u, _, g, $ = (
    /*icon*/
    c[7] && create_if_block_2$2(c)
  );
  const b = (
    /*#slots*/
    c[12].default
  ), y = create_slot(
    b,
    c,
    /*$$scope*/
    c[11],
    null
  );
  return {
    c() {
      a = element$4("button"), $ && $.c(), h = space$4(), y && y.c(), this.h();
    },
    l(v) {
      a = claim_element$4(v, "BUTTON", {
        class: !0,
        id: !0
      });
      var E = children$5(a);
      $ && $.l(E), h = claim_space$4(E), y && y.l(E), E.forEach(detach$7), this.h();
    },
    h() {
      attr$5(a, "class", d = /*size*/
      c[4] + " " + /*variant*/
      c[3] + " " + /*elem_classes*/
      c[1].join(" ") + " svelte-8huxfn"), attr$5(
        a,
        "id",
        /*elem_id*/
        c[0]
      ), a.disabled = /*disabled*/
      c[8], toggle_class$2(a, "hidden", !/*visible*/
      c[2]), set_style$1(
        a,
        "flex-grow",
        /*scale*/
        c[9]
      ), set_style$1(
        a,
        "width",
        /*scale*/
        c[9] === 0 ? "fit-content" : null
      ), set_style$1(a, "min-width", typeof /*min_width*/
      c[10] == "number" ? `calc(min(${/*min_width*/
      c[10]}px, 100%))` : null);
    },
    m(v, E) {
      insert_hydration$7(v, a, E), $ && $.m(a, null), append_hydration$4(a, h), y && y.m(a, null), u = !0, _ || (g = listen$2(
        a,
        "click",
        /*click_handler*/
        c[13]
      ), _ = !0);
    },
    p(v, E) {
      /*icon*/
      v[7] ? $ ? $.p(v, E) : ($ = create_if_block_2$2(v), $.c(), $.m(a, h)) : $ && ($.d(1), $ = null), y && y.p && (!u || E & /*$$scope*/
      2048) && update_slot_base(
        y,
        b,
        v,
        /*$$scope*/
        v[11],
        u ? get_slot_changes(
          b,
          /*$$scope*/
          v[11],
          E,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          v[11]
        ),
        null
      ), (!u || E & /*size, variant, elem_classes*/
      26 && d !== (d = /*size*/
      v[4] + " " + /*variant*/
      v[3] + " " + /*elem_classes*/
      v[1].join(" ") + " svelte-8huxfn")) && attr$5(a, "class", d), (!u || E & /*elem_id*/
      1) && attr$5(
        a,
        "id",
        /*elem_id*/
        v[0]
      ), (!u || E & /*disabled*/
      256) && (a.disabled = /*disabled*/
      v[8]), (!u || E & /*size, variant, elem_classes, visible*/
      30) && toggle_class$2(a, "hidden", !/*visible*/
      v[2]), E & /*scale*/
      512 && set_style$1(
        a,
        "flex-grow",
        /*scale*/
        v[9]
      ), E & /*scale*/
      512 && set_style$1(
        a,
        "width",
        /*scale*/
        v[9] === 0 ? "fit-content" : null
      ), E & /*min_width*/
      1024 && set_style$1(a, "min-width", typeof /*min_width*/
      v[10] == "number" ? `calc(min(${/*min_width*/
      v[10]}px, 100%))` : null);
    },
    i(v) {
      u || (transition_in$6(y, v), u = !0);
    },
    o(v) {
      transition_out$6(y, v), u = !1;
    },
    d(v) {
      v && detach$7(a), $ && $.d(), y && y.d(v), _ = !1, g();
    }
  };
}
function create_if_block$4(c) {
  let a, h, d, u, _ = (
    /*icon*/
    c[7] && create_if_block_1$2(c)
  );
  const g = (
    /*#slots*/
    c[12].default
  ), $ = create_slot(
    g,
    c,
    /*$$scope*/
    c[11],
    null
  );
  return {
    c() {
      a = element$4("a"), _ && _.c(), h = space$4(), $ && $.c(), this.h();
    },
    l(b) {
      a = claim_element$4(b, "A", {
        href: !0,
        rel: !0,
        "aria-disabled": !0,
        class: !0,
        id: !0
      });
      var y = children$5(a);
      _ && _.l(y), h = claim_space$4(y), $ && $.l(y), y.forEach(detach$7), this.h();
    },
    h() {
      attr$5(
        a,
        "href",
        /*link*/
        c[6]
      ), attr$5(a, "rel", "noopener noreferrer"), attr$5(
        a,
        "aria-disabled",
        /*disabled*/
        c[8]
      ), attr$5(a, "class", d = /*size*/
      c[4] + " " + /*variant*/
      c[3] + " " + /*elem_classes*/
      c[1].join(" ") + " svelte-8huxfn"), attr$5(
        a,
        "id",
        /*elem_id*/
        c[0]
      ), toggle_class$2(a, "hidden", !/*visible*/
      c[2]), toggle_class$2(
        a,
        "disabled",
        /*disabled*/
        c[8]
      ), set_style$1(
        a,
        "flex-grow",
        /*scale*/
        c[9]
      ), set_style$1(
        a,
        "pointer-events",
        /*disabled*/
        c[8] ? "none" : null
      ), set_style$1(
        a,
        "width",
        /*scale*/
        c[9] === 0 ? "fit-content" : null
      ), set_style$1(a, "min-width", typeof /*min_width*/
      c[10] == "number" ? `calc(min(${/*min_width*/
      c[10]}px, 100%))` : null);
    },
    m(b, y) {
      insert_hydration$7(b, a, y), _ && _.m(a, null), append_hydration$4(a, h), $ && $.m(a, null), u = !0;
    },
    p(b, y) {
      /*icon*/
      b[7] ? _ ? _.p(b, y) : (_ = create_if_block_1$2(b), _.c(), _.m(a, h)) : _ && (_.d(1), _ = null), $ && $.p && (!u || y & /*$$scope*/
      2048) && update_slot_base(
        $,
        g,
        b,
        /*$$scope*/
        b[11],
        u ? get_slot_changes(
          g,
          /*$$scope*/
          b[11],
          y,
          null
        ) : get_all_dirty_from_scope(
          /*$$scope*/
          b[11]
        ),
        null
      ), (!u || y & /*link*/
      64) && attr$5(
        a,
        "href",
        /*link*/
        b[6]
      ), (!u || y & /*disabled*/
      256) && attr$5(
        a,
        "aria-disabled",
        /*disabled*/
        b[8]
      ), (!u || y & /*size, variant, elem_classes*/
      26 && d !== (d = /*size*/
      b[4] + " " + /*variant*/
      b[3] + " " + /*elem_classes*/
      b[1].join(" ") + " svelte-8huxfn")) && attr$5(a, "class", d), (!u || y & /*elem_id*/
      1) && attr$5(
        a,
        "id",
        /*elem_id*/
        b[0]
      ), (!u || y & /*size, variant, elem_classes, visible*/
      30) && toggle_class$2(a, "hidden", !/*visible*/
      b[2]), (!u || y & /*size, variant, elem_classes, disabled*/
      282) && toggle_class$2(
        a,
        "disabled",
        /*disabled*/
        b[8]
      ), y & /*scale*/
      512 && set_style$1(
        a,
        "flex-grow",
        /*scale*/
        b[9]
      ), y & /*disabled*/
      256 && set_style$1(
        a,
        "pointer-events",
        /*disabled*/
        b[8] ? "none" : null
      ), y & /*scale*/
      512 && set_style$1(
        a,
        "width",
        /*scale*/
        b[9] === 0 ? "fit-content" : null
      ), y & /*min_width*/
      1024 && set_style$1(a, "min-width", typeof /*min_width*/
      b[10] == "number" ? `calc(min(${/*min_width*/
      b[10]}px, 100%))` : null);
    },
    i(b) {
      u || (transition_in$6($, b), u = !0);
    },
    o(b) {
      transition_out$6($, b), u = !1;
    },
    d(b) {
      b && detach$7(a), _ && _.d(), $ && $.d(b);
    }
  };
}
function create_if_block_2$2(c) {
  let a, h, d;
  return {
    c() {
      a = element$4("img"), this.h();
    },
    l(u) {
      a = claim_element$4(u, "IMG", {
        class: !0,
        src: !0,
        alt: !0
      }), this.h();
    },
    h() {
      attr$5(a, "class", "button-icon svelte-8huxfn"), src_url_equal(a.src, h = /*icon*/
      c[7].url) || attr$5(a, "src", h), attr$5(a, "alt", d = `${/*value*/
      c[5]} icon`);
    },
    m(u, _) {
      insert_hydration$7(u, a, _);
    },
    p(u, _) {
      _ & /*icon*/
      128 && !src_url_equal(a.src, h = /*icon*/
      u[7].url) && attr$5(a, "src", h), _ & /*value*/
      32 && d !== (d = `${/*value*/
      u[5]} icon`) && attr$5(a, "alt", d);
    },
    d(u) {
      u && detach$7(a);
    }
  };
}
function create_if_block_1$2(c) {
  let a, h, d;
  return {
    c() {
      a = element$4("img"), this.h();
    },
    l(u) {
      a = claim_element$4(u, "IMG", {
        class: !0,
        src: !0,
        alt: !0
      }), this.h();
    },
    h() {
      attr$5(a, "class", "button-icon svelte-8huxfn"), src_url_equal(a.src, h = /*icon*/
      c[7].url) || attr$5(a, "src", h), attr$5(a, "alt", d = `${/*value*/
      c[5]} icon`);
    },
    m(u, _) {
      insert_hydration$7(u, a, _);
    },
    p(u, _) {
      _ & /*icon*/
      128 && !src_url_equal(a.src, h = /*icon*/
      u[7].url) && attr$5(a, "src", h), _ & /*value*/
      32 && d !== (d = `${/*value*/
      u[5]} icon`) && attr$5(a, "alt", d);
    },
    d(u) {
      u && detach$7(a);
    }
  };
}
function create_fragment$6(c) {
  let a, h, d, u;
  const _ = [create_if_block$4, create_else_block$1], g = [];
  function $(b, y) {
    return (
      /*link*/
      b[6] && /*link*/
      b[6].length > 0 ? 0 : 1
    );
  }
  return a = $(c), h = g[a] = _[a](c), {
    c() {
      h.c(), d = empty$2();
    },
    l(b) {
      h.l(b), d = empty$2();
    },
    m(b, y) {
      g[a].m(b, y), insert_hydration$7(b, d, y), u = !0;
    },
    p(b, [y]) {
      let v = a;
      a = $(b), a === v ? g[a].p(b, y) : (group_outros$4(), transition_out$6(g[v], 1, 1, () => {
        g[v] = null;
      }), check_outros$4(), h = g[a], h ? h.p(b, y) : (h = g[a] = _[a](b), h.c()), transition_in$6(h, 1), h.m(d.parentNode, d));
    },
    i(b) {
      u || (transition_in$6(h), u = !0);
    },
    o(b) {
      transition_out$6(h), u = !1;
    },
    d(b) {
      b && detach$7(d), g[a].d(b);
    }
  };
}
function instance$5(c, a, h) {
  let {
    $$slots: d = {},
    $$scope: u
  } = a, {
    elem_id: _ = ""
  } = a, {
    elem_classes: g = []
  } = a, {
    visible: $ = !0
  } = a, {
    variant: b = "secondary"
  } = a, {
    size: y = "lg"
  } = a, {
    value: v = null
  } = a, {
    link: E = null
  } = a, {
    icon: S = null
  } = a, {
    disabled: R = !1
  } = a, {
    scale: x = null
  } = a, {
    min_width: H = void 0
  } = a;
  function T(C) {
    bubble$1.call(this, c, C);
  }
  return c.$$set = (C) => {
    "elem_id" in C && h(0, _ = C.elem_id), "elem_classes" in C && h(1, g = C.elem_classes), "visible" in C && h(2, $ = C.visible), "variant" in C && h(3, b = C.variant), "size" in C && h(4, y = C.size), "value" in C && h(5, v = C.value), "link" in C && h(6, E = C.link), "icon" in C && h(7, S = C.icon), "disabled" in C && h(8, R = C.disabled), "scale" in C && h(9, x = C.scale), "min_width" in C && h(10, H = C.min_width), "$$scope" in C && h(11, u = C.$$scope);
  }, [_, g, $, b, y, v, E, S, R, x, H, u, d, T];
}
class Button extends SvelteComponent$7 {
  constructor(a) {
    super(), init$7(this, a, instance$5, create_fragment$6, safe_not_equal$7, {
      elem_id: 0,
      elem_classes: 1,
      visible: 2,
      variant: 3,
      size: 4,
      value: 5,
      link: 6,
      icon: 7,
      disabled: 8,
      scale: 9,
      min_width: 10
    });
  }
}
const {
  SvelteComponent: SvelteComponent$6,
  claim_component: claim_component$5,
  claim_text: claim_text$5,
  create_component: create_component$5,
  destroy_component: destroy_component$5,
  detach: detach$6,
  init: init$6,
  insert_hydration: insert_hydration$6,
  mount_component: mount_component$5,
  safe_not_equal: safe_not_equal$6,
  set_data: set_data$5,
  text: text$5,
  transition_in: transition_in$5,
  transition_out: transition_out$5
} = window.__gradio__svelte__internal, {
  SvelteComponent: SvelteComponent$5,
  assign: assign$2,
  claim_component: claim_component$4,
  claim_text: claim_text$4,
  create_component: create_component$4,
  destroy_component: destroy_component$4,
  detach: detach$5,
  get_spread_object: get_spread_object$2,
  get_spread_update: get_spread_update$2,
  init: init$5,
  insert_hydration: insert_hydration$5,
  mount_component: mount_component$4,
  safe_not_equal: safe_not_equal$5,
  set_data: set_data$4,
  text: text$4,
  transition_in: transition_in$4,
  transition_out: transition_out$4
} = window.__gradio__svelte__internal, {
  createEventDispatcher: createEventDispatcher$2
} = window.__gradio__svelte__internal;
function create_default_slot$2(c) {
  let a = (
    /*i18n*/
    c[0](
      /*props*/
      c[2].value || /*props*/
      c[2].label || "common.submit"
    ) + ""
  ), h;
  return {
    c() {
      h = text$4(a);
    },
    l(d) {
      h = claim_text$4(d, a);
    },
    m(d, u) {
      insert_hydration$5(d, h, u);
    },
    p(d, u) {
      u & /*i18n, props*/
      5 && a !== (a = /*i18n*/
      d[0](
        /*props*/
        d[2].value || /*props*/
        d[2].label || "common.submit"
      ) + "") && set_data$4(h, a);
    },
    d(d) {
      d && detach$5(h);
    }
  };
}
function create_fragment$5(c) {
  let a, h;
  const d = [
    {
      variant: "primary"
    },
    /*props*/
    c[2],
    {
      elem_classes: (
        /*props*/
        c[2].elem_classes || []
      )
    },
    {
      disabled: (
        /*disabled*/
        c[1] || /*props*/
        c[2].disabled
      )
    }
  ];
  let u = {
    $$slots: {
      default: [create_default_slot$2]
    },
    $$scope: {
      ctx: c
    }
  };
  for (let _ = 0; _ < d.length; _ += 1)
    u = assign$2(u, d[_]);
  return a = new Button({
    props: u
  }), a.$on(
    "click",
    /*click_handler*/
    c[4]
  ), {
    c() {
      create_component$4(a.$$.fragment);
    },
    l(_) {
      claim_component$4(a.$$.fragment, _);
    },
    m(_, g) {
      mount_component$4(a, _, g), h = !0;
    },
    p(_, [g]) {
      const $ = g & /*props, disabled*/
      6 ? get_spread_update$2(d, [d[0], g & /*props*/
      4 && get_spread_object$2(
        /*props*/
        _[2]
      ), g & /*props*/
      4 && {
        elem_classes: (
          /*props*/
          _[2].elem_classes || []
        )
      }, {
        disabled: (
          /*disabled*/
          _[1] || /*props*/
          _[2].disabled
        )
      }]) : {};
      g & /*$$scope, i18n, props*/
      37 && ($.$$scope = {
        dirty: g,
        ctx: _
      }), a.$set($);
    },
    i(_) {
      h || (transition_in$4(a.$$.fragment, _), h = !0);
    },
    o(_) {
      transition_out$4(a.$$.fragment, _), h = !1;
    },
    d(_) {
      destroy_component$4(a, _);
    }
  };
}
function instance$4(c, a, h) {
  let {
    i18n: d
  } = a, {
    disabled: u
  } = a, {
    props: _ = {}
  } = a;
  const g = createEventDispatcher$2(), $ = () => g("click");
  return c.$$set = (b) => {
    "i18n" in b && h(0, d = b.i18n), "disabled" in b && h(1, u = b.disabled), "props" in b && h(2, _ = b.props);
  }, [d, u, _, g, $];
}
class SubmitButton extends SvelteComponent$5 {
  constructor(a) {
    super(), init$5(this, a, instance$4, create_fragment$5, safe_not_equal$5, {
      i18n: 0,
      disabled: 1,
      props: 2
    });
  }
}
const {
  SvelteComponent: SvelteComponent$4,
  append_hydration: append_hydration$3,
  attr: attr$4,
  children: children$4,
  claim_svg_element,
  detach: detach$4,
  init: init$4,
  insert_hydration: insert_hydration$4,
  noop: noop$1,
  safe_not_equal: safe_not_equal$4,
  svg_element
} = window.__gradio__svelte__internal;
function create_fragment$4(c) {
  let a, h, d, u;
  return {
    c() {
      a = svg_element("svg"), h = svg_element("path"), d = svg_element("polyline"), u = svg_element("line"), this.h();
    },
    l(_) {
      a = claim_svg_element(_, "svg", {
        xmlns: !0,
        width: !0,
        height: !0,
        viewBox: !0,
        fill: !0,
        stroke: !0,
        "stroke-width": !0,
        "stroke-linecap": !0,
        "stroke-linejoin": !0,
        class: !0
      });
      var g = children$4(a);
      h = claim_svg_element(g, "path", {
        d: !0
      }), children$4(h).forEach(detach$4), d = claim_svg_element(g, "polyline", {
        points: !0
      }), children$4(d).forEach(detach$4), u = claim_svg_element(g, "line", {
        x1: !0,
        y1: !0,
        x2: !0,
        y2: !0
      }), children$4(u).forEach(detach$4), g.forEach(detach$4), this.h();
    },
    h() {
      attr$4(h, "d", "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"), attr$4(d, "points", "17 8 12 3 7 8"), attr$4(u, "x1", "12"), attr$4(u, "y1", "3"), attr$4(u, "x2", "12"), attr$4(u, "y2", "15"), attr$4(a, "xmlns", "http://www.w3.org/2000/svg"), attr$4(a, "width", "1em"), attr$4(a, "height", "1em"), attr$4(a, "viewBox", "0 0 24 24"), attr$4(a, "fill", "none"), attr$4(a, "stroke", "currentColor"), attr$4(a, "stroke-width", "2"), attr$4(a, "stroke-linecap", "round"), attr$4(a, "stroke-linejoin", "round"), attr$4(a, "class", "feather feather-upload");
    },
    m(_, g) {
      insert_hydration$4(_, a, g), append_hydration$3(a, h), append_hydration$3(a, d), append_hydration$3(a, u);
    },
    p: noop$1,
    i: noop$1,
    o: noop$1,
    d(_) {
      _ && detach$4(a);
    }
  };
}
class UploadIcon extends SvelteComponent$4 {
  constructor(a) {
    super(), init$4(this, a, null, create_fragment$4, safe_not_equal$4, {});
  }
}
const {
  SvelteComponent: SvelteComponent$3,
  assign: assign$1,
  attr: attr$3,
  binding_callbacks: binding_callbacks$3,
  check_outros: check_outros$3,
  children: children$3,
  claim_component: claim_component$3,
  claim_element: claim_element$3,
  claim_space: claim_space$3,
  claim_text: claim_text$3,
  create_component: create_component$3,
  destroy_component: destroy_component$3,
  detach: detach$3,
  element: element$3,
  get_spread_object: get_spread_object$1,
  get_spread_update: get_spread_update$1,
  group_outros: group_outros$3,
  init: init$3,
  insert_hydration: insert_hydration$3,
  listen: listen$1,
  mount_component: mount_component$3,
  run_all: run_all$1,
  safe_not_equal: safe_not_equal$3,
  set_data: set_data$3,
  set_style,
  space: space$3,
  text: text$3,
  transition_in: transition_in$3,
  transition_out: transition_out$3
} = window.__gradio__svelte__internal, {
  createEventDispatcher: createEventDispatcher$1,
  tick
} = window.__gradio__svelte__internal;
function create_if_block$3(c) {
  let a, h, d;
  return h = new UploadIcon({}), {
    c() {
      a = element$3("span"), create_component$3(h.$$.fragment), this.h();
    },
    l(u) {
      a = claim_element$3(u, "SPAN", {
        style: !0
      });
      var _ = children$3(a);
      claim_component$3(h.$$.fragment, _), _.forEach(detach$3), this.h();
    },
    h() {
      set_style(a, "margin-right", "4px");
    },
    m(u, _) {
      insert_hydration$3(u, a, _), mount_component$3(h, a, null), d = !0;
    },
    i(u) {
      d || (transition_in$3(h.$$.fragment, u), d = !0);
    },
    o(u) {
      transition_out$3(h.$$.fragment, u), d = !1;
    },
    d(u) {
      u && detach$3(a), destroy_component$3(h);
    }
  };
}
function create_default_slot$1(c) {
  let a, h = (
    /*i18n*/
    c[0](
      /*props*/
      c[2].label || "upload_text.click_to_upload"
    ) + ""
  ), d, u, _ = !/*props*/
  c[2].icon && create_if_block$3();
  return {
    c() {
      _ && _.c(), a = space$3(), d = text$3(h);
    },
    l(g) {
      _ && _.l(g), a = claim_space$3(g), d = claim_text$3(g, h);
    },
    m(g, $) {
      _ && _.m(g, $), insert_hydration$3(g, a, $), insert_hydration$3(g, d, $), u = !0;
    },
    p(g, $) {
      /*props*/
      g[2].icon ? _ && (group_outros$3(), transition_out$3(_, 1, 1, () => {
        _ = null;
      }), check_outros$3()) : _ ? $ & /*props*/
      4 && transition_in$3(_, 1) : (_ = create_if_block$3(), _.c(), transition_in$3(_, 1), _.m(a.parentNode, a)), (!u || $ & /*i18n, props*/
      5) && h !== (h = /*i18n*/
      g[0](
        /*props*/
        g[2].label || "upload_text.click_to_upload"
      ) + "") && set_data$3(d, h);
    },
    i(g) {
      u || (transition_in$3(_), u = !0);
    },
    o(g) {
      transition_out$3(_), u = !1;
    },
    d(g) {
      g && (detach$3(a), detach$3(d)), _ && _.d(g);
    }
  };
}
function create_fragment$3(c) {
  let a, h, d, u, _, g, $, b, y;
  const v = [
    {
      variant: "secondary"
    },
    /*props*/
    c[2],
    {
      elem_classes: (
        /*props*/
        c[2].elem_classes || []
      )
    },
    {
      disabled: (
        /*disabled*/
        c[1] || /*props*/
        c[2].disabled
      )
    }
  ];
  let E = {
    $$slots: {
      default: [create_default_slot$1]
    },
    $$scope: {
      ctx: c
    }
  };
  for (let S = 0; S < v.length; S += 1)
    E = assign$1(E, v[S]);
  return g = new Button({
    props: E
  }), g.$on(
    "click",
    /*openFileUpload*/
    c[6]
  ), {
    c() {
      a = element$3("input"), _ = space$3(), create_component$3(g.$$.fragment), this.h();
    },
    l(S) {
      a = claim_element$3(S, "INPUT", {
        webkitdirectory: !0,
        mozdirectory: !0,
        class: !0,
        accept: !0,
        type: !0
      }), _ = claim_space$3(S), claim_component$3(g.$$.fragment, S), this.h();
    },
    h() {
      attr$3(a, "webkitdirectory", h = /*file_count*/
      c[5] === "directory" || void 0), attr$3(a, "mozdirectory", d = /*file_count*/
      c[5] === "directory" || void 0), attr$3(a, "class", "hide svelte-u9r2nm"), attr$3(
        a,
        "accept",
        /*accept_file_types*/
        c[4]
      ), attr$3(a, "type", "file"), a.multiple = u = /*file_count*/
      c[5] === "multiple" || void 0;
    },
    m(S, R) {
      insert_hydration$3(S, a, R), c[9](a), insert_hydration$3(S, _, R), mount_component$3(g, S, R), $ = !0, b || (y = [listen$1(
        a,
        "change",
        /*loadFilesFromUpload*/
        c[7]
      ), listen$1(a, "click", clearInputValue)], b = !0);
    },
    p(S, [R]) {
      (!$ || R & /*file_count*/
      32 && h !== (h = /*file_count*/
      S[5] === "directory" || void 0)) && attr$3(a, "webkitdirectory", h), (!$ || R & /*file_count*/
      32 && d !== (d = /*file_count*/
      S[5] === "directory" || void 0)) && attr$3(a, "mozdirectory", d), (!$ || R & /*accept_file_types*/
      16) && attr$3(
        a,
        "accept",
        /*accept_file_types*/
        S[4]
      ), (!$ || R & /*file_count*/
      32 && u !== (u = /*file_count*/
      S[5] === "multiple" || void 0)) && (a.multiple = u);
      const x = R & /*props, disabled*/
      6 ? get_spread_update$1(v, [v[0], R & /*props*/
      4 && get_spread_object$1(
        /*props*/
        S[2]
      ), R & /*props*/
      4 && {
        elem_classes: (
          /*props*/
          S[2].elem_classes || []
        )
      }, {
        disabled: (
          /*disabled*/
          S[1] || /*props*/
          S[2].disabled
        )
      }]) : {};
      R & /*$$scope, i18n, props*/
      8197 && (x.$$scope = {
        dirty: R,
        ctx: S
      }), g.$set(x);
    },
    i(S) {
      $ || (transition_in$3(g.$$.fragment, S), $ = !0);
    },
    o(S) {
      transition_out$3(g.$$.fragment, S), $ = !1;
    },
    d(S) {
      S && (detach$3(a), detach$3(_)), c[9](null), destroy_component$3(g, S), b = !1, run_all$1(y);
    }
  };
}
function clearInputValue(c) {
  const a = c.target;
  a.value && (a.value = "");
}
function instance$3(c, a, h) {
  let d, u, {
    i18n: _
  } = a, {
    disabled: g = !1
  } = a, {
    props: $ = {}
  } = a;
  const b = createEventDispatcher$1();
  let y, v;
  const {
    upload: E
  } = getContextValue();
  function S() {
    b("click"), y.click();
  }
  async function R(T) {
    let C = Array.from(T);
    if (!T.length)
      return;
    d === "single" && (C = [T[0]]), await tick();
    const O = await E(C);
    b("change", O);
  }
  async function x(T) {
    const C = T.target;
    C.files && await R(C.files);
  }
  function H(T) {
    binding_callbacks$3[T ? "unshift" : "push"](() => {
      y = T, h(3, y);
    });
  }
  return c.$$set = (T) => {
    "i18n" in T && h(0, _ = T.i18n), "disabled" in T && h(1, g = T.disabled), "props" in T && h(2, $ = T.props);
  }, c.$$.update = () => {
    c.$$.dirty & /*props*/
    4 && h(5, d = $.file_count || "multiple"), c.$$.dirty & /*props*/
    4 && h(8, u = $.file_types || []), c.$$.dirty & /*file_types*/
    256 && (u == null ? h(4, v = null) : (h(8, u = u.map((T) => T.startsWith(".") ? T : T + "/*")), h(4, v = u.join(", "))));
  }, [_, g, $, y, v, d, S, x, u, H];
}
class UploadButton extends SvelteComponent$3 {
  constructor(a) {
    super(), init$3(this, a, instance$3, create_fragment$3, safe_not_equal$3, {
      i18n: 0,
      disabled: 1,
      props: 2
    });
  }
}
const {
  SvelteComponent: SvelteComponent$2,
  action_destroyer,
  append_hydration: append_hydration$2,
  attr: attr$2,
  binding_callbacks: binding_callbacks$2,
  check_outros: check_outros$2,
  children: children$2,
  claim_component: claim_component$2,
  claim_element: claim_element$2,
  claim_space: claim_space$2,
  claim_text: claim_text$2,
  create_component: create_component$2,
  destroy_component: destroy_component$2,
  destroy_each: destroy_each$1,
  detach: detach$2,
  element: element$2,
  empty: empty$1,
  ensure_array_like: ensure_array_like$1,
  group_outros: group_outros$2,
  init: init$2,
  insert_hydration: insert_hydration$2,
  is_function,
  listen,
  mount_component: mount_component$2,
  noop,
  run_all,
  safe_not_equal: safe_not_equal$2,
  set_data: set_data$2,
  set_input_value,
  space: space$2,
  stop_propagation,
  text: text$2,
  toggle_class: toggle_class$1,
  transition_in: transition_in$2,
  transition_out: transition_out$2
} = window.__gradio__svelte__internal, {
  createEventDispatcher,
  onMount: onMount$1
} = window.__gradio__svelte__internal;
function get_each_context$1(c, a, h) {
  const d = c.slice();
  return d[35] = a[h], d;
}
function create_else_block_3(c) {
  let a, h, d;
  return h = new Camera({}), {
    c() {
      a = element$2("div"), create_component$2(h.$$.fragment), this.h();
    },
    l(u) {
      a = claim_element$2(u, "DIV", {
        class: !0,
        title: !0
      });
      var _ = children$2(a);
      claim_component$2(h.$$.fragment, _), _.forEach(detach$2), this.h();
    },
    h() {
      attr$2(a, "class", "icon svelte-re2izc"), attr$2(a, "title", "capture photo");
    },
    m(u, _) {
      insert_hydration$2(u, a, _), mount_component$2(h, a, null), d = !0;
    },
    p: noop,
    i(u) {
      d || (transition_in$2(h.$$.fragment, u), d = !0);
    },
    o(u) {
      transition_out$2(h.$$.fragment, u), d = !1;
    },
    d(u) {
      u && detach$2(a), destroy_component$2(h);
    }
  };
}
function create_if_block_4$1(c) {
  let a, h, d, u;
  const _ = [create_if_block_5$1, create_else_block_2], g = [];
  function $(b, y) {
    return (
      /*recording*/
      b[7] ? 0 : 1
    );
  }
  return a = $(c), h = g[a] = _[a](c), {
    c() {
      h.c(), d = empty$1();
    },
    l(b) {
      h.l(b), d = empty$1();
    },
    m(b, y) {
      g[a].m(b, y), insert_hydration$2(b, d, y), u = !0;
    },
    p(b, y) {
      let v = a;
      a = $(b), a === v ? g[a].p(b, y) : (group_outros$2(), transition_out$2(g[v], 1, 1, () => {
        g[v] = null;
      }), check_outros$2(), h = g[a], h ? h.p(b, y) : (h = g[a] = _[a](b), h.c()), transition_in$2(h, 1), h.m(d.parentNode, d));
    },
    i(b) {
      u || (transition_in$2(h), u = !0);
    },
    o(b) {
      transition_out$2(h), u = !1;
    },
    d(b) {
      b && detach$2(d), g[a].d(b);
    }
  };
}
function create_else_block_2(c) {
  let a, h, d;
  return h = new Circle({}), {
    c() {
      a = element$2("div"), create_component$2(h.$$.fragment), this.h();
    },
    l(u) {
      a = claim_element$2(u, "DIV", {
        class: !0,
        title: !0
      });
      var _ = children$2(a);
      claim_component$2(h.$$.fragment, _), _.forEach(detach$2), this.h();
    },
    h() {
      attr$2(a, "class", "icon red svelte-re2izc"), attr$2(a, "title", "start recording");
    },
    m(u, _) {
      insert_hydration$2(u, a, _), mount_component$2(h, a, null), d = !0;
    },
    p: noop,
    i(u) {
      d || (transition_in$2(h.$$.fragment, u), d = !0);
    },
    o(u) {
      transition_out$2(h.$$.fragment, u), d = !1;
    },
    d(u) {
      u && detach$2(a), destroy_component$2(h);
    }
  };
}
function create_if_block_5$1(c) {
  let a, h, d, u, _, g = format_time(
    /*seconds*/
    c[5]
  ) + "", $, b;
  return d = new Square({}), {
    c() {
      a = element$2("div"), h = element$2("div"), create_component$2(d.$$.fragment), u = space$2(), _ = element$2("span"), $ = text$2(g), this.h();
    },
    l(y) {
      a = claim_element$2(y, "DIV", {
        class: !0
      });
      var v = children$2(a);
      h = claim_element$2(v, "DIV", {
        class: !0,
        title: !0
      });
      var E = children$2(h);
      claim_component$2(d.$$.fragment, E), E.forEach(detach$2), u = claim_space$2(v), _ = claim_element$2(v, "SPAN", {
        class: !0
      });
      var S = children$2(_);
      $ = claim_text$2(S, g), S.forEach(detach$2), v.forEach(detach$2), this.h();
    },
    h() {
      attr$2(h, "class", "icon red svelte-re2izc"), attr$2(h, "title", "stop recording"), attr$2(_, "class", "svelte-re2izc"), attr$2(a, "class", "recording-wrap svelte-re2izc");
    },
    m(y, v) {
      insert_hydration$2(y, a, v), append_hydration$2(a, h), mount_component$2(d, h, null), append_hydration$2(a, u), append_hydration$2(a, _), append_hydration$2(_, $), b = !0;
    },
    p(y, v) {
      (!b || v[0] & /*seconds*/
      32) && g !== (g = format_time(
        /*seconds*/
        y[5]
      ) + "") && set_data$2($, g);
    },
    i(y) {
      b || (transition_in$2(d.$$.fragment, y), b = !0);
    },
    o(y) {
      transition_out$2(d.$$.fragment, y), b = !1;
    },
    d(y) {
      y && detach$2(a), destroy_component$2(d);
    }
  };
}
function create_if_block_3$1(c) {
  let a, h, d, u, _, g, $;
  return d = new DropdownArrow({}), {
    c() {
      a = element$2("button"), h = element$2("div"), create_component$2(d.$$.fragment), this.h();
    },
    l(b) {
      a = claim_element$2(b, "BUTTON", {
        "aria-label": !0,
        class: !0
      });
      var y = children$2(a);
      h = claim_element$2(y, "DIV", {
        class: !0,
        title: !0
      });
      var v = children$2(h);
      claim_component$2(d.$$.fragment, v), v.forEach(detach$2), y.forEach(detach$2), this.h();
    },
    h() {
      attr$2(h, "class", "icon svelte-re2izc"), attr$2(h, "title", "select video source"), attr$2(a, "aria-label", u = /*mode*/
      c[6] === "image" ? "capture photo" : "start recording"), attr$2(a, "class", "svelte-re2izc");
    },
    m(b, y) {
      insert_hydration$2(b, a, y), append_hydration$2(a, h), mount_component$2(d, h, null), _ = !0, g || ($ = listen(
        a,
        "click",
        /*select_source*/
        c[12]
      ), g = !0);
    },
    p(b, y) {
      (!_ || y[0] & /*mode*/
      64 && u !== (u = /*mode*/
      b[6] === "image" ? "capture photo" : "start recording")) && attr$2(a, "aria-label", u);
    },
    i(b) {
      _ || (transition_in$2(d.$$.fragment, b), _ = !0);
    },
    o(b) {
      transition_out$2(d.$$.fragment, b), _ = !1;
    },
    d(b) {
      b && detach$2(a), destroy_component$2(d), g = !1, $();
    }
  };
}
function create_if_block_1$1(c) {
  let a, h, d, u, _, g, $;
  d = new DropdownArrow({});
  function b(E, S) {
    return (
      /*video_sources*/
      E[8].length === 0 ? create_if_block_2$1 : create_else_block_1
    );
  }
  let y = b(c), v = y(c);
  return {
    c() {
      a = element$2("select"), h = element$2("button"), create_component$2(d.$$.fragment), u = space$2(), v.c(), this.h();
    },
    l(E) {
      a = claim_element$2(E, "SELECT", {
        class: !0,
        "aria-label": !0
      });
      var S = children$2(a);
      h = claim_element$2(S, "BUTTON", {
        class: !0
      });
      var R = children$2(h);
      claim_component$2(d.$$.fragment, R), u = claim_space$2(R), R.forEach(detach$2), v.l(S), S.forEach(detach$2), this.h();
    },
    h() {
      attr$2(h, "class", "inset-icon svelte-re2izc"), attr$2(a, "class", "select-wrap svelte-re2izc"), attr$2(a, "aria-label", "select source");
    },
    m(E, S) {
      insert_hydration$2(E, a, S), append_hydration$2(a, h), mount_component$2(d, h, null), append_hydration$2(h, u), v.m(a, null), _ = !0, g || ($ = [listen(h, "click", stop_propagation(
        /*click_handler_1*/
        c[19]
      )), action_destroyer(click_outside.call(
        null,
        a,
        /*handle_click_outside*/
        c[14]
      ))], g = !0);
    },
    p(E, S) {
      y === (y = b(E)) && v ? v.p(E, S) : (v.d(1), v = y(E), v && (v.c(), v.m(a, null)));
    },
    i(E) {
      _ || (transition_in$2(d.$$.fragment, E), _ = !0);
    },
    o(E) {
      transition_out$2(d.$$.fragment, E), _ = !1;
    },
    d(E) {
      E && detach$2(a), destroy_component$2(d), v.d(), g = !1, run_all($);
    }
  };
}
function create_else_block_1(c) {
  let a, h = ensure_array_like$1(
    /*video_sources*/
    c[8]
  ), d = [];
  for (let u = 0; u < h.length; u += 1)
    d[u] = create_each_block$1(get_each_context$1(c, h, u));
  return {
    c() {
      for (let u = 0; u < d.length; u += 1)
        d[u].c();
      a = empty$1();
    },
    l(u) {
      for (let _ = 0; _ < d.length; _ += 1)
        d[_].l(u);
      a = empty$1();
    },
    m(u, _) {
      for (let g = 0; g < d.length; g += 1)
        d[g] && d[g].m(u, _);
      insert_hydration$2(u, a, _);
    },
    p(u, _) {
      if (_[0] & /*video_sources, selectVideoSource*/
      8448) {
        h = ensure_array_like$1(
          /*video_sources*/
          u[8]
        );
        let g;
        for (g = 0; g < h.length; g += 1) {
          const $ = get_each_context$1(u, h, g);
          d[g] ? d[g].p($, _) : (d[g] = create_each_block$1($), d[g].c(), d[g].m(a.parentNode, a));
        }
        for (; g < d.length; g += 1)
          d[g].d(1);
        d.length = h.length;
      }
    },
    d(u) {
      u && detach$2(a), destroy_each$1(d, u);
    }
  };
}
function create_if_block_2$1(c) {
  let a, h = (
    /*i18n*/
    c[2]("common.no_devices") + ""
  ), d;
  return {
    c() {
      a = element$2("option"), d = text$2(h), this.h();
    },
    l(u) {
      a = claim_element$2(u, "OPTION", {
        class: !0
      });
      var _ = children$2(a);
      d = claim_text$2(_, h), _.forEach(detach$2), this.h();
    },
    h() {
      a.__value = "", set_input_value(a, a.__value), attr$2(a, "class", "svelte-re2izc");
    },
    m(u, _) {
      insert_hydration$2(u, a, _), append_hydration$2(a, d);
    },
    p(u, _) {
      _[0] & /*i18n*/
      4 && h !== (h = /*i18n*/
      u[2]("common.no_devices") + "") && set_data$2(d, h);
    },
    d(u) {
      u && detach$2(a);
    }
  };
}
function create_each_block$1(c) {
  let a, h = (
    /*source*/
    c[35].label + ""
  ), d, u, _, g, $;
  function b() {
    return (
      /*click_handler_2*/
      c[20](
        /*source*/
        c[35]
      )
    );
  }
  return {
    c() {
      a = element$2("option"), d = text$2(h), u = space$2(), this.h();
    },
    l(y) {
      a = claim_element$2(y, "OPTION", {
        class: !0
      });
      var v = children$2(a);
      d = claim_text$2(v, h), u = claim_space$2(v), v.forEach(detach$2), this.h();
    },
    h() {
      a.__value = _ = `
              ` + /*source*/
      c[35].label + `
            `, set_input_value(a, a.__value), attr$2(a, "class", "svelte-re2izc");
    },
    m(y, v) {
      insert_hydration$2(y, a, v), append_hydration$2(a, d), append_hydration$2(a, u), g || ($ = listen(a, "click", b), g = !0);
    },
    p(y, v) {
      c = y, v[0] & /*video_sources*/
      256 && h !== (h = /*source*/
      c[35].label + "") && set_data$2(d, h), v[0] & /*video_sources*/
      256 && _ !== (_ = `
              ` + /*source*/
      c[35].label + `
            `) && (a.__value = _, set_input_value(a, a.__value));
    },
    d(y) {
      y && detach$2(a), g = !1, $();
    }
  };
}
function create_else_block(c) {
  let a, h;
  return a = new Image$2({}), {
    c() {
      create_component$2(a.$$.fragment);
    },
    l(d) {
      claim_component$2(a.$$.fragment, d);
    },
    m(d, u) {
      mount_component$2(a, d, u), h = !0;
    },
    i(d) {
      h || (transition_in$2(a.$$.fragment, d), h = !0);
    },
    o(d) {
      transition_out$2(a.$$.fragment, d), h = !1;
    },
    d(d) {
      destroy_component$2(a, d);
    }
  };
}
function create_if_block$2(c) {
  let a, h;
  return a = new Video$1({}), {
    c() {
      create_component$2(a.$$.fragment);
    },
    l(d) {
      claim_component$2(a.$$.fragment, d);
    },
    m(d, u) {
      mount_component$2(a, d, u), h = !0;
    },
    i(d) {
      h || (transition_in$2(a.$$.fragment, d), h = !0);
    },
    o(d) {
      transition_out$2(a.$$.fragment, d), h = !1;
    },
    d(d) {
      destroy_component$2(a, d);
    }
  };
}
function create_fragment$2(c) {
  let a, h, d, u, _, g, $, b, y, v, E, S, R, x, H, T, C, O, j, B, D, M, I, P, L, Y, N;
  h = new Webcam({});
  const W = [create_if_block_4$1, create_else_block_3], V = [];
  function ue(ae, le) {
    return (
      /*mode*/
      ae[6] === "video" ? 0 : 1
    );
  }
  E = ue(c), S = V[E] = W[E](c);
  let se = !/*recording*/
  c[7] && create_if_block_3$1(c), ce = (
    /*options_open*/
    c[9] && create_if_block_1$1(c)
  );
  const oe = [create_if_block$2, create_else_block], ge = [];
  function J(ae, le) {
    return (
      /*mode*/
      ae[6] === "image" ? 0 : 1
    );
  }
  return j = J(c), B = ge[j] = oe[j](c), I = new RemoveIcon({}), {
    c() {
      a = element$2("button"), create_component$2(h.$$.fragment), u = space$2(), _ = element$2("div"), g = element$2("div"), $ = element$2("video"), b = space$2(), y = element$2("div"), v = element$2("button"), S.c(), x = space$2(), se && se.c(), H = space$2(), ce && ce.c(), T = space$2(), C = element$2("div"), O = element$2("button"), B.c(), D = space$2(), M = element$2("button"), create_component$2(I.$$.fragment), this.h();
    },
    l(ae) {
      a = claim_element$2(ae, "BUTTON", {
        style: !0,
        class: !0
      });
      var le = children$2(a);
      claim_component$2(h.$$.fragment, le), le.forEach(detach$2), u = claim_space$2(ae), _ = claim_element$2(ae, "DIV", {
        style: !0,
        class: !0
      });
      var z = children$2(_);
      g = claim_element$2(z, "DIV", {
        class: !0
      });
      var A = children$2(g);
      $ = claim_element$2(A, "VIDEO", {
        class: !0
      }), children$2($).forEach(detach$2), b = claim_space$2(A), y = claim_element$2(A, "DIV", {
        class: !0
      });
      var F = children$2(y);
      v = claim_element$2(F, "BUTTON", {
        "aria-label": !0,
        class: !0
      });
      var U = children$2(v);
      S.l(U), U.forEach(detach$2), x = claim_space$2(F), se && se.l(F), F.forEach(detach$2), H = claim_space$2(A), ce && ce.l(A), A.forEach(detach$2), T = claim_space$2(z), C = claim_element$2(z, "DIV", {
        class: !0
      });
      var Z = children$2(C);
      O = claim_element$2(Z, "BUTTON", {
        class: !0
      });
      var G = children$2(O);
      B.l(G), G.forEach(detach$2), D = claim_space$2(Z), M = claim_element$2(Z, "BUTTON", {
        class: !0
      });
      var Q = children$2(M);
      claim_component$2(I.$$.fragment, Q), Q.forEach(detach$2), Z.forEach(detach$2), z.forEach(detach$2), this.h();
    },
    h() {
      attr$2(a, "style", d = /*open*/
      c[3] ? "display: none;" : ""), attr$2(a, "class", "icon-button webcam svelte-re2izc"), toggle_class$1(
        a,
        "disabled",
        /*disabled*/
        c[1]
      ), attr$2($, "class", "svelte-re2izc"), toggle_class$1(
        $,
        "flip",
        /*mirror_webcam*/
        c[0]
      ), attr$2(v, "aria-label", R = /*mode*/
      c[6] === "image" ? "capture photo" : "start recording"), attr$2(v, "class", "svelte-re2izc"), attr$2(y, "class", "button-wrap svelte-re2izc"), attr$2(g, "class", "wrap svelte-re2izc"), attr$2(O, "class", "icon-button svelte-re2izc"), attr$2(M, "class", "icon-button svelte-re2izc"), attr$2(C, "class", "extra-wrap svelte-re2izc"), attr$2(_, "style", P = /*open*/
      c[3] ? "" : "display: none;"), attr$2(_, "class", "controls svelte-re2izc");
    },
    m(ae, le) {
      insert_hydration$2(ae, a, le), mount_component$2(h, a, null), insert_hydration$2(ae, u, le), insert_hydration$2(ae, _, le), append_hydration$2(_, g), append_hydration$2(g, $), c[18]($), append_hydration$2(g, b), append_hydration$2(g, y), append_hydration$2(y, v), V[E].m(v, null), append_hydration$2(y, x), se && se.m(y, null), append_hydration$2(g, H), ce && ce.m(g, null), append_hydration$2(_, T), append_hydration$2(_, C), append_hydration$2(C, O), ge[j].m(O, null), append_hydration$2(C, D), append_hydration$2(C, M), mount_component$2(I, M, null), L = !0, Y || (N = [listen(
        a,
        "click",
        /*click_handler*/
        c[17]
      ), listen(v, "click", function() {
        is_function(
          /*mode*/
          c[6] === "image" ? (
            /*take_picture*/
            c[10]
          ) : (
            /*take_recording*/
            c[11]
          )
        ) && /*mode*/
        (c[6] === "image" ? (
          /*take_picture*/
          c[10]
        ) : (
          /*take_recording*/
          c[11]
        )).apply(this, arguments);
      }), listen(
        O,
        "click",
        /*click_handler_3*/
        c[21]
      ), listen(
        M,
        "click",
        /*click_handler_4*/
        c[22]
      )], Y = !0);
    },
    p(ae, le) {
      c = ae, (!L || le[0] & /*open*/
      8 && d !== (d = /*open*/
      c[3] ? "display: none;" : "")) && attr$2(a, "style", d), (!L || le[0] & /*disabled*/
      2) && toggle_class$1(
        a,
        "disabled",
        /*disabled*/
        c[1]
      ), (!L || le[0] & /*mirror_webcam*/
      1) && toggle_class$1(
        $,
        "flip",
        /*mirror_webcam*/
        c[0]
      );
      let z = E;
      E = ue(c), E === z ? V[E].p(c, le) : (group_outros$2(), transition_out$2(V[z], 1, 1, () => {
        V[z] = null;
      }), check_outros$2(), S = V[E], S ? S.p(c, le) : (S = V[E] = W[E](c), S.c()), transition_in$2(S, 1), S.m(v, null)), (!L || le[0] & /*mode*/
      64 && R !== (R = /*mode*/
      c[6] === "image" ? "capture photo" : "start recording")) && attr$2(v, "aria-label", R), /*recording*/
      c[7] ? se && (group_outros$2(), transition_out$2(se, 1, 1, () => {
        se = null;
      }), check_outros$2()) : se ? (se.p(c, le), le[0] & /*recording*/
      128 && transition_in$2(se, 1)) : (se = create_if_block_3$1(c), se.c(), transition_in$2(se, 1), se.m(y, null)), /*options_open*/
      c[9] ? ce ? (ce.p(c, le), le[0] & /*options_open*/
      512 && transition_in$2(ce, 1)) : (ce = create_if_block_1$1(c), ce.c(), transition_in$2(ce, 1), ce.m(g, null)) : ce && (group_outros$2(), transition_out$2(ce, 1, 1, () => {
        ce = null;
      }), check_outros$2());
      let A = j;
      j = J(c), j !== A && (group_outros$2(), transition_out$2(ge[A], 1, 1, () => {
        ge[A] = null;
      }), check_outros$2(), B = ge[j], B || (B = ge[j] = oe[j](c), B.c()), transition_in$2(B, 1), B.m(O, null)), (!L || le[0] & /*open*/
      8 && P !== (P = /*open*/
      c[3] ? "" : "display: none;")) && attr$2(_, "style", P);
    },
    i(ae) {
      L || (transition_in$2(h.$$.fragment, ae), transition_in$2(S), transition_in$2(se), transition_in$2(ce), transition_in$2(B), transition_in$2(I.$$.fragment, ae), L = !0);
    },
    o(ae) {
      transition_out$2(h.$$.fragment, ae), transition_out$2(S), transition_out$2(se), transition_out$2(ce), transition_out$2(B), transition_out$2(I.$$.fragment, ae), L = !1;
    },
    d(ae) {
      ae && (detach$2(a), detach$2(u), detach$2(_)), destroy_component$2(h), c[18](null), V[E].d(), se && se.d(), ce && ce.d(), ge[j].d(), destroy_component$2(I), Y = !1, run_all(N);
    }
  };
}
function click_outside(c, a) {
  const h = (d) => {
    c && !c.contains(d.target) && !d.defaultPrevented && a(d);
  };
  return document.addEventListener("click", h, !0), {
    destroy() {
      document.removeEventListener("click", h, !0);
    }
  };
}
function instance$2(c, a, h) {
  let {
    mirror_webcam: d = !0
  } = a, {
    include_audio: u = !1
  } = a, {
    disabled: _ = !1
  } = a, {
    i18n: g
  } = a, $, b, y = !1, v = 0, E = !1, S, R = "image";
  const x = createEventDispatcher(), {
    upload: H
  } = getContextValue();
  onMount$1(() => b = document.createElement("canvas"));
  const T = {
    width: {
      ideal: 1920
    },
    height: {
      ideal: 1440
    }
  }, C = () => {
    clearInterval(S), h(7, D = !0), h(5, v = 0), S = setInterval(() => {
      h(5, v++, v);
    }, 1e3);
  }, O = () => {
    L == null || L.stop(), clearInterval(S), h(5, v = 0), h(7, D = !1);
  };
  async function j(z) {
    if (!(!z && E)) {
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        x("error", g("image.no_webcam_support"));
        return;
      }
      try {
        I = await navigator.mediaDevices.getUserMedia({
          video: z ? {
            deviceId: {
              exact: z
            },
            ...T
          } : T,
          audio: u
        }), h(16, E = !0), h(4, $.srcObject = I, $), h(4, $.muted = !0, $), $.play();
      } catch (A) {
        if (A instanceof DOMException && A.name == "NotAllowedError")
          x("error", g("image.allow_webcam_access"));
        else
          throw A;
      }
    }
  }
  function B() {
    const z = b.getContext("2d");
    $.videoWidth && $.videoHeight && (b.width = $.videoWidth, b.height = $.videoHeight, z.drawImage($, 0, 0, $.videoWidth, $.videoHeight), d && (z.scale(-1, 1), z.drawImage($, -$.videoWidth, 0)), b.toBlob(async (A) => {
      if (A) {
        const F = new File([A], "image.png", {
          type: "image/png"
        }), U = (await H([F]))[0];
        x("change", U);
      }
    }, "image/png", 0.8));
  }
  let D = !1, M = [], I, P, L;
  function Y() {
    if (D) {
      O();
      const z = new Blob(M, {
        type: P
      }), A = new FileReader();
      A.onload = async function(F) {
        if (F.target) {
          const U = new File([z], "video." + P.substring(6)), Z = (await H([U]))[0];
          x("change", Z);
        }
      }, A.readAsDataURL(z);
    } else {
      M = [];
      const z = ["video/webm", "video/mp4"];
      for (const A of z)
        if (MediaRecorder.isTypeSupported(A)) {
          P = A;
          break;
        }
      if (P === null) {
        console.error("No supported MediaRecorder mimeType");
        return;
      }
      L = new MediaRecorder(I, {
        mimeType: P
      }), L.addEventListener("dataavailable", function(A) {
        M.push(A.data);
      }), L.start(200), C();
    }
  }
  async function N() {
    const z = await navigator.mediaDevices.enumerateDevices();
    h(8, W = z.filter((A) => A.kind === "videoinput")), h(9, ue = !0);
  }
  let W = [];
  async function V(z) {
    await j(z), h(9, ue = !1);
  }
  let ue = !1;
  function se(z) {
    z.preventDefault(), z.stopPropagation(), h(9, ue = !1);
  }
  const ce = () => {
    _ || h(3, y = !0);
  };
  function oe(z) {
    binding_callbacks$2[z ? "unshift" : "push"](() => {
      $ = z, h(4, $);
    });
  }
  const ge = () => h(9, ue = !1), J = (z) => V(z.deviceId), ae = () => {
    R === "image" ? h(6, R = "video") : h(6, R = "image");
  }, le = () => {
    h(3, y = !1);
  };
  return c.$$set = (z) => {
    "mirror_webcam" in z && h(0, d = z.mirror_webcam), "include_audio" in z && h(15, u = z.include_audio), "disabled" in z && h(1, _ = z.disabled), "i18n" in z && h(2, g = z.i18n);
  }, c.$$.update = () => {
    c.$$.dirty[0] & /*open, accessed*/
    65544 && (y ? !E && j() : O());
  }, [d, _, g, y, $, v, R, D, W, ue, B, Y, N, V, se, u, E, ce, oe, ge, J, ae, le];
}
class Webcam_1 extends SvelteComponent$2 {
  constructor(a) {
    super(), init$2(this, a, instance$2, create_fragment$2, safe_not_equal$2, {
      mirror_webcam: 0,
      include_audio: 15,
      disabled: 1,
      i18n: 2
    }, null, [-1, -1]);
  }
}
const {
  SvelteComponent: SvelteComponent$1,
  add_iframe_resize_listener,
  add_render_callback,
  append_hydration: append_hydration$1,
  attr: attr$1,
  binding_callbacks: binding_callbacks$1,
  check_outros: check_outros$1,
  children: children$1,
  claim_component: claim_component$1,
  claim_element: claim_element$1,
  claim_space: claim_space$1,
  claim_text: claim_text$1,
  create_component: create_component$1,
  destroy_component: destroy_component$1,
  detach: detach$1,
  element: element$1,
  group_outros: group_outros$1,
  init: init$1,
  insert_hydration: insert_hydration$1,
  mount_component: mount_component$1,
  safe_not_equal: safe_not_equal$1,
  set_data: set_data$1,
  space: space$1,
  text: text$1,
  toggle_class,
  transition_in: transition_in$1,
  transition_out: transition_out$1
} = window.__gradio__svelte__internal, {
  onMount
} = window.__gradio__svelte__internal;
function create_if_block$1(c) {
  let a, h, d, u, _ = (
    /*value*/
    c[0].files.map(func).join(", ") + ""
  ), g, $;
  return d = new File$1({}), {
    c() {
      a = element$1("span"), h = element$1("i"), create_component$1(d.$$.fragment), u = space$1(), g = text$1(_), this.h();
    },
    l(b) {
      a = claim_element$1(b, "SPAN", {
        class: !0
      });
      var y = children$1(a);
      h = claim_element$1(y, "I", {
        class: !0
      });
      var v = children$1(h);
      claim_component$1(d.$$.fragment, v), v.forEach(detach$1), u = claim_space$1(y), g = claim_text$1(y, _), y.forEach(detach$1), this.h();
    },
    h() {
      attr$1(h, "class", "svelte-1j28ovu"), attr$1(a, "class", "files svelte-1j28ovu");
    },
    m(b, y) {
      insert_hydration$1(b, a, y), append_hydration$1(a, h), mount_component$1(d, h, null), append_hydration$1(a, u), append_hydration$1(a, g), $ = !0;
    },
    p(b, y) {
      (!$ || y & /*value*/
      1) && _ !== (_ = /*value*/
      b[0].files.map(func).join(", ") + "") && set_data$1(g, _);
    },
    i(b) {
      $ || (transition_in$1(d.$$.fragment, b), $ = !0);
    },
    o(b) {
      transition_out$1(d.$$.fragment, b), $ = !1;
    },
    d(b) {
      b && detach$1(a), destroy_component$1(d);
    }
  };
}
function create_fragment$1(c) {
  var y;
  let a, h, d = (
    /*value*/
    c[0].text + ""
  ), u, _, g, $, b = (
    /*value*/
    ((y = c[0].files) == null ? void 0 : y.length) > 0 && create_if_block$1(c)
  );
  return {
    c() {
      a = element$1("div"), h = element$1("span"), u = text$1(d), _ = space$1(), b && b.c(), this.h();
    },
    l(v) {
      a = claim_element$1(v, "DIV", {
        class: !0
      });
      var E = children$1(a);
      h = claim_element$1(E, "SPAN", {});
      var S = children$1(h);
      u = claim_text$1(S, d), S.forEach(detach$1), _ = claim_space$1(E), b && b.l(E), E.forEach(detach$1), this.h();
    },
    h() {
      attr$1(a, "class", "svelte-1j28ovu"), add_render_callback(() => (
        /*div_elementresize_handler*/
        c[5].call(a)
      )), toggle_class(
        a,
        "table",
        /*type*/
        c[1] === "table"
      ), toggle_class(
        a,
        "gallery",
        /*type*/
        c[1] === "gallery"
      ), toggle_class(
        a,
        "selected",
        /*selected*/
        c[2]
      );
    },
    m(v, E) {
      insert_hydration$1(v, a, E), append_hydration$1(a, h), append_hydration$1(h, u), append_hydration$1(a, _), b && b.m(a, null), g = add_iframe_resize_listener(
        a,
        /*div_elementresize_handler*/
        c[5].bind(a)
      ), c[6](a), $ = !0;
    },
    p(v, [E]) {
      var S;
      (!$ || E & /*value*/
      1) && d !== (d = /*value*/
      v[0].text + "") && set_data$1(u, d), /*value*/
      ((S = v[0].files) == null ? void 0 : S.length) > 0 ? b ? (b.p(v, E), E & /*value*/
      1 && transition_in$1(b, 1)) : (b = create_if_block$1(v), b.c(), transition_in$1(b, 1), b.m(a, null)) : b && (group_outros$1(), transition_out$1(b, 1, 1, () => {
        b = null;
      }), check_outros$1()), (!$ || E & /*type*/
      2) && toggle_class(
        a,
        "table",
        /*type*/
        v[1] === "table"
      ), (!$ || E & /*type*/
      2) && toggle_class(
        a,
        "gallery",
        /*type*/
        v[1] === "gallery"
      ), (!$ || E & /*selected*/
      4) && toggle_class(
        a,
        "selected",
        /*selected*/
        v[2]
      );
    },
    i(v) {
      $ || (transition_in$1(b), $ = !0);
    },
    o(v) {
      transition_out$1(b), $ = !1;
    },
    d(v) {
      v && detach$1(a), b && b.d(), g(), c[6](null);
    }
  };
}
const func = (c) => c.orig_name;
function instance$1(c, a, h) {
  let {
    value: d
  } = a, {
    type: u
  } = a, {
    selected: _ = !1
  } = a, g, $;
  function b(E, S) {
    !E || !S || ($.style.setProperty("--local-text-width", `${S < 150 ? S : 200}px`), h(4, $.style.whiteSpace = "unset", $));
  }
  onMount(() => {
    b($, g);
  });
  function y() {
    g = this.clientWidth, h(3, g);
  }
  function v(E) {
    binding_callbacks$1[E ? "unshift" : "push"](() => {
      $ = E, h(4, $);
    });
  }
  return c.$$set = (E) => {
    "value" in E && h(0, d = E.value), "type" in E && h(1, u = E.type), "selected" in E && h(2, _ = E.selected);
  }, [d, u, _, g, $, y, v];
}
class Example extends SvelteComponent$1 {
  constructor(a) {
    super(), init$1(this, a, instance$1, create_fragment$1, safe_not_equal$1, {
      value: 0,
      type: 1,
      selected: 2
    });
  }
}
const {
  SvelteComponent,
  add_flush_callback,
  append_hydration,
  assign,
  attr,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_text,
  create_component,
  destroy_component,
  destroy_each,
  detach,
  element,
  empty,
  ensure_array_like,
  flush,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration,
  mount_component,
  safe_not_equal,
  set_data,
  space,
  text,
  transition_in,
  transition_out
} = window.__gradio__svelte__internal, {
  Boolean: Boolean_1
} = globals, {
  getContext
} = window.__gradio__svelte__internal;
function get_each_context(c, a, h) {
  const d = c.slice();
  return d[53] = a[h], d;
}
function create_if_block_5(c) {
  let a, h;
  const d = [
    {
      autoscroll: (
        /*gradio*/
        c[2].autoscroll
      )
    },
    {
      i18n: (
        /*gradio*/
        c[2].i18n
      )
    },
    /*loading_status*/
    c[17]
  ];
  let u = {};
  for (let _ = 0; _ < d.length; _ += 1)
    u = assign(u, d[_]);
  return a = new Static({
    props: u
  }), {
    c() {
      create_component(a.$$.fragment);
    },
    l(_) {
      claim_component(a.$$.fragment, _);
    },
    m(_, g) {
      mount_component(a, _, g), h = !0;
    },
    p(_, g) {
      const $ = g[0] & /*gradio, loading_status*/
      131076 ? get_spread_update(d, [g[0] & /*gradio*/
      4 && {
        autoscroll: (
          /*gradio*/
          _[2].autoscroll
        )
      }, g[0] & /*gradio*/
      4 && {
        i18n: (
          /*gradio*/
          _[2].i18n
        )
      }, g[0] & /*loading_status*/
      131072 && get_spread_object(
        /*loading_status*/
        _[17]
      )]) : {};
      a.$set($);
    },
    i(_) {
      h || (transition_in(a.$$.fragment, _), h = !0);
    },
    o(_) {
      transition_out(a.$$.fragment, _), h = !1;
    },
    d(_) {
      destroy_component(a, _);
    }
  };
}
function create_if_block_4(c) {
  let a, h;
  return a = new BlockTitle({
    props: {
      show_label: (
        /*show_label*/
        c[10]
      ),
      info: (
        /*info*/
        c[4]
      ),
      $$slots: {
        default: [create_default_slot_1]
      },
      $$scope: {
        ctx: c
      }
    }
  }), {
    c() {
      create_component(a.$$.fragment);
    },
    l(d) {
      claim_component(a.$$.fragment, d);
    },
    m(d, u) {
      mount_component(a, d, u), h = !0;
    },
    p(d, u) {
      const _ = {};
      u[0] & /*show_label*/
      1024 && (_.show_label = /*show_label*/
      d[10]), u[0] & /*info*/
      16 && (_.info = /*info*/
      d[4]), u[0] & /*label*/
      8 | u[1] & /*$$scope*/
      33554432 && (_.$$scope = {
        dirty: u,
        ctx: d
      }), a.$set(_);
    },
    i(d) {
      h || (transition_in(a.$$.fragment, d), h = !0);
    },
    o(d) {
      transition_out(a.$$.fragment, d), h = !1;
    },
    d(d) {
      destroy_component(a, d);
    }
  };
}
function create_default_slot_1(c) {
  let a;
  return {
    c() {
      a = text(
        /*label*/
        c[3]
      );
    },
    l(h) {
      a = claim_text(
        h,
        /*label*/
        c[3]
      );
    },
    m(h, d) {
      insert_hydration(h, a, d);
    },
    p(h, d) {
      d[0] & /*label*/
      8 && set_data(
        a,
        /*label*/
        h[3]
      );
    },
    d(h) {
      h && detach(a);
    }
  };
}
function create_if_block_3(c) {
  let a, h, d, u;
  const _ = [
    /*_webcam_props*/
    c[24],
    {
      i18n: (
        /*gradio*/
        c[2].i18n
      )
    },
    {
      disabled: !/*interactive*/
      c[22]
    }
  ];
  let g = {};
  for (let $ = 0; $ < _.length; $ += 1)
    g = assign(g, _[$]);
  return h = new Webcam_1({
    props: g
  }), h.$on(
    "error",
    /*error_handler_1*/
    c[46]
  ), h.$on(
    "change",
    /*change_handler_3*/
    c[47]
  ), {
    c() {
      a = element("span"), create_component(h.$$.fragment), d = space(), this.h();
    },
    l($) {
      a = claim_element($, "SPAN", {
        class: !0
      });
      var b = children(a);
      claim_component(h.$$.fragment, b), d = claim_space(b), b.forEach(detach), this.h();
    },
    h() {
      attr(a, "class", "tool-button svelte-9felha");
    },
    m($, b) {
      insert_hydration($, a, b), mount_component(h, a, null), append_hydration(a, d), u = !0;
    },
    p($, b) {
      const y = b[0] & /*_webcam_props, gradio, interactive*/
      20971524 ? get_spread_update(_, [b[0] & /*_webcam_props*/
      16777216 && get_spread_object(
        /*_webcam_props*/
        $[24]
      ), b[0] & /*gradio*/
      4 && {
        i18n: (
          /*gradio*/
          $[2].i18n
        )
      }, b[0] & /*interactive*/
      4194304 && {
        disabled: !/*interactive*/
        $[22]
      }]) : {};
      h.$set(y);
    },
    i($) {
      u || (transition_in(h.$$.fragment, $), u = !0);
    },
    o($) {
      transition_out(h.$$.fragment, $), u = !1;
    },
    d($) {
      $ && detach(a), destroy_component(h);
    }
  };
}
function create_if_block_2(c) {
  let a, h, d, u;
  return h = new AudioRecorder({
    props: {
      i18n: (
        /*gradio*/
        c[2].i18n
      ),
      disabled: !/*interactive*/
      c[22]
    }
  }), h.$on(
    "error",
    /*error_handler*/
    c[44]
  ), h.$on(
    "change",
    /*change_handler_2*/
    c[45]
  ), {
    c() {
      a = element("span"), create_component(h.$$.fragment), d = space(), this.h();
    },
    l(_) {
      a = claim_element(_, "SPAN", {
        class: !0
      });
      var g = children(a);
      claim_component(h.$$.fragment, g), d = claim_space(g), g.forEach(detach), this.h();
    },
    h() {
      attr(a, "class", "tool-button svelte-9felha");
    },
    m(_, g) {
      insert_hydration(_, a, g), mount_component(h, a, null), append_hydration(a, d), u = !0;
    },
    p(_, g) {
      const $ = {};
      g[0] & /*gradio*/
      4 && ($.i18n = /*gradio*/
      _[2].i18n), g[0] & /*interactive*/
      4194304 && ($.disabled = !/*interactive*/
      _[22]), h.$set($);
    },
    i(_) {
      u || (transition_in(h.$$.fragment, _), u = !0);
    },
    o(_) {
      transition_out(h.$$.fragment, _), u = !1;
    },
    d(_) {
      _ && detach(a), destroy_component(h);
    }
  };
}
function create_if_block_1(c) {
  let a, h, d, u;
  return h = new UploadButton({
    props: {
      props: (
        /*_upload_button_props*/
        c[23]
      ),
      disabled: !/*interactive*/
      c[22],
      i18n: (
        /*gradio*/
        c[2].i18n
      )
    }
  }), h.$on(
    "change",
    /*change_handler_1*/
    c[42]
  ), h.$on(
    "click",
    /*click_handler*/
    c[43]
  ), {
    c() {
      a = element("span"), create_component(h.$$.fragment), d = space(), this.h();
    },
    l(_) {
      a = claim_element(_, "SPAN", {
        class: !0
      });
      var g = children(a);
      claim_component(h.$$.fragment, g), d = claim_space(g), g.forEach(detach), this.h();
    },
    h() {
      attr(a, "class", "tool-button upload-button svelte-9felha");
    },
    m(_, g) {
      insert_hydration(_, a, g), mount_component(h, a, null), append_hydration(a, d), u = !0;
    },
    p(_, g) {
      const $ = {};
      g[0] & /*_upload_button_props*/
      8388608 && ($.props = /*_upload_button_props*/
      _[23]), g[0] & /*interactive*/
      4194304 && ($.disabled = !/*interactive*/
      _[22]), g[0] & /*gradio*/
      4 && ($.i18n = /*gradio*/
      _[2].i18n), h.$set($);
    },
    i(_) {
      u || (transition_in(h.$$.fragment, _), u = !0);
    },
    o(_) {
      transition_out(h.$$.fragment, _), u = !1;
    },
    d(_) {
      _ && detach(a), destroy_component(h);
    }
  };
}
function create_each_block(c) {
  let a, h, d, u;
  const _ = [create_if_block_1, create_if_block_2, create_if_block_3], g = [];
  function $(b, y) {
    return (
      /*source*/
      b[53] === "upload" ? 0 : (
        /*source*/
        b[53] === "microphone" ? 1 : (
          /*source*/
          b[53] === "webcam" ? 2 : -1
        )
      )
    );
  }
  return ~(a = $(c)) && (h = g[a] = _[a](c)), {
    c() {
      h && h.c(), d = empty();
    },
    l(b) {
      h && h.l(b), d = empty();
    },
    m(b, y) {
      ~a && g[a].m(b, y), insert_hydration(b, d, y), u = !0;
    },
    p(b, y) {
      let v = a;
      a = $(b), a === v ? ~a && g[a].p(b, y) : (h && (group_outros(), transition_out(g[v], 1, 1, () => {
        g[v] = null;
      }), check_outros()), ~a ? (h = g[a], h ? h.p(b, y) : (h = g[a] = _[a](b), h.c()), transition_in(h, 1), h.m(d.parentNode, d)) : h = null);
    },
    i(b) {
      u || (transition_in(h), u = !0);
    },
    o(b) {
      transition_out(h), u = !1;
    },
    d(b) {
      b && detach(d), ~a && g[a].d(b);
    }
  };
}
function create_if_block(c) {
  let a, h;
  return a = new FilePreview({
    props: {
      loading: (
        /*uploading*/
        c[27]
      ),
      theme: (
        /*gradio*/
        c[2].theme
      ),
      i18n: (
        /*gradio*/
        c[2].i18n
      ),
      value: (
        /*value*/
        c[0].files
      ),
      props: (
        /*_file_preview_props*/
        c[26]
      ),
      disabled: !/*interactive*/
      c[22]
    }
  }), a.$on(
    "select",
    /*select_handler*/
    c[49]
  ), a.$on(
    "delete",
    /*delete_handler*/
    c[50]
  ), {
    c() {
      create_component(a.$$.fragment);
    },
    l(d) {
      claim_component(a.$$.fragment, d);
    },
    m(d, u) {
      mount_component(a, d, u), h = !0;
    },
    p(d, u) {
      const _ = {};
      u[0] & /*uploading*/
      134217728 && (_.loading = /*uploading*/
      d[27]), u[0] & /*gradio*/
      4 && (_.theme = /*gradio*/
      d[2].theme), u[0] & /*gradio*/
      4 && (_.i18n = /*gradio*/
      d[2].i18n), u[0] & /*value*/
      1 && (_.value = /*value*/
      d[0].files), u[0] & /*_file_preview_props*/
      67108864 && (_.props = /*_file_preview_props*/
      d[26]), u[0] & /*interactive*/
      4194304 && (_.disabled = !/*interactive*/
      d[22]), a.$set(_);
    },
    i(d) {
      h || (transition_in(a.$$.fragment, d), h = !0);
    },
    o(d) {
      transition_out(a.$$.fragment, d), h = !1;
    },
    d(d) {
      destroy_component(a, d);
    }
  };
}
function create_default_slot(c) {
  var I;
  let a, h, d, u, _, g, $, b, y, v, E, S, R, x, H = (
    /*loading_status*/
    c[17] && create_if_block_5(c)
  ), T = (
    /*show_label*/
    c[10] && /*label*/
    c[3] && create_if_block_4(c)
  );
  function C(P) {
    c[35](P);
  }
  let O = {
    value: (
      /*value*/
      c[0].text
    ),
    show_label: (
      /*show_label*/
      c[10]
    ),
    lines: (
      /*lines*/
      c[8]
    ),
    type: (
      /*type*/
      c[12]
    ),
    rtl: (
      /*rtl*/
      c[18]
    ),
    text_align: (
      /*text_align*/
      c[19]
    ),
    max_lines: /*max_lines*/ c[11] ? (
      /*max_lines*/
      c[11]
    ) : (
      /*lines*/
      c[8] + 1
    ),
    placeholder: (
      /*placeholder*/
      c[9]
    ),
    show_copy_button: (
      /*show_copy_button*/
      c[16]
    ),
    autofocus: (
      /*autofocus*/
      c[20]
    ),
    container: (
      /*container*/
      c[13]
    ),
    autoscroll: (
      /*autoscroll*/
      c[21]
    ),
    disabled: !/*interactive*/
    c[22]
  };
  /*value_is_output*/
  c[1] !== void 0 && (O.value_is_output = /*value_is_output*/
  c[1]), u = new Input({
    props: O
  }), binding_callbacks.push(() => bind(u, "value_is_output", C)), u.$on(
    "change",
    /*change_handler*/
    c[36]
  ), u.$on(
    "input",
    /*input_handler*/
    c[37]
  ), u.$on(
    "submit",
    /*submit_handler*/
    c[38]
  ), u.$on(
    "blur",
    /*blur_handler*/
    c[39]
  ), u.$on(
    "select",
    /*select_handler_1*/
    c[40]
  ), u.$on(
    "focus",
    /*focus_handler*/
    c[41]
  );
  let j = ensure_array_like(
    /*_sources*/
    c[28]
  ), B = [];
  for (let P = 0; P < j.length; P += 1)
    B[P] = create_each_block(get_each_context(c, j, P));
  const D = (P) => transition_out(B[P], 1, 1, () => {
    B[P] = null;
  });
  E = new SubmitButton({
    props: {
      props: (
        /*_submit_button_props*/
        c[25]
      ),
      i18n: (
        /*gradio*/
        c[2].i18n
      ),
      disabled: !/*interactive*/
      c[22] || /*uploading*/
      c[27]
    }
  }), E.$on(
    "click",
    /*click_handler_1*/
    c[48]
  );
  let M = (
    /*value*/
    ((I = c[0].files) == null ? void 0 : I.length) && create_if_block(c)
  );
  return {
    c() {
      H && H.c(), a = space(), T && T.c(), h = space(), d = element("div"), create_component(u.$$.fragment), g = space(), $ = element("div"), b = element("span");
      for (let P = 0; P < B.length; P += 1)
        B[P].c();
      y = space(), v = element("span"), create_component(E.$$.fragment), S = space(), M && M.c(), R = empty(), this.h();
    },
    l(P) {
      H && H.l(P), a = claim_space(P), T && T.l(P), h = claim_space(P), d = claim_element(P, "DIV", {
        class: !0
      });
      var L = children(d);
      claim_component(u.$$.fragment, L), L.forEach(detach), g = claim_space(P), $ = claim_element(P, "DIV", {
        class: !0
      });
      var Y = children($);
      b = claim_element(Y, "SPAN", {
        class: !0
      });
      var N = children(b);
      for (let V = 0; V < B.length; V += 1)
        B[V].l(N);
      N.forEach(detach), y = claim_space(Y), v = claim_element(Y, "SPAN", {
        class: !0
      });
      var W = children(v);
      claim_component(E.$$.fragment, W), W.forEach(detach), Y.forEach(detach), S = claim_space(P), M && M.l(P), R = empty(), this.h();
    },
    h() {
      attr(d, "class", "input-content svelte-9felha"), attr(b, "class", "input-tools svelte-9felha"), attr(v, "class", "submit-button svelte-9felha"), attr($, "class", "controls svelte-9felha");
    },
    m(P, L) {
      H && H.m(P, L), insert_hydration(P, a, L), T && T.m(P, L), insert_hydration(P, h, L), insert_hydration(P, d, L), mount_component(u, d, null), insert_hydration(P, g, L), insert_hydration(P, $, L), append_hydration($, b);
      for (let Y = 0; Y < B.length; Y += 1)
        B[Y] && B[Y].m(b, null);
      append_hydration($, y), append_hydration($, v), mount_component(E, v, null), insert_hydration(P, S, L), M && M.m(P, L), insert_hydration(P, R, L), x = !0;
    },
    p(P, L) {
      var W;
      /*loading_status*/
      P[17] ? H ? (H.p(P, L), L[0] & /*loading_status*/
      131072 && transition_in(H, 1)) : (H = create_if_block_5(P), H.c(), transition_in(H, 1), H.m(a.parentNode, a)) : H && (group_outros(), transition_out(H, 1, 1, () => {
        H = null;
      }), check_outros()), /*show_label*/
      P[10] && /*label*/
      P[3] ? T ? (T.p(P, L), L[0] & /*show_label, label*/
      1032 && transition_in(T, 1)) : (T = create_if_block_4(P), T.c(), transition_in(T, 1), T.m(h.parentNode, h)) : T && (group_outros(), transition_out(T, 1, 1, () => {
        T = null;
      }), check_outros());
      const Y = {};
      if (L[0] & /*value*/
      1 && (Y.value = /*value*/
      P[0].text), L[0] & /*show_label*/
      1024 && (Y.show_label = /*show_label*/
      P[10]), L[0] & /*lines*/
      256 && (Y.lines = /*lines*/
      P[8]), L[0] & /*type*/
      4096 && (Y.type = /*type*/
      P[12]), L[0] & /*rtl*/
      262144 && (Y.rtl = /*rtl*/
      P[18]), L[0] & /*text_align*/
      524288 && (Y.text_align = /*text_align*/
      P[19]), L[0] & /*max_lines, lines*/
      2304 && (Y.max_lines = /*max_lines*/
      P[11] ? (
        /*max_lines*/
        P[11]
      ) : (
        /*lines*/
        P[8] + 1
      )), L[0] & /*placeholder*/
      512 && (Y.placeholder = /*placeholder*/
      P[9]), L[0] & /*show_copy_button*/
      65536 && (Y.show_copy_button = /*show_copy_button*/
      P[16]), L[0] & /*autofocus*/
      1048576 && (Y.autofocus = /*autofocus*/
      P[20]), L[0] & /*container*/
      8192 && (Y.container = /*container*/
      P[13]), L[0] & /*autoscroll*/
      2097152 && (Y.autoscroll = /*autoscroll*/
      P[21]), L[0] & /*interactive*/
      4194304 && (Y.disabled = !/*interactive*/
      P[22]), !_ && L[0] & /*value_is_output*/
      2 && (_ = !0, Y.value_is_output = /*value_is_output*/
      P[1], add_flush_callback(() => _ = !1)), u.$set(Y), L[0] & /*_upload_button_props, interactive, gradio, value, _sources, _webcam_props*/
      297795589) {
        j = ensure_array_like(
          /*_sources*/
          P[28]
        );
        let V;
        for (V = 0; V < j.length; V += 1) {
          const ue = get_each_context(P, j, V);
          B[V] ? (B[V].p(ue, L), transition_in(B[V], 1)) : (B[V] = create_each_block(ue), B[V].c(), transition_in(B[V], 1), B[V].m(b, null));
        }
        for (group_outros(), V = j.length; V < B.length; V += 1)
          D(V);
        check_outros();
      }
      const N = {};
      L[0] & /*_submit_button_props*/
      33554432 && (N.props = /*_submit_button_props*/
      P[25]), L[0] & /*gradio*/
      4 && (N.i18n = /*gradio*/
      P[2].i18n), L[0] & /*interactive, uploading*/
      138412032 && (N.disabled = !/*interactive*/
      P[22] || /*uploading*/
      P[27]), E.$set(N), /*value*/
      (W = P[0].files) != null && W.length ? M ? (M.p(P, L), L[0] & /*value*/
      1 && transition_in(M, 1)) : (M = create_if_block(P), M.c(), transition_in(M, 1), M.m(R.parentNode, R)) : M && (group_outros(), transition_out(M, 1, 1, () => {
        M = null;
      }), check_outros());
    },
    i(P) {
      if (!x) {
        transition_in(H), transition_in(T), transition_in(u.$$.fragment, P);
        for (let L = 0; L < j.length; L += 1)
          transition_in(B[L]);
        transition_in(E.$$.fragment, P), transition_in(M), x = !0;
      }
    },
    o(P) {
      transition_out(H), transition_out(T), transition_out(u.$$.fragment, P), B = B.filter(Boolean_1);
      for (let L = 0; L < B.length; L += 1)
        transition_out(B[L]);
      transition_out(E.$$.fragment, P), transition_out(M), x = !1;
    },
    d(P) {
      P && (detach(a), detach(h), detach(d), detach(g), detach($), detach(S), detach(R)), H && H.d(P), T && T.d(P), destroy_component(u), destroy_each(B, P), destroy_component(E), M && M.d(P);
    }
  };
}
function create_fragment(c) {
  let a, h;
  return a = new Block({
    props: {
      visible: (
        /*visible*/
        c[7]
      ),
      elem_id: (
        /*elem_id*/
        c[5]
      ),
      elem_classes: (
        /*elem_classes*/
        c[6]
      ),
      scale: (
        /*scale*/
        c[14]
      ),
      min_width: (
        /*min_width*/
        c[15]
      ),
      allow_overflow: !1,
      container: (
        /*container*/
        c[13]
      ),
      padding: (
        /*container*/
        c[13]
      ),
      $$slots: {
        default: [create_default_slot]
      },
      $$scope: {
        ctx: c
      }
    }
  }), {
    c() {
      create_component(a.$$.fragment);
    },
    l(d) {
      claim_component(a.$$.fragment, d);
    },
    m(d, u) {
      mount_component(a, d, u), h = !0;
    },
    p(d, u) {
      const _ = {};
      u[0] & /*visible*/
      128 && (_.visible = /*visible*/
      d[7]), u[0] & /*elem_id*/
      32 && (_.elem_id = /*elem_id*/
      d[5]), u[0] & /*elem_classes*/
      64 && (_.elem_classes = /*elem_classes*/
      d[6]), u[0] & /*scale*/
      16384 && (_.scale = /*scale*/
      d[14]), u[0] & /*min_width*/
      32768 && (_.min_width = /*min_width*/
      d[15]), u[0] & /*container*/
      8192 && (_.container = /*container*/
      d[13]), u[0] & /*container*/
      8192 && (_.padding = /*container*/
      d[13]), u[0] & /*uploading, gradio, value, _file_preview_props, interactive, _submit_button_props, _sources, _upload_button_props, _webcam_props, show_label, lines, type, rtl, text_align, max_lines, placeholder, show_copy_button, autofocus, container, autoscroll, value_is_output, info, label, loading_status*/
      536821535 | u[1] & /*$$scope*/
      33554432 && (_.$$scope = {
        dirty: u,
        ctx: d
      }), a.$set(_);
    },
    i(d) {
      h || (transition_in(a.$$.fragment, d), h = !0);
    },
    o(d) {
      transition_out(a.$$.fragment, d), h = !1;
    },
    d(d) {
      destroy_component(a, d);
    }
  };
}
function instance(c, a, h) {
  let d, {
    gradio: u
  } = a, {
    label: _ = ""
  } = a, {
    info: g = void 0
  } = a, {
    elem_id: $ = ""
  } = a, {
    elem_classes: b = []
  } = a, {
    visible: y = !0
  } = a, {
    value: v = {
      text: "",
      files: []
    }
  } = a, {
    lines: E
  } = a, {
    placeholder: S = ""
  } = a, {
    show_label: R
  } = a, {
    max_lines: x
  } = a, {
    type: H = "text"
  } = a, {
    container: T = !0
  } = a, {
    scale: C = null
  } = a, {
    min_width: O = void 0
  } = a, {
    show_copy_button: j = !1
  } = a, {
    loading_status: B = void 0
  } = a, {
    value_is_output: D = !1
  } = a, {
    rtl: M = !1
  } = a, {
    text_align: I = void 0
  } = a, {
    autofocus: P = !1
  } = a, {
    autoscroll: L = !0
  } = a, {
    interactive: Y
  } = a, {
    sources: N = ["upload"]
  } = a, {
    root: W = ""
  } = a, {
    upload_button_props: V = {}
  } = a, ue = {}, {
    webcam_props: se = {}
  } = a, ce = {}, {
    submit_button_props: oe = {}
  } = a, ge = {}, {
    file_preview_props: J = {}
  } = a, ae = {}, le = !1;
  const z = getContext("upload_files");
  setContextValue({
    upload: async (te) => {
      try {
        h(27, le = !0);
        const ye = await (z ? upload(await prepare_files(te), W, z) : u.client.upload(await prepare_files(te), W, void 0, void 0));
        return (ye == null ? void 0 : ye.filter(Boolean)) || [];
      } catch {
        return [];
      } finally {
        h(27, le = !1);
      }
    }
  });
  function F(te) {
    D = te, h(1, D);
  }
  const U = (te) => {
    h(0, v.text = te.detail, v), u.dispatch("change", v);
  }, Z = () => u.dispatch("input"), G = () => {
    le || u.dispatch("submit");
  }, Q = () => u.dispatch("blur"), he = (te) => u.dispatch("select", te.detail), me = () => u.dispatch("focus"), Te = (te) => {
    ue.file_count === "single" ? h(0, v.files = te.detail, v) : h(0, v.files = [...v.files, ...te.detail], v), u.dispatch("upload"), u.dispatch("change", v);
  };
  function Pe(te) {
    bubble.call(this, c, te);
  }
  const Re = (te) => {
    u.dispatch("error", te.detail);
  }, Me = (te) => {
    ue.file_count === "single" ? h(0, v.files = [te.detail], v) : h(0, v.files = [...v.files, te.detail], v), u.dispatch("upload"), u.dispatch("change", v);
  }, Fe = (te) => {
    u.dispatch("error", te.detail);
  }, ve = (te) => {
    ue.file_count === "single" ? h(0, v.files = [te.detail], v) : h(0, v.files = [...v.files, te.detail], v), u.dispatch("upload"), u.dispatch("change", v);
  }, be = () => u.dispatch("submit");
  function X(te) {
    bubble.call(this, c, te);
  }
  const ne = (te) => {
    h(0, v.files = v.files.filter((ye, xe) => xe !== te.detail), v), u.dispatch("change", v);
  };
  return c.$$set = (te) => {
    "gradio" in te && h(2, u = te.gradio), "label" in te && h(3, _ = te.label), "info" in te && h(4, g = te.info), "elem_id" in te && h(5, $ = te.elem_id), "elem_classes" in te && h(6, b = te.elem_classes), "visible" in te && h(7, y = te.visible), "value" in te && h(0, v = te.value), "lines" in te && h(8, E = te.lines), "placeholder" in te && h(9, S = te.placeholder), "show_label" in te && h(10, R = te.show_label), "max_lines" in te && h(11, x = te.max_lines), "type" in te && h(12, H = te.type), "container" in te && h(13, T = te.container), "scale" in te && h(14, C = te.scale), "min_width" in te && h(15, O = te.min_width), "show_copy_button" in te && h(16, j = te.show_copy_button), "loading_status" in te && h(17, B = te.loading_status), "value_is_output" in te && h(1, D = te.value_is_output), "rtl" in te && h(18, M = te.rtl), "text_align" in te && h(19, I = te.text_align), "autofocus" in te && h(20, P = te.autofocus), "autoscroll" in te && h(21, L = te.autoscroll), "interactive" in te && h(22, Y = te.interactive), "sources" in te && h(29, N = te.sources), "root" in te && h(30, W = te.root), "upload_button_props" in te && h(31, V = te.upload_button_props), "webcam_props" in te && h(32, se = te.webcam_props), "submit_button_props" in te && h(33, oe = te.submit_button_props), "file_preview_props" in te && h(34, J = te.file_preview_props);
  }, c.$$.update = () => {
    c.$$.dirty[0] & /*sources*/
    536870912 && h(28, d = Array.from(new Set(N))), c.$$.dirty[0] & /*_upload_button_props*/
    8388608 | c.$$.dirty[1] & /*upload_button_props*/
    1 && h(23, ue = {
      ...ue,
      ...V
    }), c.$$.dirty[0] & /*_webcam_props*/
    16777216 | c.$$.dirty[1] & /*webcam_props*/
    2 && h(24, ce = {
      ...ce,
      ...se
    }), c.$$.dirty[0] & /*_submit_button_props*/
    33554432 | c.$$.dirty[1] & /*submit_button_props*/
    4 && h(25, ge = {
      ...ge,
      ...oe
    }), c.$$.dirty[0] & /*_file_preview_props*/
    67108864 | c.$$.dirty[1] & /*file_preview_props*/
    8 && h(26, ae = {
      ...ae,
      ...J
    });
  }, [v, D, u, _, g, $, b, y, E, S, R, x, H, T, C, O, j, B, M, I, P, L, Y, ue, ce, ge, ae, le, d, N, W, V, se, oe, J, F, U, Z, G, Q, he, me, Te, Pe, Re, Me, Fe, ve, be, X, ne];
}
class Awaited extends SvelteComponent {
  constructor(a) {
    super(), init(this, a, instance, create_fragment, safe_not_equal, {
      gradio: 2,
      label: 3,
      info: 4,
      elem_id: 5,
      elem_classes: 6,
      visible: 7,
      value: 0,
      lines: 8,
      placeholder: 9,
      show_label: 10,
      max_lines: 11,
      type: 12,
      container: 13,
      scale: 14,
      min_width: 15,
      show_copy_button: 16,
      loading_status: 17,
      value_is_output: 1,
      rtl: 18,
      text_align: 19,
      autofocus: 20,
      autoscroll: 21,
      interactive: 22,
      sources: 29,
      root: 30,
      upload_button_props: 31,
      webcam_props: 32,
      submit_button_props: 33,
      file_preview_props: 34
    }, null, [-1, -1]);
  }
  get gradio() {
    return this.$$.ctx[2];
  }
  set gradio(a) {
    this.$$set({
      gradio: a
    }), flush();
  }
  get label() {
    return this.$$.ctx[3];
  }
  set label(a) {
    this.$$set({
      label: a
    }), flush();
  }
  get info() {
    return this.$$.ctx[4];
  }
  set info(a) {
    this.$$set({
      info: a
    }), flush();
  }
  get elem_id() {
    return this.$$.ctx[5];
  }
  set elem_id(a) {
    this.$$set({
      elem_id: a
    }), flush();
  }
  get elem_classes() {
    return this.$$.ctx[6];
  }
  set elem_classes(a) {
    this.$$set({
      elem_classes: a
    }), flush();
  }
  get visible() {
    return this.$$.ctx[7];
  }
  set visible(a) {
    this.$$set({
      visible: a
    }), flush();
  }
  get value() {
    return this.$$.ctx[0];
  }
  set value(a) {
    this.$$set({
      value: a
    }), flush();
  }
  get lines() {
    return this.$$.ctx[8];
  }
  set lines(a) {
    this.$$set({
      lines: a
    }), flush();
  }
  get placeholder() {
    return this.$$.ctx[9];
  }
  set placeholder(a) {
    this.$$set({
      placeholder: a
    }), flush();
  }
  get show_label() {
    return this.$$.ctx[10];
  }
  set show_label(a) {
    this.$$set({
      show_label: a
    }), flush();
  }
  get max_lines() {
    return this.$$.ctx[11];
  }
  set max_lines(a) {
    this.$$set({
      max_lines: a
    }), flush();
  }
  get type() {
    return this.$$.ctx[12];
  }
  set type(a) {
    this.$$set({
      type: a
    }), flush();
  }
  get container() {
    return this.$$.ctx[13];
  }
  set container(a) {
    this.$$set({
      container: a
    }), flush();
  }
  get scale() {
    return this.$$.ctx[14];
  }
  set scale(a) {
    this.$$set({
      scale: a
    }), flush();
  }
  get min_width() {
    return this.$$.ctx[15];
  }
  set min_width(a) {
    this.$$set({
      min_width: a
    }), flush();
  }
  get show_copy_button() {
    return this.$$.ctx[16];
  }
  set show_copy_button(a) {
    this.$$set({
      show_copy_button: a
    }), flush();
  }
  get loading_status() {
    return this.$$.ctx[17];
  }
  set loading_status(a) {
    this.$$set({
      loading_status: a
    }), flush();
  }
  get value_is_output() {
    return this.$$.ctx[1];
  }
  set value_is_output(a) {
    this.$$set({
      value_is_output: a
    }), flush();
  }
  get rtl() {
    return this.$$.ctx[18];
  }
  set rtl(a) {
    this.$$set({
      rtl: a
    }), flush();
  }
  get text_align() {
    return this.$$.ctx[19];
  }
  set text_align(a) {
    this.$$set({
      text_align: a
    }), flush();
  }
  get autofocus() {
    return this.$$.ctx[20];
  }
  set autofocus(a) {
    this.$$set({
      autofocus: a
    }), flush();
  }
  get autoscroll() {
    return this.$$.ctx[21];
  }
  set autoscroll(a) {
    this.$$set({
      autoscroll: a
    }), flush();
  }
  get interactive() {
    return this.$$.ctx[22];
  }
  set interactive(a) {
    this.$$set({
      interactive: a
    }), flush();
  }
  get sources() {
    return this.$$.ctx[29];
  }
  set sources(a) {
    this.$$set({
      sources: a
    }), flush();
  }
  get root() {
    return this.$$.ctx[30];
  }
  set root(a) {
    this.$$set({
      root: a
    }), flush();
  }
  get upload_button_props() {
    return this.$$.ctx[31];
  }
  set upload_button_props(a) {
    this.$$set({
      upload_button_props: a
    }), flush();
  }
  get webcam_props() {
    return this.$$.ctx[32];
  }
  set webcam_props(a) {
    this.$$set({
      webcam_props: a
    }), flush();
  }
  get submit_button_props() {
    return this.$$.ctx[33];
  }
  set submit_button_props(a) {
    this.$$set({
      submit_button_props: a
    }), flush();
  }
  get file_preview_props() {
    return this.$$.ctx[34];
  }
  set file_preview_props(a) {
    this.$$set({
      file_preview_props: a
    }), flush();
  }
}
export {
  Example as BaseExample,
  Input as BaseTextbox,
  Awaited as default
};
